/*! hash:ae6a15474fa7d9a1f9f8, chunkhash:92caaabc7d6ba0ab89f7, name:85, filebase:85.bundle.js, query:, file:javascripts/chunks/85.bundle.js */
webpackJsonp([85],{

/***/ 780:
/***/ (function(module, exports) {

eval("(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"filbert\"] = factory();\n\telse\n\t\troot[\"filbert\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Sk = __webpack_require__(1);\n\tvar transform = __webpack_require__(2);\n\tvar improveError = __webpack_require__(3);\n\n\tvar defaultOptions = {\n\t\tlocations: true,\n\t\tranges: true,\n\t\tsippets: true,\n\t\tfilename: 'file.py',\n\t\tuseLet: false,\n\t\tfriendlyErrors: true\n\t};\n\n\tfunction rangeToLoc(x, offsets) {\n\t\tvar best = -1;\n\t\tfor ( var i = 0; i < offsets.length; ++i ) {\n\t\t\tif ( offsets[i] > x ) break;\n\t\t\tbest = i;\n\t\t}\n\t\tvar off = best >= 0 ? offsets[best] : 0;\n\t\treturn {line: best+2, column: x - off, pos: x };\n\t}\n\n\tfunction locToRange(line, col, offsets) {\n\t\tvar loff = 0;\n\t\tif ( line > 2 && (line-2) < offsets.length ) loff = offsets[line-2];\n\t\treturn loff + col;\n\t}\n\n\tfunction decorate(n, code, offsets, options) {\n\t\tvar numrange = locToRange(n.lineno, n.col_offset, offsets);\n\n\t\tvar range = [\n\t\t\tnumrange === numrange ? numrange : Infinity,\n\t\t\tnumrange === numrange ? numrange : -Infinity\n\t\t];\n\t\t\n\t\tif ( n.value ) range[1] += (n.value.length);\n\n\t\tif ( n.children )\n\t\tfor ( var i = 0; i < n.children.length; ++i ) {\n\t\t\tvar r = decorate(n.children[i], code, offsets, options);\n\t\t\trange[0] = Math.min(range[0], r[0]);\n\t\t\trange[1] = Math.max(range[1], r[1]);\n\t\t}\n\n\t\tif ( options.ranges ) n.range = range;\n\t\tif ( options.locations ) {\n\t\t\tn.loc = {\n\t\t\t\tstart: rangeToLoc(range[0], offsets),\n\t\t\t\tend: rangeToLoc(range[1], offsets),\n\t\t\t};\n\t\t}\n\t\tif ( options.snippets ) n.str = code.substring(range[0], range[1]);\n\n\t\treturn range;\n\t}\n\n\tfunction parser(code, options) {\n\t\tvar lineOffsets = [];\n\t\tvar idx = -1;\n\t\tvar parse, ast;\n\t\toptions = options || {};\n\t\tfor ( var opt in defaultOptions ) {\n\t\t\tif ( !(opt in options) ) options[opt] = defaultOptions[opt];\n\t\t}\n\n\t\twhile ( true ) {\n\t\t\tidx = code.indexOf(\"\\n\", idx+1);\n\t\t\tif ( idx < 0 ) break;\n\t\t\tlineOffsets.push(idx+1);\n\t\t}\n\n\t\ttry {\n\t\t\tparse = Sk.parse(options.filename, code);\n\t\t\tdecorate(parse.cst, code, lineOffsets, options);\n\t\t\tparse.flags = parse.flags | Sk.Parser.CO_FUTURE_UNICODE_LITERALS; //Enable future unicode literals\n\t\t\tast = Sk.astFromParse(parse.cst, options.filename, parse.flags);\n\t\t} catch ( e ) {\n\t\t\tif ( e.extra && e.extra.node ) decorate(e.extra.node, code, lineOffsets, options);\n\t\t\timproveError(e, options, code);\n\t\t\tif ( e.loc ) {\n\t\t\t\te.pos = locToRange(e.loc.line, e.loc.column, lineOffsets);\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\n\t\t//console.log(JSON.stringify(ast, null, \"  \"));\n\t\tvar ctx = {varType: (options.useLet ? 'let' : 'var')};\n\t\tvar js = transform(ast, ctx);\n\t\treturn js;\n\t}\n\n\tmodule.exports = {\n\t\tparse: parser,\n\t\tpythonRuntime: __webpack_require__(4),\n\t\tdefaultOptions: {runtimeParamName: '__pythonRuntime'}\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/* ---- /Users/rob/skulpty/lib/preamble.js ---- */ \n\n\tvar goog = {\n\t\tglobal: global\n\t};\n\n\tvar COMPILED = false;\n\n\tgoog.exportSymbol = function() {};\n\tgoog.require = function() {};\n\n\tgoog.inherits = function(childCtor, parentCtor) {\n\t  if ( !parentCtor ) throw new Error(\"Cant inherit from undefined?\");\n\t  /** @constructor */\n\t  function tempCtor() {};\n\t  tempCtor.prototype = parentCtor.prototype;\n\t  childCtor.superClass_ = parentCtor.prototype;\n\t  childCtor.prototype = new tempCtor();\n\t  /** @override */\n\t  childCtor.prototype.constructor = childCtor;\n\t};\n\n\tgoog.asserts = {\n\t\tassert: function(what, why) {\n\t        if ( !what ) throw new Error(\"AssertionFailed:\" + why);\n\t    }\n\t};\n\n\tvar Sk = Sk || {};\n\n\tSk.builtin = Sk.builtin  ||  {};\n\n\tSk.builtin.bool = Boolean;\n\tSk.builtin.int_ = function Int(x) {\n\t  this.v = x;\n\t};\n\n\tSk.builtin.int_.prototype.threshold$ = Infinity;\n\tSk.builtin.int_.prototype.valueOf = function() { return this.v.valueOf(); };\n\n\tSk.builtin.tuple = function(x) {\n\t  this.v = Array.prototype.slice.call(x, 0);\n\t};\n\tSk.builtin.tuple.prototype.sq$length = function() { return this.length; };\n\n\tSk.builtin.float_ = Number;\n\tSk.builtin.long = Number;\n\tSk.builtin.func = function(fx) { return fx; };\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/type.js ---- */ \n\n\tif(Sk.builtin === undefined) {\n\t    Sk.builtin = {};\n\t}\n\n\t/**\n\t * Maps Python dunder names to the Skulpt Javascript function names that\n\t * implement them.\n\t *\n\t * Note: __add__, __mul__, and __rmul__ can be used for either numeric or\n\t * sequence types. Here, they default to the numeric versions (i.e. nb$add,\n\t * nb$multiply, and nb$reflected_multiply). This works because Sk.abstr.binary_op_\n\t * checks for the numeric shortcuts and not the sequence shortcuts when computing\n\t * a binary operation.\n\t *\n\t * Because many of these functions are used in contexts in which Skulpt does not\n\t * [yet] handle suspensions, the assumption is that they must not suspend. However,\n\t * some of these built-in functions are acquiring 'canSuspend' arguments to signal\n\t * where this is not the case. These need to be spliced out of the argument list before\n\t * it is passed to python. Array values in this map contain [dunderName, argumentIdx],\n\t * where argumentIdx specifies the index of the 'canSuspend' boolean argument.\n\t *\n\t * @type {Object}\n\t */\n\tSk.dunderToSkulpt = {\n\t    \"__eq__\": \"ob$eq\",\n\t    \"__ne__\": \"ob$ne\",\n\t    \"__lt__\": \"ob$lt\",\n\t    \"__le__\": \"ob$le\",\n\t    \"__gt__\": \"ob$gt\",\n\t    \"__ge__\": \"ob$ge\",\n\t    \"__hash__\": \"tp$hash\",\n\t    \"__abs__\": \"nb$abs\",\n\t    \"__neg__\": \"nb$negative\",\n\t    \"__pos__\": \"nb$positive\",\n\t    \"__int__\": \"nb$int_\",\n\t    \"__long__\": \"nb$lng\",\n\t    \"__float__\": \"nb$float_\",\n\t    \"__add__\": \"nb$add\",\n\t    \"__radd__\": \"nb$reflected_add\",\n\t    \"__sub__\": \"nb$subtract\",\n\t    \"__rsub__\": \"nb$reflected_subtract\",\n\t    \"__mul__\": \"nb$multiply\",\n\t    \"__rmul__\": \"nb$reflected_multiply\",\n\t    \"__div__\": \"nb$divide\",\n\t    \"__rdiv__\": \"nb$reflected_divide\",\n\t    \"__floordiv__\": \"nb$floor_divide\",\n\t    \"__rfloordiv__\": \"nb$reflected_floor_divide\",\n\t    \"__mod__\": \"nb$remainder\",\n\t    \"__rmod__\": \"nb$reflected_remainder\",\n\t    \"__divmod__\": \"nb$divmod\",\n\t    \"__rdivmod__\": \"nb$reflected_divmod\",\n\t    \"__pow__\": \"nb$power\",\n\t    \"__rpow__\": \"nb$reflected_power\",\n\t    \"__contains__\": \"sq$contains\",\n\t    \"__len__\": [\"sq$length\", 0]\n\t};\n\n\t/**\n\t *\n\t * @constructor\n\t *\n\t * @param {*} name name or object to get type of, if only one arg\n\t *\n\t * @param {Sk.builtin.tuple=} bases\n\t *\n\t * @param {Object=} dict\n\t *\n\t *\n\t * This type represents the type of `type'. *Calling* an instance of\n\t * this builtin type named \"type\" creates class objects. The resulting\n\t * class objects will have various tp$xyz attributes on them that allow\n\t * for the various operations on that object.\n\t *\n\t * calling the type or calling an instance of the type? or both?\n\t */\n\tSk.builtin.type = function (name, bases, dict) {\n\t    var mro;\n\t    var obj;\n\t    var klass;\n\t    var v;\n\t    if (bases === undefined && dict === undefined) {\n\t        // 1 arg version of type()\n\t        // the argument is an object, not a name and returns a type object\n\t        obj = name;\n\t        return obj.ob$type;\n\t    } else {\n\n\t        // argument dict must be of type dict\n\t        if(dict.tp$name !== \"dict\") {\n\t            throw new Sk.builtin.TypeError(\"type() argument 3 must be dict, not \" + Sk.abstr.typeName(dict));\n\t        }\n\n\t        // checks if name must be string\n\t        if(!Sk.builtin.checkString(name)) {\n\t            throw new Sk.builtin.TypeError(\"type() argument 1 must be str, not \" + Sk.abstr.typeName(name));\n\t        }\n\n\t        // argument bases must be of type tuple\n\t        if(bases.tp$name !== \"tuple\") {\n\t            throw new Sk.builtin.TypeError(\"type() argument 2 must be tuple, not \" + Sk.abstr.typeName(bases));\n\t        }\n\n\t        // type building version of type\n\n\t        // dict is the result of running the classes code object\n\t        // (basically the dict of functions). those become the prototype\n\t        // object of the class).\n\t        /**\n\t        * @constructor\n\t        */\n\t        klass = function (kwdict, varargseq, kws, args, canSuspend) {\n\t            var init;\n\t            var self = this;\n\t            var s;\n\t            var args_copy;\n\t            if (!(this instanceof klass)) {\n\t                return new klass(kwdict, varargseq, kws, args, canSuspend);\n\t            }\n\n\t            args = args || [];\n\t            self[\"$d\"] = new Sk.builtin.dict([]);\n\t            self[\"$d\"].mp$ass_subscript(new Sk.builtin.str(\"__dict__\"), self[\"$d\"]);\n\n\t            if (klass.prototype.tp$base !== undefined) {\n\t                if (klass.prototype.tp$base.sk$klass) {\n\t                    klass.prototype.tp$base.call(this, kwdict, varargseq, kws, args.slice(), canSuspend);\n\t                } else {\n\t                    // Call super constructor if subclass of a builtin\n\t                    args_copy = args.slice();\n\t                    args_copy.unshift(klass, this);\n\t                    Sk.abstr.superConstructor.apply(undefined, args_copy);\n\t                }\n\t            }\n\n\t            init = Sk.builtin.type.typeLookup(self.ob$type, \"__init__\");\n\t            if (init !== undefined) {\n\t                // return should be None or throw a TypeError otherwise\n\t                args.unshift(self);\n\t                s = Sk.misceval.applyOrSuspend(init, kwdict, varargseq, kws, args);\n\n\t                return (function doSusp(s) {\n\t                    if (s instanceof Sk.misceval.Suspension) {\n\t                        // TODO I (Meredydd) don't know whether we are ever called\n\t                        // from anywhere except Sk.misceval.applyOrSuspend().\n\t                        // If we're not, we don't need a canSuspend parameter at all.\n\t                        if (canSuspend) {\n\t                            return new Sk.misceval.Suspension(doSusp, s);\n\t                        } else {\n\t                            return Sk.misceval.retryOptionalSuspensionOrThrow(s);\n\t                        }\n\t                    } else {\n\t                        return self;\n\t                    }\n\t                })(s);\n\t            }\n\n\t            return self;\n\t        };\n\n\t        var _name = Sk.ffi.remapToJs(name); // unwrap name string to js for latter use\n\n\t        var inheritsFromObject = false, inheritsBuiltin = false;\n\n\t        if (bases.v.length === 0 && Sk.python3) {\n\t            // new style class, inherits from object by default\n\t            inheritsFromObject = true;\n\t            Sk.abstr.setUpInheritance(_name, klass, Sk.builtin.object);\n\t        }\n\n\t        var parent, it, firstAncestor, builtin_bases = [];\n\t        // Set up inheritance from any builtins\n\t        for (it = bases.tp$iter(), parent = it.tp$iternext(); parent !== undefined; parent = it.tp$iternext()) {\n\t            if (firstAncestor === undefined) {\n\t                firstAncestor = parent;\n\t            }\n\t            if (parent.prototype instanceof Sk.builtin.object || parent === Sk.builtin.object) {\n\n\t                while (parent.sk$klass && parent.prototype.tp$base) {\n\t                    parent = parent.prototype.tp$base;\n\t                }\n\n\t                if (!parent.sk$klass && builtin_bases.indexOf(parent) < 0) {\n\t                    builtin_bases.push(parent);\n\t                }\n\n\t                // This class inherits from Sk.builtin.object at some level\n\t                inheritsFromObject = true;\n\t            }\n\t        }\n\n\t        if (builtin_bases.length > 1) {\n\t            throw new Sk.builtin.TypeError(\"Multiple inheritance with more than one builtin type is unsupported\");\n\t        }\n\n\t        // Javascript does not support multiple inheritance, so only the first\n\t        // base (if any) will directly inherit in Javascript\n\t        if (firstAncestor !== undefined) {\n\t            goog.inherits(klass, firstAncestor);\n\n\t            if (firstAncestor.prototype instanceof Sk.builtin.object || firstAncestor === Sk.builtin.object) {\n\t                klass.prototype.tp$base = firstAncestor;\n\t            }\n\t        }\n\n\t        klass.prototype.tp$name = _name;\n\t        klass.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(_name, klass);\n\n\t        if (!inheritsFromObject) {\n\t            // old style class, does not inherit from object\n\t            klass.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\t            klass.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n\t        }\n\n\t        // set __module__ if not present (required by direct type(name, bases, dict) calls)\n\t        var module_lk = new Sk.builtin.str(\"__module__\");\n\t        if(dict.mp$lookup(module_lk) === undefined) {\n\t            dict.mp$ass_subscript(module_lk, Sk.globals[\"__name__\"]);\n\t        }\n\n\t        // copy properties into our klass object\n\t        // uses python iter methods\n\t        var k;\n\t        for (it = dict.tp$iter(), k = it.tp$iternext(); k !== undefined; k = it.tp$iternext()) {\n\t            v = dict.mp$subscript(k);\n\t            if (v === undefined) {\n\t                v = null;\n\t            }\n\t            klass.prototype[k.v] = v;\n\t            klass[k.v] = v;\n\t        }\n\n\t        klass[\"__class__\"] = klass;\n\t        klass[\"__name__\"] = name;\n\t        klass.sk$klass = true;\n\t        klass.prototype.tp$descr_get = function () {\n\t            goog.asserts.fail(\"in type tp$descr_get\");\n\t        };\n\t        klass.prototype[\"$r\"] = function () {\n\t            var cname;\n\t            var mod;\n\t            // TODO use Sk.abstr.gattr() here so __repr__ can be dynamically provided (eg by __getattr__())\n\t            var reprf = this.tp$getattr(\"__repr__\");\n\t            if (reprf !== undefined && reprf.im_func !== Sk.builtin.object.prototype[\"__repr__\"]) {\n\t                return Sk.misceval.apply(reprf, undefined, undefined, undefined, []);\n\t            }\n\n\t            if ((klass.prototype.tp$base !== undefined) &&\n\t                (klass.prototype.tp$base !== Sk.builtin.object) &&\n\t                (klass.prototype.tp$base.prototype[\"$r\"] !== undefined)) {\n\t                // If subclass of a builtin which is not object, use that class' repr\n\t                return klass.prototype.tp$base.prototype[\"$r\"].call(this);\n\t            } else {\n\t                // Else, use default repr for a user-defined class instance\n\t                mod = dict.mp$subscript(module_lk); // lookup __module__\n\t                cname = \"\";\n\t                if (mod) {\n\t                    cname = mod.v + \".\";\n\t                }\n\t                return new Sk.builtin.str(\"<\" + cname + _name + \" object>\");\n\t            }\n\t        };\n\t        klass.prototype.tp$str = function () {\n\t            // TODO use Sk.abstr.gattr() here so __str__ can be dynamically provided (eg by __getattr__())\n\t            var strf = this.tp$getattr(\"__str__\");\n\t            if (strf !== undefined && strf.im_func !== Sk.builtin.object.prototype[\"__str__\"]) {\n\t                return Sk.misceval.apply(strf, undefined, undefined, undefined, []);\n\t            }\n\t            if ((klass.prototype.tp$base !== undefined) &&\n\t                (klass.prototype.tp$base !== Sk.builtin.object) &&\n\t                (klass.prototype.tp$base.prototype.tp$str !== undefined)) {\n\t                // If subclass of a builtin which is not object, use that class' repr\n\t                return klass.prototype.tp$base.prototype.tp$str.call(this);\n\t            }\n\t            return this[\"$r\"]();\n\t        };\n\t        klass.prototype.tp$length = function (canSuspend) {\n\t            var r = Sk.misceval.chain(Sk.abstr.gattr(this, \"__len__\", canSuspend), function(lenf) {\n\t                return Sk.misceval.applyOrSuspend(lenf, undefined, undefined, undefined, []);\n\t            });\n\t            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t        };\n\t        klass.prototype.tp$call = function (args, kw) {\n\t            return Sk.misceval.chain(Sk.abstr.gattr(this, \"__call__\", true), function(callf) {\n\t                return Sk.misceval.applyOrSuspend(callf, undefined, undefined, kw, args);\n\t            });\n\t        };\n\t        klass.prototype.tp$iter = function () {\n\t            var iterf = Sk.abstr.gattr(this, \"__iter__\", false);\n\t            return Sk.misceval.callsim(iterf);\n\t        };\n\t        klass.prototype.tp$iternext = function (canSuspend) {\n\t            var self = this;\n\t            var r = Sk.misceval.chain(\n\t                Sk.misceval.tryCatch(function() {\n\t                    return Sk.abstr.gattr(self, \"next\", canSuspend);\n\t                }, function(e) {\n\t                    if (e instanceof Sk.builtin.AttributeError) {\n\t                        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(self) + \"' object is not iterable\");\n\t                    } else {\n\t                        throw e;\n\t                    }\n\t                }),\n\t            function(/** {Object} */ iternextf) {\n\t                return Sk.misceval.tryCatch(function() {\n\t                    return Sk.misceval.callsimOrSuspend(iternextf);\n\t                }, function(e) {\n\t                    if (e instanceof Sk.builtin.StopIteration) {\n\t                        return undefined;\n\t                    } else {\n\t                        throw e;\n\t                    }\n\t                });\n\t            });\n\n\t            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t        };\n\n\t        klass.prototype.tp$getitem = function (key, canSuspend) {\n\t            var getf = Sk.abstr.gattr(this, \"__getitem__\", canSuspend), r;\n\t            if (getf !== undefined) {\n\t                r = Sk.misceval.applyOrSuspend(getf, undefined, undefined, undefined, [key]);\n\t                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t            }\n\t            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support indexing\");\n\t        };\n\t        klass.prototype.tp$setitem = function (key, value, canSuspend) {\n\t            var setf = Sk.abstr.gattr(this, \"__setitem__\", canSuspend), r;\n\t            if (setf !== undefined) {\n\t                r = Sk.misceval.applyOrSuspend(setf, undefined, undefined, undefined, [key, value]);\n\t                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t            }\n\t            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support item assignment\");\n\t        };\n\n\t        if (bases) {\n\t            //print(\"building mro for\", name);\n\t            //for (var i = 0; i < bases.length; ++i)\n\t            //print(\"base[\" + i + \"]=\" + bases[i].tp$name);\n\t            klass[\"$d\"] = new Sk.builtin.dict([]);\n\t            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.basesStr_, bases);\n\t            mro = Sk.builtin.type.buildMRO(klass);\n\t            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);\n\t            klass.tp$mro = mro;\n\t            //print(\"mro result\", Sk.builtin.repr(mro).v);\n\t        }\n\n\t        // fix for class attributes\n\t        klass.tp$setattr = Sk.builtin.type.prototype.tp$setattr;\n\n\t        var shortcutDunder = function (skulpt_name, magic_name, magic_func, canSuspendIdx) {\n\t            klass.prototype[skulpt_name] = function () {\n\t                var args = Array.prototype.slice.call(arguments), canSuspend;\n\t                args.unshift(magic_func, this);\n\n\t                if (canSuspendIdx) {\n\t                    canSuspend = args[canSuspendIdx+1];\n\t                    args.splice(canSuspendIdx+1, 1);\n\t                    if (canSuspend) {\n\t                        return Sk.misceval.callsimOrSuspend.apply(undefined, args);\n\t                    }\n\t                }\n\t                return Sk.misceval.callsim.apply(undefined, args);\n\t            };\n\t        };\n\n\t        // Register skulpt shortcuts to magic methods defined by this class.\n\t        // TODO: This is somewhat problematic, as it means that dynamically defined\n\t        // methods (eg those returned by __getattr__()) cannot be used by these magic\n\t        // functions.\n\t        var dunder, skulpt_name, canSuspendIdx;\n\t        for (dunder in Sk.dunderToSkulpt) {\n\t            skulpt_name = Sk.dunderToSkulpt[dunder];\n\t            if (typeof(skulpt_name) === \"string\") {\n\t                canSuspendIdx = null;\n\t            } else {\n\t                canSuspendIdx = skulpt_name[1];\n\t                skulpt_name = skulpt_name[0];\n\t            }\n\n\t            if (klass[dunder]) {\n\t                // scope workaround\n\t                shortcutDunder(skulpt_name, dunder, klass[dunder], canSuspendIdx);\n\t            }\n\t        }\n\n\t        return klass;\n\t    }\n\n\t};\n\n\t/**\n\t *\n\t */\n\tSk.builtin.type.makeTypeObj = function (name, newedInstanceOfType) {\n\t    Sk.builtin.type.makeIntoTypeObj(name, newedInstanceOfType);\n\t    return newedInstanceOfType;\n\t};\n\n\tSk.builtin.type.makeIntoTypeObj = function (name, t) {\n\t    goog.asserts.assert(name !== undefined);\n\t    goog.asserts.assert(t !== undefined);\n\t    t.ob$type = Sk.builtin.type;\n\t    t.tp$name = name;\n\t    t[\"$r\"] = function () {\n\t        var ctype;\n\t        var mod = t.__module__;\n\t        var cname = \"\";\n\t        if (mod) {\n\t            cname = mod.v + \".\";\n\t        }\n\t        ctype = \"class\";\n\t        if (!mod && !t.sk$klass && !Sk.python3) {\n\t            ctype = \"type\";\n\t        }\n\t        return new Sk.builtin.str(\"<\" + ctype + \" '\" + cname + t.tp$name + \"'>\");\n\t    };\n\t    t.tp$str = undefined;\n\t    t.tp$getattr = Sk.builtin.type.prototype.tp$getattr;\n\t    t.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n\t    t.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;\n\t    t.sk$type = true;\n\n\t    return t;\n\t};\n\n\tSk.builtin.type.ob$type = Sk.builtin.type;\n\tSk.builtin.type.tp$name = \"type\";\n\tSk.builtin.type[\"$r\"] = function () {\n\t    if(Sk.python3) {\n\t        return new Sk.builtin.str(\"<class 'type'>\");\n\t    } else {\n\t        return new Sk.builtin.str(\"<type 'type'>\");\n\t    }\n\t};\n\n\t//Sk.builtin.type.prototype.tp$descr_get = function() { print(\"in type descr_get\"); };\n\n\t//Sk.builtin.type.prototype.tp$name = \"type\";\n\n\t// basically the same as GenericGetAttr except looks in the proto instead\n\tSk.builtin.type.prototype.tp$getattr = function (name) {\n\t    var res;\n\t    var tp = this;\n\t    var descr;\n\t    var f;\n\n\t    if (this[\"$d\"]) {\n\t        res = this[\"$d\"].mp$lookup(new Sk.builtin.str(name));\n\t        if (res !== undefined) {\n\t            return res;\n\t        }\n\t    }\n\n\t    descr = Sk.builtin.type.typeLookup(tp, name);\n\n\t    //print(\"type.tpgetattr descr\", descr, descr.tp$name, descr.func_code, name);\n\t    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\n\t        f = descr.ob$type.tp$descr_get;\n\t        // todo;if (f && descr.tp$descr_set) // is a data descriptor if it has a set\n\t        // return f.call(descr, this, this.ob$type);\n\t    }\n\n\t    if (f) {\n\t        // non-data descriptor\n\t        return f.call(descr, null, tp);\n\t    }\n\n\t    if (descr !== undefined) {\n\t        return descr;\n\t    }\n\n\t    return undefined;\n\t};\n\n\tSk.builtin.type.prototype.tp$setattr = function (name, value) {\n\t    // class attributes are direct properties of the object\n\t    this[name] = value;\n\t};\n\n\tSk.builtin.type.typeLookup = function (type, name) {\n\t    var mro = type.tp$mro;\n\t    var pyname = new Sk.builtin.str(name);\n\t    var base;\n\t    var res;\n\t    var i;\n\n\t    // todo; probably should fix this, used for builtin types to get stuff\n\t    // from prototype\n\t    if (!mro) {\n\t        if (type.prototype) {\n\t            return type.prototype[name];\n\t        }\n\t        return undefined;\n\t    }\n\n\t    for (i = 0; i < mro.v.length; ++i) {\n\t        base = mro.v[i];\n\t        if (base.hasOwnProperty(name)) {\n\t            return base[name];\n\t        }\n\t        res = base[\"$d\"].mp$lookup(pyname);\n\t        if (res !== undefined) {\n\t            return res;\n\t        }\n\t        if (base.prototype && base.prototype[name] !== undefined) {\n\t            return base.prototype[name];\n\t        }\n\t    }\n\n\t    return undefined;\n\t};\n\n\tSk.builtin.type.mroMerge_ = function (seqs) {\n\t    /*\n\t     var tmp = [];\n\t     for (var i = 0; i < seqs.length; ++i)\n\t     {\n\t     tmp.push(new Sk.builtin.list(seqs[i]));\n\t     }\n\t     print(Sk.builtin.repr(new Sk.builtin.list(tmp)).v);\n\t     */\n\t    var seq;\n\t    var i;\n\t    var next;\n\t    var k;\n\t    var sseq;\n\t    var j;\n\t    var cand;\n\t    var cands;\n\t    var res = [];\n\t    for (; ;) {\n\t        for (i = 0; i < seqs.length; ++i) {\n\t            seq = seqs[i];\n\t            if (seq.length !== 0) {\n\t                break;\n\t            }\n\t        }\n\t        if (i === seqs.length) { // all empty\n\t            return res;\n\t        }\n\t        cands = [];\n\t        for (i = 0; i < seqs.length; ++i) {\n\t            seq = seqs[i];\n\t            //print(\"XXX\", Sk.builtin.repr(new Sk.builtin.list(seq)).v);\n\t            if (seq.length !== 0) {\n\t                cand = seq[0];\n\t                //print(\"CAND\", Sk.builtin.repr(cand).v);\n\t                OUTER:\n\t                    for (j = 0; j < seqs.length; ++j) {\n\t                        sseq = seqs[j];\n\t                        for (k = 1; k < sseq.length; ++k) {\n\t                            if (sseq[k] === cand) {\n\t                                break OUTER;\n\t                            }\n\t                        }\n\t                    }\n\n\t                // cand is not in any sequences' tail -> constraint-free\n\t                if (j === seqs.length) {\n\t                    cands.push(cand);\n\t                }\n\t            }\n\t        }\n\n\t        if (cands.length === 0) {\n\t            throw new Sk.builtin.TypeError(\"Inconsistent precedences in type hierarchy\");\n\t        }\n\n\t        next = cands[0];\n\t        // append next to result and remove from sequences\n\t        res.push(next);\n\t        for (i = 0; i < seqs.length; ++i) {\n\t            seq = seqs[i];\n\t            if (seq.length > 0 && seq[0] === next) {\n\t                seq.splice(0, 1);\n\t            }\n\t        }\n\t    }\n\t};\n\n\tSk.builtin.type.buildMRO_ = function (klass) {\n\t    // MERGE(klass + mro(bases) + bases)\n\t    var i;\n\t    var bases;\n\t    var all = [\n\t        [klass]\n\t    ];\n\n\t    //Sk.debugout(\"buildMRO for\", klass.tp$name);\n\n\t    var kbases = klass[\"$d\"].mp$subscript(Sk.builtin.type.basesStr_);\n\t    for (i = 0; i < kbases.v.length; ++i) {\n\t        all.push(Sk.builtin.type.buildMRO_(kbases.v[i]));\n\t    }\n\n\t    bases = [];\n\t    for (i = 0; i < kbases.v.length; ++i) {\n\t        bases.push(kbases.v[i]);\n\t    }\n\t    all.push(bases);\n\n\t    return Sk.builtin.type.mroMerge_(all);\n\t};\n\n\t/*\n\t * C3 MRO (aka CPL) linearization. Figures out which order to search through\n\t * base classes to determine what should override what. C3 does the \"right\n\t * thing\", and it's what Python has used since 2.3.\n\t *\n\t * Kind of complicated to explain, but not really that complicated in\n\t * implementation. Explanations:\n\t *\n\t * http://people.csail.mit.edu/jrb/goo/manual.43/goomanual_55.html\n\t * http://www.python.org/download/releases/2.3/mro/\n\t * http://192.220.96.201/dylan/linearization-oopsla96.html\n\t *\n\t * This implementation is based on a post by Samuele Pedroni on python-dev\n\t * (http://mail.python.org/pipermail/python-dev/2002-October/029176.html) when\n\t * discussing its addition to Python.\n\t */\n\tSk.builtin.type.buildMRO = function (klass) {\n\t    return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(klass));\n\t};\n\n\tSk.builtin.type.prototype.tp$richcompare = function (other, op) {\n\t    var r2;\n\t    var r1;\n\t    if (other.ob$type != Sk.builtin.type) {\n\t        return undefined;\n\t    }\n\t    if (!this[\"$r\"] || !other[\"$r\"]) {\n\t        return undefined;\n\t    }\n\t    r1 = new Sk.builtin.str(this[\"$r\"]().v.slice(1,6));\n\t    r2 = new Sk.builtin.str(other[\"$r\"]().v.slice(1,6));\n\t    if (this[\"$r\"]().v.slice(1,6) !== \"class\") {\n\t        r1 = this[\"$r\"]();\n\t        r2 = other[\"$r\"]();\n\t    }\n\t    return r1.tp$richcompare(r2, op);\n\t};\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/abstract.js ---- */ \n\n\t/**\n\t * @namespace Sk.abstr\n\t *\n\t */\n\tSk.abstr = {};\n\n\t//\n\t// Number\n\t//\n\n\tSk.abstr.typeName = function (v) {\n\t    var vtypename;\n\t    if (v.tp$name !== undefined) {\n\t        vtypename = v.tp$name;\n\t    } else {\n\t        vtypename = \"<invalid type>\";\n\t    }\n\t    return vtypename;\n\t};\n\n\tSk.abstr.binop_type_error = function (v, w, name) {\n\t    var vtypename = Sk.abstr.typeName(v),\n\t        wtypename = Sk.abstr.typeName(w);\n\n\t    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for \" + name + \": '\" + vtypename + \"' and '\" + wtypename + \"'\");\n\t};\n\n\tSk.abstr.unop_type_error = function (v, name) {\n\t    var vtypename = Sk.abstr.typeName(v),\n\t        uop = {\n\t            \"UAdd\"  : \"+\",\n\t            \"USub\"  : \"-\",\n\t            \"Invert\": \"~\"\n\t        }[name];\n\n\t    throw new Sk.builtin.TypeError(\"bad operand type for unary \" + uop + \": '\" + vtypename + \"'\");\n\t};\n\n\t/**\n\t * lookup and return the LHS object slot function method.  This coudl be either a builtin slot function or a dunder method defined by the user.\n\t * @param obj\n\t * @param name\n\t * @returns {Object|null|undefined}\n\t * @private\n\t */\n\tSk.abstr.boNameToSlotFuncLhs_ = function (obj, name) {\n\t    if (obj === null) {\n\t        return undefined;\n\t    }\n\n\t    switch (name) {\n\t    case \"Add\":\n\t        return obj.nb$add ? obj.nb$add : obj[\"__add__\"];\n\t    case \"Sub\":\n\t        return obj.nb$subtract ? obj.nb$subtract : obj[\"__sub__\"];\n\t    case \"Mult\":\n\t        return obj.nb$multiply ? obj.nb$multiply : obj[\"__mul__\"];\n\t    case \"Div\":\n\t        return obj.nb$divide ? obj.nb$divide : obj[\"__div__\"];\n\t    case \"FloorDiv\":\n\t        return obj.nb$floor_divide ? obj.nb$floor_divide : obj[\"__floordiv__\"];\n\t    case \"Mod\":\n\t        return obj.nb$remainder ? obj.nb$remainder : obj[\"__mod__\"];\n\t    case \"DivMod\":\n\t        return obj.nb$divmod ? obj.nb$divmod : obj[\"__divmod__\"];\n\t    case \"Pow\":\n\t        return obj.nb$power ? obj.nb$power : obj[\"__pow__\"];\n\t    case \"LShift\":\n\t        return obj.nb$lshift ? obj.nb$lshift : obj[\"__lshift__\"];\n\t    case \"RShift\":\n\t        return obj.nb$rshift ? obj.nb$rshift : obj[\"__rshift__\"];\n\t    case \"BitAnd\":\n\t        return obj.nb$and ? obj.nb$and : obj[\"__and__\"];\n\t    case \"BitXor\":\n\t        return obj.nb$xor ? obj.nb$xor : obj[\"__xor__\"];\n\t    case \"BitOr\":\n\t        return obj.nb$or ? obj.nb$or : obj[\"__or__\"];\n\t    }\n\t};\n\n\tSk.abstr.boNameToSlotFuncRhs_ = function (obj, name) {\n\t    if (obj === null) {\n\t        return undefined;\n\t    }\n\n\t    switch (name) {\n\t    case \"Add\":\n\t        return obj.nb$reflected_add ? obj.nb$reflected_add : obj[\"__radd__\"];\n\t    case \"Sub\":\n\t        return obj.nb$reflected_subtract ? obj.nb$reflected_subtract : obj[\"__rsub__\"];\n\t    case \"Mult\":\n\t        return obj.nb$reflected_multiply ? obj.nb$reflected_multiply : obj[\"__rmul__\"];\n\t    case \"Div\":\n\t        return obj.nb$reflected_divide ? obj.nb$reflected_divide : obj[\"__rdiv__\"];\n\t    case \"FloorDiv\":\n\t        return obj.nb$reflected_floor_divide ? obj.nb$reflected_floor_divide : obj[\"__rfloordiv__\"];\n\t    case \"Mod\":\n\t        return obj.nb$reflected_remainder ? obj.nb$reflected_remainder : obj[\"__rmod__\"];\n\t    case \"DivMod\":\n\t        return obj.nb$reflected_divmod ? obj.nb$reflected_divmod : obj[\"__rdivmod__\"];\n\t    case \"Pow\":\n\t        return obj.nb$reflected_power ? obj.nb$reflected_power : obj[\"__rpow__\"];\n\t    case \"LShift\":\n\t        return obj.nb$reflected_lshift ? obj.nb$reflected_lshift : obj[\"__rlshift__\"];\n\t    case \"RShift\":\n\t        return obj.nb$reflected_rshift ? obj.nb$reflected_rshift : obj[\"__rrshift__\"];\n\t    case \"BitAnd\":\n\t        return obj.nb$reflected_and ? obj.nb$reflected_and : obj[\"__rand__\"];\n\t    case \"BitXor\":\n\t        return obj.nb$reflected_xor ? obj.nb$reflected_xor : obj[\"__rxor__\"];\n\t    case \"BitOr\":\n\t        return obj.nb$reflected_or ? obj.nb$reflected_or : obj[\"__ror__\"];\n\t    }\n\t};\n\n\tSk.abstr.iboNameToSlotFunc_ = function (obj, name) {\n\t    switch (name) {\n\t    case \"Add\":\n\t        return obj.nb$inplace_add ? obj.nb$inplace_add : obj[\"__iadd__\"];\n\t    case \"Sub\":\n\t        return obj.nb$inplace_subtract ? obj.nb$inplace_subtract : obj[\"__isub__\"];\n\t    case \"Mult\":\n\t        return obj.nb$inplace_multiply ? obj.nb$inplace_multiply : obj[\"__imul__\"];\n\t    case \"Div\":\n\t        return obj.nb$inplace_divide ? obj.nb$inplace_divide : obj[\"__idiv__\"];\n\t    case \"FloorDiv\":\n\t        return obj.nb$inplace_floor_divide ? obj.nb$inplace_floor_divide : obj[\"__ifloordiv__\"];\n\t    case \"Mod\":\n\t        return obj.nb$inplace_remainder;\n\t    case \"Pow\":\n\t        return obj.nb$inplace_power;\n\t    case \"LShift\":\n\t        return obj.nb$inplace_lshift ? obj.nb$inplace_lshift : obj[\"__ilshift__\"];\n\t    case \"RShift\":\n\t        return obj.nb$inplace_rshift ? obj.nb$inplace_rshift : obj[\"__irshift__\"];\n\t    case \"BitAnd\":\n\t        return obj.nb$inplace_and;\n\t    case \"BitOr\":\n\t        return obj.nb$inplace_or;\n\t    case \"BitXor\":\n\t        return obj.nb$inplace_xor ? obj.nb$inplace_xor : obj[\"__ixor__\"];\n\t    }\n\t};\n\tSk.abstr.uoNameToSlotFunc_ = function (obj, name) {\n\t    if (obj === null) {\n\t        return undefined;\n\t    }\n\t    switch (name) {\n\t    case \"USub\":\n\t        return obj.nb$negative ? obj.nb$negative : obj[\"__neg__\"];\n\t    case \"UAdd\":\n\t        return obj.nb$positive ? obj.nb$positive : obj[\"__pos__\"];\n\t    case \"Invert\":\n\t        return obj.nb$invert ? obj.nb$invert : obj[\"__invert__\"];\n\t    }\n\t};\n\n\tSk.abstr.binary_op_ = function (v, w, opname) {\n\t    var wop;\n\t    var ret;\n\t    var vop;\n\n\t    // All Python inheritance is now enforced with Javascript inheritance\n\t    // (see Sk.abstr.setUpInheritance). This checks if w's type is a strict\n\t    // subclass of v's type\n\t    var w_is_subclass = w.constructor.prototype instanceof v.constructor;\n\n\t    // From the Python 2.7 docs:\n\t    //\n\t    // \"If the right operand’s type is a subclass of the left operand’s type and\n\t    // that subclass provides the reflected method for the operation, this\n\t    // method will be called before the left operand’s non-reflected method.\n\t    // This behavior allows subclasses to override their ancestors’ operations.\"\n\t    //\n\t    // -- https://docs.python.org/2/reference/datamodel.html#index-92\n\n\t    if (w_is_subclass) {\n\t        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\n\t        if (wop !== undefined) {\n\t            if (wop.call) {\n\t                ret = wop.call(w, v);\n\t            } else {\n\t                ret = Sk.misceval.callsim(wop, w, v);\n\t            }\n\t            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t                return ret;\n\t            }\n\t        }\n\t    }\n\n\t    vop = Sk.abstr.boNameToSlotFuncLhs_(v, opname);\n\t    if (vop !== undefined) {\n\t        if (vop.call) {\n\t            ret = vop.call(v, w);\n\t        } else {\n\t            ret = Sk.misceval.callsim(vop, v, w);\n\t        }\n\t        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t            return ret;\n\t        }\n\t    }\n\t    // Don't retry RHS if failed above\n\t    if (!w_is_subclass) {\n\t        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\n\t        if (wop !== undefined) {\n\t            if (wop.call) {\n\t                ret = wop.call(w, v);\n\t            } else {\n\t                ret = Sk.misceval.callsim(wop, w, v);\n\t            }\n\t            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t                return ret;\n\t            }\n\t        }\n\t    }\n\t    Sk.abstr.binop_type_error(v, w, opname);\n\t};\n\n\tSk.abstr.binary_iop_ = function (v, w, opname) {\n\t    var wop;\n\t    var ret;\n\t    var vop = Sk.abstr.iboNameToSlotFunc_(v, opname);\n\t    if (vop !== undefined) {\n\t        if (vop.call) {\n\t            ret = vop.call(v, w);\n\t        } else {  // assume that vop is an __xxx__ type method\n\t            ret = Sk.misceval.callsim(vop, v, w); //  added to be like not-in-place... is this okay?\n\t        }\n\t        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t            return ret;\n\t        }\n\t    }\n\t    wop = Sk.abstr.iboNameToSlotFunc_(w, opname);\n\t    if (wop !== undefined) {\n\t        if (wop.call) {\n\t            ret = wop.call(w, v);\n\t        } else { // assume that wop is an __xxx__ type method\n\t            ret = Sk.misceval.callsim(wop, w, v); //  added to be like not-in-place... is this okay?\n\t        }\n\t        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t            return ret;\n\t        }\n\t    }\n\t    Sk.abstr.binop_type_error(v, w, opname);\n\t};\n\tSk.abstr.unary_op_ = function (v, opname) {\n\t    var ret;\n\t    var vop = Sk.abstr.uoNameToSlotFunc_(v, opname);\n\t    if (vop !== undefined) {\n\t        if (vop.call) {\n\t            ret = vop.call(v);\n\t        } else {  // assume that vop is an __xxx__ type method\n\t            ret = Sk.misceval.callsim(vop, v); //  added to be like not-in-place... is this okay?\n\t        }\n\t        if (ret !== undefined) {\n\t            return ret;\n\t        }\n\t    }\n\t    Sk.abstr.unop_type_error(v, opname);\n\t};\n\n\t//\n\t// handle upconverting a/b from number to long if op causes too big/small a\n\t// result, or if either of the ops are already longs\n\tSk.abstr.numOpAndPromote = function (a, b, opfn) {\n\t    var tmp;\n\t    var ans;\n\t    if (a === null || b === null) {\n\t        return undefined;\n\t    }\n\n\t    if (typeof a === \"number\" && typeof b === \"number\") {\n\t        ans = opfn(a, b);\n\t        // todo; handle float   Removed RNL (bugs in lng, and it should be a question of precision, not magnitude -- this was just wrong)\n\t        if ((ans > Sk.builtin.int_.threshold$ || ans < -Sk.builtin.int_.threshold$) && Math.floor(ans) === ans) {\n\t            return [Sk.builtin.lng.fromInt$(a), Sk.builtin.lng.fromInt$(b)];\n\t        } else {\n\t            return ans;\n\t        }\n\t    } else if (a === undefined || b === undefined) {\n\t        throw new Sk.builtin.NameError(\"Undefined variable in expression\");\n\t    }\n\n\t    if (a.constructor === Sk.builtin.lng) {\n\t        return [a, b];\n\t    } else if ((a.constructor === Sk.builtin.int_ ||\n\t                a.constructor === Sk.builtin.float_) &&\n\t                b.constructor === Sk.builtin.complex) {\n\t        // special case of upconverting nmber and complex\n\t        // can we use here the Sk.builtin.checkComplex() method?\n\t        tmp = new Sk.builtin.complex(a);\n\t        return [tmp, b];\n\t    } else if (a.constructor === Sk.builtin.int_ ||\n\t               a.constructor === Sk.builtin.float_) {\n\t        return [a, b];\n\t    } else if (typeof a === \"number\") {\n\t        tmp = Sk.builtin.assk$(a);\n\t        return [tmp, b];\n\t    } else {\n\t        return undefined;\n\t    }\n\t};\n\n\tSk.abstr.boNumPromote_ = {\n\t    \"Add\"     : function (a, b) {\n\t        return a + b;\n\t    },\n\t    \"Sub\"     : function (a, b) {\n\t        return a - b;\n\t    },\n\t    \"Mult\"    : function (a, b) {\n\t        return a * b;\n\t    },\n\t    \"Mod\"     : function (a, b) {\n\t        var m;\n\t        if (b === 0) {\n\t            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n\t        }\n\t        m = a % b;\n\t        return ((m * b) < 0 ? (m + b) : m);\n\t    },\n\t    \"Div\"     : function (a, b) {\n\t        if (b === 0) {\n\t            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n\t        } else {\n\t            return a / b;\n\t        }\n\t    },\n\t    \"FloorDiv\": function (a, b) {\n\t        if (b === 0) {\n\t            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n\t        } else {\n\t            return Math.floor(a / b);\n\t        } // todo; wrong? neg?\n\t    },\n\t    \"Pow\"     : Math.pow,\n\t    \"BitAnd\"  : function (a, b) {\n\t        var m = a & b;\n\t        if (m < 0) {\n\t            m = m + 4294967296; // convert back to unsigned\n\t        }\n\t        return m;\n\t    },\n\t    \"BitOr\"   : function (a, b) {\n\t        var m = a | b;\n\t        if (m < 0) {\n\t            m = m + 4294967296; // convert back to unsigned\n\t        }\n\t        return m;\n\t    },\n\t    \"BitXor\"  : function (a, b) {\n\t        var m = a ^ b;\n\t        if (m < 0) {\n\t            m = m + 4294967296; // convert back to unsigned\n\t        }\n\t        return m;\n\t    },\n\t    \"LShift\"  : function (a, b) {\n\t        var m;\n\t        if (b < 0) {\n\t            throw new Sk.builtin.ValueError(\"negative shift count\");\n\t        }\n\t        m = a << b;\n\t        if (m > a) {\n\t            return m;\n\t        } else {\n\t            // Fail, this will get recomputed with longs\n\t            return a * Math.pow(2, b);\n\t        }\n\t    },\n\t    \"RShift\"  : function (a, b) {\n\t        var m;\n\t        if (b < 0) {\n\t            throw new Sk.builtin.ValueError(\"negative shift count\");\n\t        }\n\t        m = a >> b;\n\t        if ((a > 0) && (m < 0)) {\n\t            // fix incorrect sign extension\n\t            m = m & (Math.pow(2, 32 - b) - 1);\n\t        }\n\t        return m;\n\t    }\n\t};\n\n\tSk.abstr.numberBinOp = function (v, w, op) {\n\t    var tmp;\n\t    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\n\t    if (numPromoteFunc !== undefined) {\n\t        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\n\t        if (typeof tmp === \"number\") {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\n\t            return tmp;\n\t        } else if (tmp !== undefined) {\n\t            v = tmp[0];\n\t            w = tmp[1];\n\t        }\n\t    }\n\n\t    return Sk.abstr.binary_op_(v, w, op);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.numberBinOp\", Sk.abstr.numberBinOp);\n\n\tSk.abstr.numberInplaceBinOp = function (v, w, op) {\n\t    var tmp;\n\t    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\n\t    if (numPromoteFunc !== undefined) {\n\t        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\n\t        if (typeof tmp === \"number\") {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\n\t            return tmp;\n\t        } else if (tmp !== undefined) {\n\t            v = tmp[0];\n\t            w = tmp[1];\n\t        }\n\t    }\n\n\t    return Sk.abstr.binary_iop_(v, w, op);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.numberInplaceBinOp\", Sk.abstr.numberInplaceBinOp);\n\n\tSk.abstr.numberUnaryOp = function (v, op) {\n\t    var value;\n\t    if (op === \"Not\") {\n\t        return Sk.misceval.isTrue(v) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;\n\t    } else if (v instanceof Sk.builtin.bool) {\n\t        value = Sk.builtin.asnum$(v);\n\t        if (op === \"USub\") {\n\t            return new Sk.builtin.int_(-value);\n\t        }\n\t        if (op === \"UAdd\") {\n\t            return new Sk.builtin.int_(value);\n\t        }\n\t        if (op === \"Invert\") {\n\t            return new Sk.builtin.int_(~value);\n\t        }\n\t    } else {\n\t        if (op === \"USub\" && v.nb$negative) {\n\t            return v.nb$negative();\n\t        }\n\t        if (op === \"UAdd\" && v.nb$positive) {\n\t            return v.nb$positive();\n\t        }\n\t        if (op === \"Invert\" && v.nb$invert) {\n\t            return v.nb$invert();\n\t        }\n\t    }\n\n\t    return Sk.abstr.unary_op_(v, op);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.numberUnaryOp\", Sk.abstr.numberUnaryOp);\n\n\t//\n\t// Sequence\n\t//\n\n\tSk.abstr.fixSeqIndex_ = function (seq, i) {\n\t    i = Sk.builtin.asnum$(i);\n\t    if (i < 0 && seq.sq$length) {\n\t        i += seq.sq$length();\n\t    }\n\t    return i;\n\t};\n\n\t/**\n\t * @param {*} seq\n\t * @param {*} ob\n\t * @param {boolean=} canSuspend\n\t */\n\tSk.abstr.sequenceContains = function (seq, ob, canSuspend) {\n\t    var seqtypename;\n\t    var special;\n\t    var r;\n\n\t    if (seq.sq$contains) {\n\t        return seq.sq$contains(ob);\n\t    }\n\n\t    /**\n\t     *  Look for special method and call it, we have to distinguish between built-ins and\n\t     *  python objects\n\t     */\n\t    special = Sk.abstr.lookupSpecial(seq, \"__contains__\");\n\t    if (special != null) {\n\t        // method on builtin, provide this arg\n\t        return Sk.misceval.isTrue(Sk.misceval.callsim(special, seq, ob));\n\t    }\n\n\t    if (!Sk.builtin.checkIterable(seq)) {\n\t        seqtypename = Sk.abstr.typeName(seq);\n\t        throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n\t    }\n\n\t    r = Sk.misceval.iterFor(Sk.abstr.iter(seq), function(i) {\n\t        if (Sk.misceval.richCompareBool(i, ob, \"Eq\")) {\n\t            return new Sk.misceval.Break(true);\n\t        } else {\n\t            return false;\n\t        }\n\t    }, false);\n\n\t    return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t};\n\n\tSk.abstr.sequenceConcat = function (seq1, seq2) {\n\t    var seq1typename;\n\t    if (seq1.sq$concat) {\n\t        return seq1.sq$concat(seq2);\n\t    }\n\t    seq1typename = Sk.abstr.typeName(seq1);\n\t    throw new Sk.builtin.TypeError(\"'\" + seq1typename + \"' object can't be concatenated\");\n\t};\n\n\tSk.abstr.sequenceGetIndexOf = function (seq, ob) {\n\t    var seqtypename;\n\t    var i, it;\n\t    var index;\n\t    if (seq.index) {\n\t        return Sk.misceval.callsim(seq.index, seq, ob);\n\t    }\n\t    if (Sk.builtin.checkIterable(seq)) {\n\t        index = 0;\n\t        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n\t             i !== undefined; i = it.tp$iternext()) {\n\t            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\n\t                return new Sk.builtin.int_(index);\n\t            }\n\t            index += 1;\n\t        }\n\t        throw new Sk.builtin.ValueError(\"sequence.index(x): x not in sequence\");\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n\t};\n\n\tSk.abstr.sequenceGetCountOf = function (seq, ob) {\n\t    var seqtypename;\n\t    var i, it;\n\t    var count;\n\t    if (seq.count) {\n\t        return Sk.misceval.callsim(seq.count, seq, ob);\n\t    }\n\t    if (Sk.builtin.checkIterable(seq)) {\n\t        count = 0;\n\t        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n\t             i !== undefined; i = it.tp$iternext()) {\n\t            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\n\t                count += 1;\n\t            }\n\t        }\n\t        return new Sk.builtin.int_(count);\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n\t};\n\n\tSk.abstr.sequenceGetItem = function (seq, i, canSuspend) {\n\t    var seqtypename;\n\t    if (seq.mp$subscript) {\n\t        return seq.mp$subscript(i);\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsubscriptable\");\n\t};\n\n\tSk.abstr.sequenceSetItem = function (seq, i, x, canSuspend) {\n\t    var seqtypename;\n\t    if (seq.mp$ass_subscript) {\n\t        return seq.mp$ass_subscript(i, x);\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item assignment\");\n\t};\n\n\tSk.abstr.sequenceDelItem = function (seq, i) {\n\t    var seqtypename;\n\t    if (seq.sq$del_item) {\n\t        i = Sk.abstr.fixSeqIndex_(seq, i);\n\t        seq.sq$del_item(i);\n\t        return;\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item deletion\");\n\t};\n\n\tSk.abstr.sequenceRepeat = function (f, seq, n) {\n\t    var ntypename;\n\t    var count;\n\t    n = Sk.builtin.asnum$(n);\n\t    count = Sk.misceval.asIndex(n);\n\t    if (count === undefined) {\n\t        ntypename = Sk.abstr.typeName(n);\n\t        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + ntypename + \"'\");\n\t    }\n\t    return f.call(seq, n);\n\t};\n\n\tSk.abstr.sequenceGetSlice = function (seq, i1, i2) {\n\t    var seqtypename;\n\t    if (seq.sq$slice) {\n\t        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n\t        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n\t        return seq.sq$slice(i1, i2);\n\t    } else if (seq.mp$subscript) {\n\t        return seq.mp$subscript(new Sk.builtin.slice(i1, i2));\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsliceable\");\n\t};\n\n\tSk.abstr.sequenceDelSlice = function (seq, i1, i2) {\n\t    var seqtypename;\n\t    if (seq.sq$del_slice) {\n\t        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n\t        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n\t        seq.sq$del_slice(i1, i2);\n\t        return;\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' doesn't support slice deletion\");\n\t};\n\n\tSk.abstr.sequenceSetSlice = function (seq, i1, i2, x) {\n\t    var seqtypename;\n\t    if (seq.sq$ass_slice) {\n\t        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n\t        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n\t        seq.sq$ass_slice(i1, i2, x);\n\t    } else if (seq.mp$ass_subscript) {\n\t        seq.mp$ass_subscript(new Sk.builtin.slice(i1, i2), x);\n\t    } else {\n\t        seqtypename = Sk.abstr.typeName(seq);\n\t        throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object doesn't support slice assignment\");\n\t    }\n\t};\n\n\t// seq - Python object to unpack\n\t// n   - JavaScript number of items to unpack\n\tSk.abstr.sequenceUnpack = function (seq, n) {\n\t    var res = [];\n\t    var it, i;\n\n\t    if (!Sk.builtin.checkIterable(seq)) {\n\t        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not iterable\");\n\t    }\n\n\t    for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n\t         (i !== undefined) && (res.length < n);\n\t         i = it.tp$iternext()) {\n\t        res.push(i);\n\t    }\n\n\t    if (res.length < n) {\n\t        throw new Sk.builtin.ValueError(\"need more than \" + res.length + \" values to unpack\");\n\t    }\n\t    if (i !== undefined) {\n\t        throw new Sk.builtin.ValueError(\"too many values to unpack\");\n\t    }\n\n\t    // Return Javascript array of items\n\t    return res;\n\t};\n\n\t//\n\t// Object\n\t//\n\n\tSk.abstr.objectFormat = function (obj, format_spec) {\n\t    var meth; // PyObject\n\t    var result; // PyObject\n\n\t    // If no format_spec is provided, use an empty string\n\t    if(format_spec == null) {\n\t        format_spec = \"\";\n\t    }\n\n\t    // Find the (unbound!) __format__ method (a borrowed reference)\n\t    meth = Sk.abstr.lookupSpecial(obj, \"__format__\");\n\t    if (meth == null) {\n\t        throw new Sk.builtin.TypeError(\"Type \" + Sk.abstr.typeName(obj) + \"doesn't define __format__\");\n\t    }\n\n\t    // And call it\n\t    result = Sk.misceval.callsim(meth, obj, format_spec);\n\t    if (!Sk.builtin.checkString(result)) {\n\t        throw new Sk.builtin.TypeError(\"__format__ must return a str, not \" + Sk.abstr.typeName(result));\n\t    }\n\n\t    return result;\n\t};\n\n\tSk.abstr.objectAdd = function (a, b) {\n\t    var btypename;\n\t    var atypename;\n\t    if (a.nb$add) {\n\t        return a.nb$add(b);\n\t    }\n\n\t    atypename = Sk.abstr.typeName(a);\n\t    btypename = Sk.abstr.typeName(b);\n\t    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for +: '\" + atypename + \"' and '\" + btypename + \"'\");\n\t};\n\n\t// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\n\tSk.abstr.objectNegative = function (obj) {\n\t    var objtypename;\n\t    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\n\n\t    if (obj instanceof Sk.builtin.bool) {\n\t        obj = new Sk.builtin.int_(obj_asnum);\n\t    }\n\n\t    if (obj.nb$negative) {\n\t        return obj.nb$negative();\n\t    }\n\n\t    objtypename = Sk.abstr.typeName(obj);\n\t    throw new Sk.builtin.TypeError(\"bad operand type for unary -: '\" + objtypename + \"'\");\n\t};\n\n\t// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\n\tSk.abstr.objectPositive = function (obj) {\n\t    var objtypename = Sk.abstr.typeName(obj);\n\t    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\n\n\t    if (obj instanceof Sk.builtin.bool) {\n\t        obj = new Sk.builtin.int_(obj_asnum);\n\t    }\n\n\t    if (obj.nb$negative) {\n\t        return obj.nb$positive();\n\t    }\n\n\t    throw new Sk.builtin.TypeError(\"bad operand type for unary +: '\" + objtypename + \"'\");\n\t};\n\n\tSk.abstr.objectDelItem = function (o, key) {\n\t    var otypename;\n\t    var keytypename;\n\t    var keyValue;\n\t    if (o !== null) {\n\t        if (o.mp$del_subscript) {\n\t            o.mp$del_subscript(key);\n\t            return;\n\t        }\n\t        if (o.sq$ass_item) {\n\t            keyValue = Sk.misceval.asIndex(key);\n\t            if (keyValue === undefined) {\n\t                keytypename = Sk.abstr.typeName(key);\n\t                throw new Sk.builtin.TypeError(\"sequence index must be integer, not '\" + keytypename + \"'\");\n\t            }\n\t            Sk.abstr.sequenceDelItem(o, keyValue);\n\t            return;\n\t        }\n\t        // if o is a slice do something else...\n\t    }\n\n\t    otypename = Sk.abstr.typeName(o);\n\t    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' object does not support item deletion\");\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.objectDelItem\", Sk.abstr.objectDelItem);\n\n\tSk.abstr.objectGetItem = function (o, key, canSuspend) {\n\t    var otypename;\n\t    if (o !== null) {\n\t        if (o.tp$getitem) {\n\t            return o.tp$getitem(key, canSuspend);\n\t        } else if (o.mp$subscript) {\n\t            return o.mp$subscript(key, canSuspend);\n\t        } else if (Sk.misceval.isIndex(key) && o.sq$item) {\n\t            return Sk.abstr.sequenceGetItem(o, Sk.misceval.asIndex(key), canSuspend);\n\t        }\n\t    }\n\n\t    otypename = Sk.abstr.typeName(o);\n\t    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support indexing\");\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.objectGetItem\", Sk.abstr.objectGetItem);\n\n\tSk.abstr.objectSetItem = function (o, key, v, canSuspend) {\n\t    var otypename;\n\t    if (o !== null) {\n\t        if (o.tp$setitem) {\n\t            return o.tp$setitem(key, v, canSuspend);\n\t        } else if (o.mp$ass_subscript) {\n\t            return o.mp$ass_subscript(key, v, canSuspend);\n\t        } else if (Sk.misceval.isIndex(key) && o.sq$ass_item) {\n\t            return Sk.abstr.sequenceSetItem(o, Sk.misceval.asIndex(key), v, canSuspend);\n\t        }\n\t    }\n\n\t    otypename = Sk.abstr.typeName(o);\n\t    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support item assignment\");\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.objectSetItem\", Sk.abstr.objectSetItem);\n\n\n\tSk.abstr.gattr = function (obj, nameJS, canSuspend) {\n\t    var ret, f;\n\t    var objname = Sk.abstr.typeName(obj);\n\n\t    if (obj === null) {\n\t        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\n\t    }\n\n\n\t    if (obj.tp$getattr !== undefined) {\n\t        f = obj.tp$getattr(\"__getattribute__\");\n\t    }\n\n\t    if (f !== undefined) {\n\t        ret = Sk.misceval.callsimOrSuspend(f, new Sk.builtin.str(nameJS));\n\t    }\n\n\t    ret = Sk.misceval.chain(ret, function(ret) {\n\t        var f;\n\n\t        if (ret === undefined && obj.tp$getattr !== undefined) {\n\t            ret = obj.tp$getattr(nameJS);\n\n\t            if (ret === undefined) {\n\t                f = obj.tp$getattr(\"__getattr__\");\n\n\t                if (f !== undefined) {\n\t                    ret = Sk.misceval.callsimOrSuspend(f, new Sk.builtin.str(nameJS));\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    }, function(r) {\n\t        if (r === undefined) {\n\t            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\n\t        }\n\t        return r;\n\t    });\n\n\t    return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.gattr\", Sk.abstr.gattr);\n\n\tSk.abstr.sattr = function (obj, nameJS, data, canSuspend) {\n\t    var objname = Sk.abstr.typeName(obj), r, setf;\n\n\t    if (obj === null) {\n\t        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\n\t    }\n\n\t    if (obj.tp$getattr !== undefined) {\n\t        setf = obj.tp$getattr(\"__setattr__\");\n\t        if (setf !== undefined) {\n\t            r = Sk.misceval.callsimOrSuspend(setf, new Sk.builtin.str(nameJS), data);\n\t            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t        }\n\t    }\n\n\t    if (obj.tp$setattr !== undefined) {\n\t        obj.tp$setattr(nameJS, data);\n\t    } else {\n\t        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\n\t    }\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.sattr\", Sk.abstr.sattr);\n\n\n\tSk.abstr.iternext = function (it, canSuspend) {\n\t    return it.tp$iternext(canSuspend);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.iternext\", Sk.abstr.iternext);\n\n\n\t/**\n\t * Get the iterator for a Python object  This iterator could be one of the following.\n\t * This is the preferred mechanism for consistently getting the correct iterator.  You should\n\t * not just use tp$iter because that could lead to incorrect behavior of a user created class.\n\t *\n\t * - tp$iter\n\t * - A user defined `__iter__` method\n\t * - A user defined `__getitem__` method\n\t *\n\t * @param obj\n\t *\n\t * @throws {Sk.builtin.TypeError}\n\t * @returns {Object}\n\t */\n\n\tSk.abstr.iter = function(obj) {\n\t    var iter;\n\t    var getit;\n\t    var ret;\n\n\t    /**\n\t     * Builds an iterator around classes that have a __getitem__ method.\n\t     *\n\t     * @constructor\n\t     */\n\t    var seqIter = function (obj) {\n\t        this.idx = 0;\n\t        this.myobj = obj;\n\t        this.getitem = Sk.abstr.lookupSpecial(obj, \"__getitem__\");\n\t        this.tp$iternext = function () {\n\t            var ret;\n\t            try {\n\t                ret = Sk.misceval.callsim(this.getitem, this.myobj, Sk.ffi.remapToPy(this.idx));\n\t            } catch (e) {\n\t                if (e instanceof Sk.builtin.IndexError || e instanceof Sk.builtin.StopIteration) {\n\t                    return undefined;\n\t                } else {\n\t                    throw e;\n\t                }\n\t            }\n\t            this.idx++;\n\t            return ret;\n\t        };\n\t    };\n\n\t    if (obj.tp$getattr) {\n\t        iter =  Sk.abstr.lookupSpecial(obj,\"__iter__\");\n\t        if (iter) {\n\t            ret = Sk.misceval.callsim(iter, obj);\n\t            if (ret.tp$iternext) {\n\t                return ret;\n\t            }\n\t        }\n\t    }\n\t    if (obj.tp$iter) {\n\t        try {  // catch and ignore not iterable error here.\n\t            ret = obj.tp$iter();\n\t            if (ret.tp$iternext) {\n\t                return ret;\n\t            }\n\t        } catch (e) { }\n\t    }\n\t    getit = Sk.abstr.lookupSpecial(obj, \"__getitem__\");\n\t    if (getit) {\n\t        // create internal iterobject if __getitem__\n\t        return new seqIter(obj);\n\t    }\n\t    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(obj) + \"' object is not iterable\");\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.iter\", Sk.abstr.iter);\n\n\t/**\n\t * Special method look up. First try getting the method via\n\t * internal dict and getattr. If getattr is not present (builtins)\n\t * try if method is defined on the object itself\n\t *\n\t * @returns {null|Object} Return null if not found or the function\n\t */\n\tSk.abstr.lookupSpecial = function(op, str) {\n\t    var res;\n\t    var obtp;\n\t    if (op.ob$type) {\n\t        obtp = op.ob$type;\n\t    } else {\n\t        return null;\n\t    }\n\n\t    return Sk.builtin.type.typeLookup(obtp, str);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.lookupSpecial\", Sk.abstr.lookupSpecial);\n\n\t/**\n\t * Mark a class as unhashable and prevent its `__hash__` function from being called.\n\t * @param  {function(...[?])} thisClass The class to mark as unhashable.\n\t * @return {undefined}\n\t */\n\tSk.abstr.markUnhashable = function (thisClass) {\n\t    var proto = thisClass.prototype;\n\t    proto.__hash__ = Sk.builtin.none.none$;\n\t    proto.tp$hash = Sk.builtin.none.none$;\n\t};\n\n\t/**\n\t * Set up inheritance between two Python classes. This allows only for single\n\t * inheritance -- multiple inheritance is not supported by Javascript.\n\t *\n\t * Javascript's inheritance is prototypal. This means that properties must\n\t * be defined on the superclass' prototype in order for subclasses to inherit\n\t * them.\n\t *\n\t * ```\n\t * Sk.superclass.myProperty                 # will NOT be inherited\n\t * Sk.superclass.prototype.myProperty       # will be inherited\n\t * ```\n\t *\n\t * In order for a class to be subclassable, it must (directly or indirectly)\n\t * inherit from Sk.builtin.object so that it will be properly initialized in\n\t * {@link Sk.doOneTimeInitialization} (in src/import.js). Further, all Python\n\t * builtins should inherit from Sk.builtin.object.\n\t *\n\t * @param {string} childName The Python name of the child (subclass).\n\t * @param {function(...[?])} child     The subclass.\n\t * @param {function(...[?])} parent    The superclass.\n\t * @return {undefined}\n\t */\n\tSk.abstr.setUpInheritance = function (childName, child, parent) {\n\t    goog.inherits(child, parent);\n\t    child.prototype.tp$base = parent;\n\t    child.prototype.tp$name = childName;\n\t    child.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(childName, child);\n\t};\n\n\t/**\n\t * Call the super constructor of the provided class, with the object `self` as\n\t * the `this` value of that constructor. Any arguments passed to this function\n\t * after `self` will be passed as-is to the constructor.\n\t *\n\t * @param  {function(...[?])} thisClass The subclass.\n\t * @param  {Object} self      The instance of the subclas.\n\t * @param  {...?} args Arguments to pass to the constructor.\n\t * @return {undefined}\n\t */\n\tSk.abstr.superConstructor = function (thisClass, self, args) {\n\t    var argumentsForConstructor = Array.prototype.slice.call(arguments, 2);\n\t    thisClass.prototype.tp$base.apply(self, argumentsForConstructor);\n\t};\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/object.js ---- */ \n\n\t/**\n\t * @constructor\n\t * Sk.builtin.object\n\t *\n\t * @description\n\t * Constructor for Python object. All Python classes (builtin and user-defined)\n\t * should inherit from this class.\n\t *\n\t * @return {Sk.builtin.object} Python object\n\t */\n\tSk.builtin.object = function () {\n\t    if (!(this instanceof Sk.builtin.object)) {\n\t        return new Sk.builtin.object();\n\t    }\n\n\t    return this;\n\t};\n\n\n\n\tvar _tryGetSubscript = function(dict, pyName) {\n\t    try {\n\t        return dict.mp$subscript(pyName);\n\t    } catch (x) {\n\t        return undefined;\n\t    }\n\t};\n\n\t/**\n\t * @return {undefined}\n\t */\n\tSk.builtin.object.prototype.GenericGetAttr = function (name) {\n\t    var res;\n\t    var f;\n\t    var descr;\n\t    var tp;\n\t    var dict;\n\t    var pyName = new Sk.builtin.str(name);\n\t    goog.asserts.assert(typeof name === \"string\");\n\n\t    tp = this.ob$type;\n\t    goog.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n\t    dict = this[\"$d\"] || this.constructor[\"$d\"];\n\n\t    // todo; assert? force?\n\t    if (dict) {\n\t        if (dict.mp$lookup) {\n\t            res = dict.mp$lookup(pyName);\n\t        } else if (dict.mp$subscript) {\n\t            res = _tryGetSubscript(dict, pyName);\n\t        } else if (typeof dict === \"object\") {\n\t            // todo; definitely the wrong place for this. other custom tp$getattr won't work on object -- bnm -- implemented custom __getattr__ in abstract.js\n\t            res = dict[name];\n\t        }\n\t        if (res !== undefined) {\n\t            return res;\n\t        }\n\t    }\n\n\t    descr = Sk.builtin.type.typeLookup(tp, name);\n\n\t    // otherwise, look in the type for a descr\n\t    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\n\t        f = descr.ob$type.tp$descr_get;\n\t        if (!(f) && descr[\"__get__\"]) {\n\t            f = descr[\"__get__\"];\n\t            return Sk.misceval.callsimOrSuspend(f, descr, this, Sk.builtin.none.none$);\n\t        }\n\t        // todo;\n\t        // if (f && descr.tp$descr_set) // is a data descriptor if it has a set\n\t        // return f.call(descr, this, this.ob$type);\n\n\t        if (f) {\n\t            // non-data descriptor\n\t            return f.call(descr, this, this.ob$type);\n\t        }\n\t    }\n\n\t    if (descr !== undefined) {\n\t        return descr;\n\t    }\n\n\t    return undefined;\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericGetAttr\", Sk.builtin.object.prototype.GenericGetAttr);\n\n\tSk.builtin.object.prototype.GenericPythonGetAttr = function(self, name) {\n\t    return Sk.builtin.object.prototype.GenericGetAttr.call(self, name.v);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonGetAttr\", Sk.builtin.object.prototype.GenericPythonGetAttr);\n\n\tSk.builtin.object.prototype.GenericSetAttr = function (name, value) {\n\t    var objname = Sk.abstr.typeName(this);\n\t    var pyname;\n\t    var dict;\n\t    var tp = this.ob$type;\n\t    var descr;\n\t    var f;\n\n\t    goog.asserts.assert(typeof name === \"string\");\n\t    goog.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n\t    dict = this[\"$d\"] || this.constructor[\"$d\"];\n\n\t    descr = Sk.builtin.type.typeLookup(tp, name);\n\n\t    // otherwise, look in the type for a descr\n\t    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\n\t        //f = descr.ob$type.tp$descr_set;\n\t        if (descr[\"__set__\"]) {\n\t            f = descr[\"__set__\"];\n\t            Sk.misceval.callsimOrSuspend(f, descr, this, value);\n\t            return;\n\t        }\n\t        // todo;\n\t        //if (f && descr.tp$descr_set) // is a data descriptor if it has a set\n\t        //return f.call(descr, this, this.ob$type);\n\t    }\n\n\t    if (dict.mp$ass_subscript) {\n\t        pyname = new Sk.builtin.str(name);\n\n\t        if (this instanceof Sk.builtin.object && !(this.ob$type.sk$klass) &&\n\t            dict.mp$lookup(pyname) === undefined) {\n\t            // Cannot add new attributes to a builtin object\n\t            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + name + \"'\");\n\t        }\n\t        dict.mp$ass_subscript(new Sk.builtin.str(name), value);\n\t    } else if (typeof dict === \"object\") {\n\t        dict[name] = value;\n\t    }\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericSetAttr\", Sk.builtin.object.prototype.GenericSetAttr);\n\n\tSk.builtin.object.prototype.GenericPythonSetAttr = function(self, name, value) {\n\t    return Sk.builtin.object.prototype.GenericSetAttr.call(self, name.v, value);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonSetAttr\", Sk.builtin.object.prototype.GenericPythonSetAttr);\n\n\tSk.builtin.object.prototype.HashNotImplemented = function () {\n\t    throw new Sk.builtin.TypeError(\"unhashable type: '\" + Sk.abstr.typeName(this) + \"'\");\n\t};\n\n\tSk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\tSk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n\n\t// Although actual attribute-getting happens in pure Javascript via tp$getattr, classes\n\t// overriding __getattr__ etc need to be able to call object.__getattr__ etc from Python\n\tSk.builtin.object.prototype[\"__getattr__\"] = Sk.builtin.object.prototype.GenericPythonGetAttr;\n\tSk.builtin.object.prototype[\"__setattr__\"] = Sk.builtin.object.prototype.GenericPythonSetAttr;\n\n\t/**\n\t * The name of this class.\n\t * @type {string}\n\t */\n\tSk.builtin.object.prototype.tp$name = \"object\";\n\n\t/**\n\t * The type object of this class.\n\t * @type {Sk.builtin.type}\n\t */\n\tSk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(\"object\", Sk.builtin.object);\n\tSk.builtin.object.prototype.ob$type.sk$klass = undefined;   // Nonsense for closure compiler\n\n\t/** Default implementations of dunder methods found in all Python objects */\n\n\t/**\n\t * Python wrapper for `__repr__` method.\n\t * @name  __repr__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__repr__\"] = function (self) {\n\t    Sk.builtin.pyCheckArgs(\"__repr__\", arguments, 0, 0, false, true);\n\n\t    return self[\"$r\"]();\n\t};\n\n\t/**\n\t * Python wrapper for `__str__` method.\n\t * @name  __str__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__str__\"] = function (self) {\n\t    Sk.builtin.pyCheckArgs(\"__str__\", arguments, 0, 0, false, true);\n\n\t    return self[\"$r\"]();\n\t};\n\n\t/**\n\t * Python wrapper for `__hash__` method.\n\t * @name  __hash__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__hash__\"] = function (self) {\n\t    Sk.builtin.pyCheckArgs(\"__hash__\", arguments, 0, 0, false, true);\n\n\t    return self.tp$hash();\n\t};\n\n\t/**\n\t * Python wrapper for `__eq__` method.\n\t * @name  __eq__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__eq__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__eq__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$eq(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__ne__` method.\n\t * @name  __ne__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__ne__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__ne__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$ne(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__lt__` method.\n\t * @name  __lt__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__lt__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__lt__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$lt(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__le__` method.\n\t * @name  __le__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__le__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__le__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$le(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__gt__` method.\n\t * @name  __gt__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__gt__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__gt__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$gt(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__ge__` method.\n\t * @name  __ge__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__ge__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__ge__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$ge(other);\n\t};\n\n\t/** Default implementations of Javascript functions used in dunder methods */\n\n\t/**\n\t * Return the string representation of this instance.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @name  $r\n\t * @memberOf Sk.builtin.object.prototype\n\t * @return {Sk.builtin.str} The Python string representation of this instance.\n\t */\n\tSk.builtin.object.prototype[\"$r\"] = function () {\n\t    return new Sk.builtin.str(\"<object>\");\n\t};\n\n\tSk.builtin.hashCount = 1;\n\tSk.builtin.idCount = 1;\n\n\t/**\n\t * Return the hash value of this instance.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @return {Sk.builtin.int_} The hash value\n\t */\n\tSk.builtin.object.prototype.tp$hash = function () {\n\t    if (!this.$savedHash_) {\n\t        this.$savedHash_ = new Sk.builtin.int_(Sk.builtin.hashCount++);\n\t    }\n\n\t    return this.$savedHash_;\n\t};\n\n\t/**\n\t * Perform equality check between this instance and a Python object (i.e. this == other).\n\t *\n\t * Implements `__eq__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to check for equality.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if equal, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$eq = function (other) {\n\t    if (this === other) {\n\t        return Sk.builtin.bool.true$;\n\t    }\n\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Perform non-equality check between this instance and a Python object (i.e. this != other).\n\t *\n\t * Implements `__ne__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to check for non-equality.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if not equal, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$ne = function (other) {\n\t    if (this === other) {\n\t        return Sk.builtin.bool.false$;\n\t    }\n\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Determine if this instance is less than a Python object (i.e. this < other).\n\t *\n\t * Implements `__lt__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to compare.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this < other, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$lt = function (other) {\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Determine if this instance is less than or equal to a Python object (i.e. this <= other).\n\t *\n\t * Implements `__le__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to compare.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this <= other, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$le = function (other) {\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Determine if this instance is greater than a Python object (i.e. this > other).\n\t *\n\t * Implements `__gt__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to compare.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this > other, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$gt = function (other) {\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Determine if this instance is greater than or equal to a Python object (i.e. this >= other).\n\t *\n\t * Implements `__ge__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to compare.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this >= other, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$ge = function (other) {\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t// Wrap the following functions in Sk.builtin.func once that class is initialized\n\t/**\n\t * Array of all the Python functions which are methods of this class.\n\t * @type {Array}\n\t */\n\tSk.builtin.object.pythonFunctions = [\"__repr__\", \"__str__\", \"__hash__\",\n\t\"__eq__\", \"__ne__\", \"__lt__\", \"__le__\", \"__gt__\", \"__ge__\", \"__getattr__\", \"__setattr__\"];\n\n\t/**\n\t * @constructor\n\t * Sk.builtin.none\n\t *\n\t * @extends {Sk.builtin.object}\n\t */\n\tSk.builtin.none = function () {\n\t    this.v = null;\n\t};\n\tSk.abstr.setUpInheritance(\"NoneType\", Sk.builtin.none, Sk.builtin.object);\n\n\t/** @override */\n\tSk.builtin.none.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"None\"); };\n\n\t/** @override */\n\tSk.builtin.none.prototype.tp$hash = function () {\n\t    return new Sk.builtin.int_(0);\n\t};\n\n\t/**\n\t * Python None constant.\n\t * @type {Sk.builtin.none}\n\t */\n\tSk.builtin.none.none$ = new Sk.builtin.none();\n\n\t/**\n\t * @constructor\n\t * Sk.builtin.NotImplemented\n\t *\n\t * @extends {Sk.builtin.object}\n\t */\n\tSk.builtin.NotImplemented = function() { };\n\tSk.abstr.setUpInheritance(\"NotImplementedType\", Sk.builtin.NotImplemented, Sk.builtin.object);\n\n\t/** @override */\n\tSk.builtin.NotImplemented.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"NotImplemented\"); };\n\n\t/**\n\t * Python NotImplemented constant.\n\t * @type {Sk.builtin.NotImplemented}\n\t */\n\tSk.builtin.NotImplemented.NotImplemented$ = new Sk.builtin.NotImplemented();\n\n\tgoog.exportSymbol(\"Sk.builtin.none\", Sk.builtin.none);\n\tgoog.exportSymbol(\"Sk.builtin.NotImplemented\", Sk.builtin.NotImplemented);\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/function.js ---- */ \n\n\t/**\n\t * @namespace Sk.builtin\n\t */\n\n\n\t/**\n\t * Check arguments to Python functions to ensure the correct number of\n\t * arguments are passed.\n\t *\n\t * @param {string} name the name of the function\n\t * @param {Object} args the args passed to the function\n\t * @param {number} minargs the minimum number of allowable arguments\n\t * @param {number=} maxargs optional maximum number of allowable\n\t * arguments (default: Infinity)\n\t * @param {boolean=} kwargs optional true if kwargs, false otherwise\n\t * (default: false)\n\t * @param {boolean=} free optional true if free vars, false otherwise\n\t * (default: false)\n\t */\n\tSk.builtin.pyCheckArgs = function (name, args, minargs, maxargs, kwargs, free) {\n\t    var nargs = args.length;\n\t    var msg = \"\";\n\n\t    if (maxargs === undefined) {\n\t        maxargs = Infinity;\n\t    }\n\t    if (kwargs) {\n\t        nargs -= 1;\n\t    }\n\t    if (free) {\n\t        nargs -= 1;\n\t    }\n\t    if ((nargs < minargs) || (nargs > maxargs)) {\n\t        if (minargs === maxargs) {\n\t            msg = name + \"() takes exactly \" + minargs + \" arguments\";\n\t        } else if (nargs < minargs) {\n\t            msg = name + \"() takes at least \" + minargs + \" arguments\";\n\t        } else {\n\t            msg = name + \"() takes at most \" + maxargs + \" arguments\";\n\t        }\n\t        msg += \" (\" + nargs + \" given)\";\n\t        throw new Sk.builtin.TypeError(msg);\n\t    }\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.pyCheckArgs\", Sk.builtin.pyCheckArgs);\n\n\t/**\n\t * Check type of argument to Python functions.\n\t *\n\t * @param {string} name the name of the argument\n\t * @param {string} exptype string of the expected type name\n\t * @param {boolean} check truthy if type check passes, falsy otherwise\n\t */\n\tSk.builtin.pyCheckType = function (name, exptype, check) {\n\t    if (!check) {\n\t        throw new Sk.builtin.TypeError(name + \" must be a \" + exptype);\n\t    }\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.pyCheckType\", Sk.builtin.pyCheckType);\n\n\tSk.builtin.checkSequence = function (arg) {\n\t    return (arg !== null && arg.mp$subscript !== undefined);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkSequence\", Sk.builtin.checkSequence);\n\n\t/**\n\t * Use this to test whether or not a Python object is iterable.  You should **not** rely\n\t * on the presence of tp$iter on the object as a good test, as it could be a user defined\n\t * class with `__iter__` defined or ``__getitem__``  This tests for all of those cases\n\t *\n\t * @param arg {Object}   A Python object\n\t * @returns {boolean} true if the object is iterable\n\t */\n\tSk.builtin.checkIterable = function (arg) {\n\t    var ret = false;\n\t    if (arg !== null ) {\n\t        try {\n\t            ret = Sk.abstr.iter(arg);\n\t            if (ret) {\n\t                return true;\n\t            } else {\n\t                return false;\n\t            }\n\t        } catch (e) {\n\t            if (e instanceof Sk.builtin.TypeError) {\n\t                return false;\n\t            } else {\n\t                throw e;\n\t            }\n\t        }\n\t    }\n\t    return ret;\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkIterable\", Sk.builtin.checkIterable);\n\n\tSk.builtin.checkCallable = function (obj) {\n\t    // takes care of builtin functions and methods, builtins\n\t    if (typeof obj === \"function\") {\n\t        return true;\n\t    }\n\t    // takes care of python function, methods and lambdas\n\t    if (obj instanceof Sk.builtin.func) {\n\t        return true;\n\t    }\n\t    // takes care of instances of methods\n\t    if (obj instanceof Sk.builtin.method) {\n\t        return true;\n\t    }\n\t    // go up the prototype chain to see if the class has a __call__ method\n\t    if (Sk.abstr.lookupSpecial(obj, \"__call__\") !== undefined) {\n\t        return true;\n\t    } \n\t    return false;\n\t};\n\n\tSk.builtin.checkNumber = function (arg) {\n\t    return (arg !== null && (typeof arg === \"number\" ||\n\t        arg instanceof Sk.builtin.int_ ||\n\t        arg instanceof Sk.builtin.float_ ||\n\t        arg instanceof Sk.builtin.lng));\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkNumber\", Sk.builtin.checkNumber);\n\n\t/**\n\t * Checks for complex type, delegates to internal method\n\t * Most skulpt users would search here!\n\t */\n\tSk.builtin.checkComplex = function (arg) {\n\t    return Sk.builtin.complex._complex_check(arg);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkComplex\", Sk.builtin.checkComplex);\n\n\tSk.builtin.checkInt = function (arg) {\n\t    return (arg !== null) && ((typeof arg === \"number\" && arg === (arg | 0)) ||\n\t        arg instanceof Sk.builtin.int_ ||\n\t        arg instanceof Sk.builtin.lng);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkInt\", Sk.builtin.checkInt);\n\n\tSk.builtin.checkFloat = function (arg) {\n\t    return (arg !== null) && (arg instanceof Sk.builtin.float_);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkFloat\", Sk.builtin.checkFloat);\n\n\tSk.builtin.checkString = function (arg) {\n\t    return (arg !== null && arg.__class__ == Sk.builtin.str);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkString\", Sk.builtin.checkString);\n\n\tSk.builtin.checkClass = function (arg) {\n\t    return (arg !== null && arg.sk$type);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkClass\", Sk.builtin.checkClass);\n\n\tSk.builtin.checkBool = function (arg) {\n\t    return (arg instanceof Sk.builtin.bool);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkBool\", Sk.builtin.checkBool);\n\n\tSk.builtin.checkNone = function (arg) {\n\t    return (arg instanceof Sk.builtin.none);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkNone\", Sk.builtin.checkNone);\n\n\tSk.builtin.checkFunction = function (arg) {\n\t    return (arg !== null && arg.tp$call !== undefined);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkFunction\", Sk.builtin.checkFunction);\n\n\t/**\n\t * @constructor\n\t * Sk.builtin.func\n\t *\n\t * @description\n\t * This function converts a Javascript function into a Python object that is callable.  Or just\n\t * think of it as a Python function rather than a Javascript function now.  This is an important\n\t * distinction in skulpt because once you have Python function you cannot just call it.\n\t * You must now use Sk.misceval.callsim to call the Python function.\n\t *\n\t * @param {Function} code the javascript implementation of this function\n\t * @param {Object=} globals the globals where this function was defined.\n\t * Can be undefined (which will be stored as null) for builtins. (is\n\t * that ok?)\n\t * @param {Object=} closure dict of free variables\n\t * @param {Object=} closure2 another dict of free variables that will be\n\t * merged into 'closure'. there's 2 to simplify generated code (one is $free,\n\t * the other is $cell)\n\t *\n\t * closure is the cell variables from the parent scope that we need to close\n\t * over. closure2 is the free variables in the parent scope that we also might\n\t * need to access.\n\t *\n\t * NOTE: co_varnames and co_name are defined by compiled code only, so we have\n\t * to access them via dict-style lookup for closure.\n\t *\n\t */\n\tSk.builtin.func = function (code, globals, closure, closure2) {\n\t    var k;\n\t    this.func_code = code;\n\t    this.func_globals = globals || null;\n\t    if (closure2 !== undefined) {\n\t        // todo; confirm that modification here can't cause problems\n\t        for (k in closure2) {\n\t            closure[k] = closure2[k];\n\t        }\n\t    }\n\t    this.func_closure = closure;\n\t    return this;\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.func\", Sk.builtin.func);\n\n\n\tSk.builtin.func.prototype.tp$name = \"function\";\n\tSk.builtin.func.prototype.tp$descr_get = function (obj, objtype) {\n\t    goog.asserts.assert(obj !== undefined && objtype !== undefined);\n\t    if (obj == null) {\n\t        return this;\n\t    }\n\t    return new Sk.builtin.method(this, obj, objtype);\n\t};\n\tSk.builtin.func.prototype.tp$call = function (args, kw) {\n\t    var j;\n\t    var i;\n\t    var numvarnames;\n\t    var varnames;\n\t    var kwlen;\n\t    var kwargsarr;\n\t    var expectskw;\n\t    var name;\n\t    var numargs;\n\n\t    // note: functions expect 'this' to be globals to avoid having to\n\t    // slice/unshift onto the main args\n\t    if (this.func_closure) {\n\t        // todo; OK to modify?\n\t        if (this.func_code[\"$defaults\"] && this.func_code[\"co_varnames\"]) {\n\t            // Make sure all default arguments are in args before adding closure\n\t            numargs = args.length;\n\t            numvarnames = this.func_code[\"co_varnames\"].length;\n\t            for (i = numargs; i < numvarnames; i++) {\n\t                args.push(undefined);\n\t            }\n\t        }\n\t        args.push(this.func_closure);\n\t    }\n\n\t    expectskw = this.func_code[\"co_kwargs\"];\n\t    kwargsarr = [];\n\n\t    if (this.func_code[\"no_kw\"] && kw) {\n\t        name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\n\t        throw new Sk.builtin.TypeError(name + \"() takes no keyword arguments\");\n\t    }\n\n\t    if (kw) {\n\t        // bind the kw args\n\t        kwlen = kw.length;\n\t        varnames = this.func_code[\"co_varnames\"];\n\t        numvarnames = varnames && varnames.length;\n\t        for (i = 0; i < kwlen; i += 2) {\n\t            // todo; make this a dict mapping name to offset\n\t            for (j = 0; j < numvarnames; ++j) {\n\t                if (kw[i] === varnames[j]) {\n\t                    break;\n\t                }\n\t            }\n\t            if (varnames && j !== numvarnames) {\n\t                if (j in args) {\n\t                    name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\n\t                    throw new Sk.builtin.TypeError(name + \"() got multiple values for keyword argument '\" + kw[i] + \"'\");\n\t                }\n\t                args[j] = kw[i + 1];\n\t            } else if (expectskw) {\n\t                // build kwargs dict\n\t                kwargsarr.push(new Sk.builtin.str(kw[i]));\n\t                kwargsarr.push(kw[i + 1]);\n\t            } else {\n\t                name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\n\t                throw new Sk.builtin.TypeError(name + \"() got an unexpected keyword argument '\" + kw[i] + \"'\");\n\t            }\n\t        }\n\t    }\n\t    if (expectskw) {\n\t        args.unshift(kwargsarr);\n\t    }\n\n\t    //print(JSON.stringify(args, null, 2));\n\n\t    return this.func_code.apply(this.func_globals, args);\n\t};\n\n\tSk.builtin.func.prototype.tp$getattr = function (key) {\n\t    return this[key];\n\t};\n\tSk.builtin.func.prototype.tp$setattr = function (key, value) {\n\t    this[key] = value;\n\t};\n\n\t//todo; investigate why the other doesn't work\n\t//Sk.builtin.type.makeIntoTypeObj('function', Sk.builtin.func);\n\tSk.builtin.func.prototype.ob$type = Sk.builtin.type.makeTypeObj(\"function\", new Sk.builtin.func(null, null));\n\n\tSk.builtin.func.prototype[\"$r\"] = function () {\n\t    var name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\n\t    return new Sk.builtin.str(\"<function \" + name + \">\");\n\t};\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/seqtype.js ---- */ \n\n\t/**\n\t * @constructor\n\t * Sk.builtin.seqtype\n\t *\n\t * @description\n\t * Abstract class for Python sequence types.\n\t *\n\t * @extends {Sk.builtin.object}\n\t *\n\t * @return {undefined} Cannot instantiate a Sk.builtin.seqtype object\n\t */\n\tSk.builtin.seqtype = function () {\n\n\t    throw new Sk.builtin.ExternalError(\"Cannot instantiate abstract Sk.builtin.seqtype class\");\n\n\t};\n\n\tSk.abstr.setUpInheritance(\"SequenceType\", Sk.builtin.seqtype, Sk.builtin.object);\n\n\tSk.builtin.seqtype.sk$abstract = true;\n\n\t/**\n\t * Python wrapper of `__len__` method.\n\t *\n\t * @name  __len__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__len__\"] = new Sk.builtin.func(function (self) {\n\n\t    Sk.builtin.pyCheckArgs(\"__len__\", arguments, 0, 0, false, true);\n\n\t    return new Sk.builtin.int_(self.sq$length());    \n\n\t});\n\n\t/**\n\t * Python wrapper of `__iter__` method.\n\t *\n\t * @name  __iter__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__iter__\"] = new Sk.builtin.func(function (self) {\n\n\t    Sk.builtin.pyCheckArgs(\"__iter__\", arguments, 0, 0, false, true);\n\n\t    return self.tp$iter();\n\n\t});\n\n\t/**\n\t * Python wrapper of `__contains__` method.\n\t *\n\t * @name  __contains__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__contains__\"] = new Sk.builtin.func(function (self, item) {\n\n\t    Sk.builtin.pyCheckArgs(\"__contains__\", arguments, 1, 1, false, true);\n\n\t    if (self.sq$contains(item)) {\n\t        return Sk.builtin.bool.true$;\n\t    } else {\n\t        return Sk.builtin.bool.false$;\n\t    }\n\n\t});\n\n\t/**\n\t * Python wrapper of `__getitem__` method.\n\t *\n\t * @name  __getitem__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__getitem__\"] = new Sk.builtin.func(function (self, key) {\n\n\t    Sk.builtin.pyCheckArgs(\"__getitem__\", arguments, 1, 1, false, true);\n\n\t    return self.mp$subscript(key);\n\n\t});\n\n\t/**\n\t * Python wrapper of `__add__` method.\n\t *\n\t * @name  __add__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__add__\"] = new Sk.builtin.func(function (self, other) {\n\n\t    Sk.builtin.pyCheckArgs(\"__add__\", arguments, 1, 1, false, true);\n\n\t    return self.sq$concat(other);\n\n\t});\n\n\t/**\n\t * Python wrapper of `__mul__` method.\n\t *\n\t * @name  __mul__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__mul__\"] = new Sk.builtin.func(function (self, n) {\n\n\t    Sk.builtin.pyCheckArgs(\"__mul__\", arguments, 1, 1, false, true);\n\n\t    if (!Sk.misceval.isIndex(n)) {\n\t        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n\t    }\n\n\t    return self.sq$repeat(n);\n\n\t});\n\n\t/**\n\t * Python wrapper of `__rmul__` method.\n\t *\n\t * @name  __rmul__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__rmul__\"] = new Sk.builtin.func(function (self, n) {\n\n\t    Sk.builtin.pyCheckArgs(\"__rmul__\", arguments, 1, 1, false, true);\n\n\t    return self.sq$repeat(n);    \n\n\t});\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/str.js ---- */ \n\n\tSk.builtin.interned = {};\n\n\t/**\n\t * @constructor\n\t * @param {*} x\n\t * @extends Sk.builtin.object\n\t */\n\tSk.builtin.str = function (x) {\n\t    var ret;\n\t    if (x === undefined) {\n\t        x = \"\";\n\t    }\n\t    if (x instanceof Sk.builtin.str) {\n\t        return x;\n\t    }\n\t    if (!(this instanceof Sk.builtin.str)) {\n\t        return new Sk.builtin.str(x);\n\t    }\n\n\n\t    // convert to js string\n\t    if (x === true) {\n\t        ret = \"True\";\n\t    } else if (x === false) {\n\t        ret = \"False\";\n\t    } else if ((x === null) || (x instanceof Sk.builtin.none)) {\n\t        ret = \"None\";\n\t    } else if (x instanceof Sk.builtin.bool) {\n\t        if (x.v) {\n\t            ret = \"True\";\n\t        } else {\n\t            ret = \"False\";\n\t        }\n\t    } else if (typeof x === \"number\") {\n\t        ret = x.toString();\n\t        if (ret === \"Infinity\") {\n\t            ret = \"inf\";\n\t        } else if (ret === \"-Infinity\") {\n\t            ret = \"-inf\";\n\t        }\n\t    } else if (typeof x === \"string\") {\n\t        ret = x;\n\t    } else if (x.tp$str !== undefined) {\n\t        ret = x.tp$str();\n\t        if (!(ret instanceof Sk.builtin.str)) {\n\t            throw new Sk.builtin.ValueError(\"__str__ didn't return a str\");\n\t        }\n\t        return ret;\n\t    } else {\n\t        return Sk.misceval.objectRepr(x);\n\t    }\n\n\t    // interning required for strings in py\n\t    if (Sk.builtin.interned[\"1\" + ret]) {\n\t        return Sk.builtin.interned[\"1\" + ret];\n\t    }\n\n\t    this.__class__ = Sk.builtin.str;\n\t    this.v = ret;\n\t    this[\"v\"] = this.v;\n\t    Sk.builtin.interned[\"1\" + ret] = this;\n\t    return this;\n\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.str\", Sk.builtin.str);\n\n\tSk.abstr.setUpInheritance(\"str\", Sk.builtin.str, Sk.builtin.seqtype);\n\n\tSk.builtin.str.prototype.mp$subscript = function (index) {\n\t    var ret;\n\t    if (Sk.misceval.isIndex(index)) {\n\t        index = Sk.misceval.asIndex(index);\n\t        if (index < 0) {\n\t            index = this.v.length + index;\n\t        }\n\t        if (index < 0 || index >= this.v.length) {\n\t            throw new Sk.builtin.IndexError(\"string index out of range\");\n\t        }\n\t        return new Sk.builtin.str(this.v.charAt(index));\n\t    } else if (index instanceof Sk.builtin.slice) {\n\t        ret = \"\";\n\t        index.sssiter$(this, function (i, wrt) {\n\t            if (i >= 0 && i < wrt.v.length) {\n\t                ret += wrt.v.charAt(i);\n\t            }\n\t        });\n\t        return new Sk.builtin.str(ret);\n\t    } else {\n\t        throw new Sk.builtin.TypeError(\"string indices must be integers, not \" + Sk.abstr.typeName(index));\n\t    }\n\t};\n\n\tSk.builtin.str.prototype.sq$length = function () {\n\t    return this.v.length;\n\t};\n\tSk.builtin.str.prototype.sq$concat = function (other) {\n\t    var otypename;\n\t    if (!other || !Sk.builtin.checkString(other)) {\n\t        otypename = Sk.abstr.typeName(other);\n\t        throw new Sk.builtin.TypeError(\"cannot concatenate 'str' and '\" + otypename + \"' objects\");\n\t    }\n\t    return new Sk.builtin.str(this.v + other.v);\n\t};\n\tSk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;\n\tSk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;\n\tSk.builtin.str.prototype.sq$repeat = function (n) {\n\t    var i;\n\t    var ret;\n\n\t    if (!Sk.misceval.isIndex(n)) {\n\t        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n\t    }\n\n\t    n = Sk.misceval.asIndex(n);\n\t    ret = \"\";\n\t    for (i = 0; i < n; ++i) {\n\t        ret += this.v;\n\t    }\n\t    return new Sk.builtin.str(ret);\n\t};\n\tSk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;\n\tSk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;\n\tSk.builtin.str.prototype.sq$item = function () {\n\t    goog.asserts.fail();\n\t};\n\tSk.builtin.str.prototype.sq$slice = function (i1, i2) {\n\t    i1 = Sk.builtin.asnum$(i1);\n\t    i2 = Sk.builtin.asnum$(i2);\n\t    if (i1 < 0) {\n\t        i1 = 0;\n\t    }\n\t    return new Sk.builtin.str(this.v.substr(i1, i2 - i1));\n\t};\n\n\tSk.builtin.str.prototype.sq$contains = function (ob) {\n\t    if (!(ob instanceof Sk.builtin.str)) {\n\t        throw new Sk.builtin.TypeError(\"TypeError: 'In <string> requires string as left operand\");\n\t    }\n\t    return this.v.indexOf(ob.v) != -1;\n\t};\n\n\tSk.builtin.str.prototype.__iter__ = new Sk.builtin.func(function (self) {\n\t    return new Sk.builtin.str_iter_(self);\n\t});\n\n\tSk.builtin.str.prototype.tp$iter = function () {\n\t    return new Sk.builtin.str_iter_(this);\n\t};\n\n\tSk.builtin.str.prototype.tp$richcompare = function (other, op) {\n\t    if (!(other instanceof Sk.builtin.str)) {\n\t        return undefined;\n\t    }\n\n\t    switch (op) {\n\t        case \"Lt\":\n\t            return this.v < other.v;\n\t        case \"LtE\":\n\t            return this.v <= other.v;\n\t        case \"Eq\":\n\t            return this.v === other.v;\n\t        case \"NotEq\":\n\t            return this.v !== other.v;\n\t        case \"Gt\":\n\t            return this.v > other.v;\n\t        case \"GtE\":\n\t            return this.v >= other.v;\n\t        default:\n\t            goog.asserts.fail();\n\t    }\n\t};\n\n\tSk.builtin.str.prototype[\"$r\"] = function () {\n\t    // single is preferred\n\t    var ashex;\n\t    var c;\n\t    var i;\n\t    var ret;\n\t    var len;\n\t    var quote = \"'\";\n\t    //jshint ignore:start\n\t    if (this.v.indexOf(\"'\") !== -1 && this.v.indexOf('\"') === -1) {\n\t        quote = '\"';\n\t    }\n\t    //jshint ignore:end\n\t    len = this.v.length;\n\t    ret = quote;\n\t    for (i = 0; i < len; ++i) {\n\t        c = this.v.charAt(i);\n\t        if (c === quote || c === \"\\\\\") {\n\t            ret += \"\\\\\" + c;\n\t        } else if (c === \"\\t\") {\n\t            ret += \"\\\\t\";\n\t        } else if (c === \"\\n\") {\n\t            ret += \"\\\\n\";\n\t        } else if (c === \"\\r\") {\n\t            ret += \"\\\\r\";\n\t        } else if (c < \" \" || c >= 0x7f) {\n\t            ashex = c.charCodeAt(0).toString(16);\n\t            if (ashex.length < 2) {\n\t                ashex = \"0\" + ashex;\n\t            }\n\t            ret += \"\\\\x\" + ashex;\n\t        } else {\n\t            ret += c;\n\t        }\n\t    }\n\t    ret += quote;\n\t    return new Sk.builtin.str(ret);\n\t};\n\n\n\tSk.builtin.str.re_escape_ = function (s) {\n\t    var c;\n\t    var i;\n\t    var ret = [];\n\t    var re = /^[A-Za-z0-9]+$/;\n\t    for (i = 0; i < s.length; ++i) {\n\t        c = s.charAt(i);\n\n\t        if (re.test(c)) {\n\t            ret.push(c);\n\t        } else {\n\t            if (c === \"\\\\000\") {\n\t                ret.push(\"\\\\000\");\n\t            } else {\n\t                ret.push(\"\\\\\" + c);\n\t            }\n\t        }\n\t    }\n\t    return ret.join(\"\");\n\t};\n\n\tSk.builtin.str.prototype[\"lower\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"lower\", arguments, 1, 1);\n\t    return new Sk.builtin.str(self.v.toLowerCase());\n\t});\n\n\tSk.builtin.str.prototype[\"upper\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"upper\", arguments, 1, 1);\n\t    return new Sk.builtin.str(self.v.toUpperCase());\n\t});\n\n\tSk.builtin.str.prototype[\"capitalize\"] = new Sk.builtin.func(function (self) {\n\t    var i;\n\t    var cap;\n\t    var orig;\n\t    Sk.builtin.pyCheckArgs(\"capitalize\", arguments, 1, 1);\n\t    orig = self.v;\n\n\t    if (orig.length === 0) {\n\t        return new Sk.builtin.str(\"\");\n\t    }\n\t    cap = orig.charAt(0).toUpperCase();\n\n\t    for (i = 1; i < orig.length; i++) {\n\t        cap += orig.charAt(i).toLowerCase();\n\t    }\n\t    return new Sk.builtin.str(cap);\n\t});\n\n\tSk.builtin.str.prototype[\"join\"] = new Sk.builtin.func(function (self, seq) {\n\t    var it, i;\n\t    var arrOfStrs;\n\t    Sk.builtin.pyCheckArgs(\"join\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"seq\", \"iterable\", Sk.builtin.checkIterable(seq));\n\t    arrOfStrs = [];\n\t    for (it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n\t        if (i.constructor !== Sk.builtin.str) {\n\t            throw new Sk.builtin.TypeError(\"TypeError: sequence item \" + arrOfStrs.length + \": expected string, \" + typeof i + \" found\");\n\t        }\n\t        arrOfStrs.push(i.v);\n\t    }\n\t    return new Sk.builtin.str(arrOfStrs.join(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"split\"] = new Sk.builtin.func(function (self, on, howmany) {\n\t    var splits;\n\t    var index;\n\t    var match;\n\t    var result;\n\t    var s;\n\t    var str;\n\t    var regex;\n\t    Sk.builtin.pyCheckArgs(\"split\", arguments, 1, 3);\n\t    if ((on === undefined) || (on instanceof Sk.builtin.none)) {\n\t        on = null;\n\t    }\n\t    if ((on !== null) && !Sk.builtin.checkString(on)) {\n\t        throw new Sk.builtin.TypeError(\"expected a string\");\n\t    }\n\t    if ((on !== null) && on.v === \"\") {\n\t        throw new Sk.builtin.ValueError(\"empty separator\");\n\t    }\n\t    if ((howmany !== undefined) && !Sk.builtin.checkInt(howmany)) {\n\t        throw new Sk.builtin.TypeError(\"an integer is required\");\n\t    }\n\n\t    howmany = Sk.builtin.asnum$(howmany);\n\t    regex = /[\\s]+/g;\n\t    str = self.v;\n\t    if (on === null) {\n\t        str = goog.string.trimLeft(str);\n\t    } else {\n\t        // Escape special characters in \"on\" so we can use a regexp\n\t        s = on.v.replace(/([.*+?=|\\\\\\/()\\[\\]\\{\\}^$])/g, \"\\\\$1\");\n\t        regex = new RegExp(s, \"g\");\n\t    }\n\n\t    // This is almost identical to re.split,\n\t    // except how the regexp is constructed\n\n\t    result = [];\n\t    index = 0;\n\t    splits = 0;\n\t    while ((match = regex.exec(str)) != null) {\n\t        if (match.index === regex.lastIndex) {\n\t            // empty match\n\t            break;\n\t        }\n\t        result.push(new Sk.builtin.str(str.substring(index, match.index)));\n\t        index = regex.lastIndex;\n\t        splits += 1;\n\t        if (howmany && (splits >= howmany)) {\n\t            break;\n\t        }\n\t    }\n\t    str = str.substring(index);\n\t    if (on !== null || (str.length > 0)) {\n\t        result.push(new Sk.builtin.str(str));\n\t    }\n\n\t    return new Sk.builtin.list(result);\n\t});\n\n\tSk.builtin.str.prototype[\"strip\"] = new Sk.builtin.func(function (self, chars) {\n\t    var regex;\n\t    var pattern;\n\t    Sk.builtin.pyCheckArgs(\"strip\", arguments, 1, 2);\n\t    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n\t        throw new Sk.builtin.TypeError(\"strip arg must be None or str\");\n\t    }\n\t    if (chars === undefined) {\n\t        pattern = /^\\s+|\\s+$/g;\n\t    } else {\n\t        regex = Sk.builtin.str.re_escape_(chars.v);\n\t        pattern = new RegExp(\"^[\" + regex + \"]+|[\" + regex + \"]+$\", \"g\");\n\t    }\n\t    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n\t});\n\n\tSk.builtin.str.prototype[\"lstrip\"] = new Sk.builtin.func(function (self, chars) {\n\t    var regex;\n\t    var pattern;\n\t    Sk.builtin.pyCheckArgs(\"lstrip\", arguments, 1, 2);\n\t    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n\t        throw new Sk.builtin.TypeError(\"lstrip arg must be None or str\");\n\t    }\n\t    if (chars === undefined) {\n\t        pattern = /^\\s+/g;\n\t    } else {\n\t        regex = Sk.builtin.str.re_escape_(chars.v);\n\t        pattern = new RegExp(\"^[\" + regex + \"]+\", \"g\");\n\t    }\n\t    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n\t});\n\n\tSk.builtin.str.prototype[\"rstrip\"] = new Sk.builtin.func(function (self, chars) {\n\t    var regex;\n\t    var pattern;\n\t    Sk.builtin.pyCheckArgs(\"rstrip\", arguments, 1, 2);\n\t    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n\t        throw new Sk.builtin.TypeError(\"rstrip arg must be None or str\");\n\t    }\n\t    if (chars === undefined) {\n\t        pattern = /\\s+$/g;\n\t    } else {\n\t        regex = Sk.builtin.str.re_escape_(chars.v);\n\t        pattern = new RegExp(\"[\" + regex + \"]+$\", \"g\");\n\t    }\n\t    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n\t});\n\n\tSk.builtin.str.prototype[\"partition\"] = new Sk.builtin.func(function (self, sep) {\n\t    var pos;\n\t    var sepStr;\n\t    Sk.builtin.pyCheckArgs(\"partition\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\n\t    sepStr = new Sk.builtin.str(sep);\n\t    pos = self.v.indexOf(sepStr.v);\n\t    if (pos < 0) {\n\t        return new Sk.builtin.tuple([self, Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr]);\n\t    }\n\n\t    return new Sk.builtin.tuple([\n\t        new Sk.builtin.str(self.v.substring(0, pos)),\n\t        sepStr,\n\t        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\n\t});\n\n\tSk.builtin.str.prototype[\"rpartition\"] = new Sk.builtin.func(function (self, sep) {\n\t    var pos;\n\t    var sepStr;\n\t    Sk.builtin.pyCheckArgs(\"rpartition\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\n\t    sepStr = new Sk.builtin.str(sep);\n\t    pos = self.v.lastIndexOf(sepStr.v);\n\t    if (pos < 0) {\n\t        return new Sk.builtin.tuple([Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr, self]);\n\t    }\n\n\t    return new Sk.builtin.tuple([\n\t        new Sk.builtin.str(self.v.substring(0, pos)),\n\t        sepStr,\n\t        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\n\t});\n\n\tSk.builtin.str.prototype[\"count\"] = new Sk.builtin.func(function (self, pat, start, end) {\n\t    var normaltext;\n\t    var ctl;\n\t    var slice;\n\t    var m;\n\t    Sk.builtin.pyCheckArgs(\"count\", arguments, 2, 4);\n\t    if (!Sk.builtin.checkString(pat)) {\n\t        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n\t    }\n\t    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\t    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\n\t    if (start === undefined) {\n\t        start = 0;\n\t    } else {\n\t        start = Sk.builtin.asnum$(start);\n\t        start = start >= 0 ? start : self.v.length + start;\n\t    }\n\n\t    if (end === undefined) {\n\t        end = self.v.length;\n\t    } else {\n\t        end = Sk.builtin.asnum$(end);\n\t        end = end >= 0 ? end : self.v.length + end;\n\t    }\n\n\t    normaltext = pat.v.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n\t    m = new RegExp(normaltext, \"g\");\n\t    slice = self.v.slice(start, end);\n\t    ctl = slice.match(m);\n\t    if (!ctl) {\n\t        return  new Sk.builtin.int_(0);\n\t    } else {\n\t        return new Sk.builtin.int_(ctl.length);\n\t    }\n\n\t});\n\n\tSk.builtin.str.prototype[\"ljust\"] = new Sk.builtin.func(function (self, len, fillchar) {\n\t    var newstr;\n\t    Sk.builtin.pyCheckArgs(\"ljust\", arguments, 2, 3);\n\t    if (!Sk.builtin.checkInt(len)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n\t    }\n\t    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n\t        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n\t    }\n\t    if (fillchar === undefined) {\n\t        fillchar = \" \";\n\t    } else {\n\t        fillchar = fillchar.v;\n\t    }\n\t    len = Sk.builtin.asnum$(len);\n\t    if (self.v.length >= len) {\n\t        return self;\n\t    } else {\n\t        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\n\t        return new Sk.builtin.str(self.v + newstr);\n\t    }\n\t});\n\n\tSk.builtin.str.prototype[\"rjust\"] = new Sk.builtin.func(function (self, len, fillchar) {\n\t    var newstr;\n\t    Sk.builtin.pyCheckArgs(\"rjust\", arguments, 2, 3);\n\t    if (!Sk.builtin.checkInt(len)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n\t    }\n\t    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n\t        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n\t    }\n\t    if (fillchar === undefined) {\n\t        fillchar = \" \";\n\t    } else {\n\t        fillchar = fillchar.v;\n\t    }\n\t    len = Sk.builtin.asnum$(len);\n\t    if (self.v.length >= len) {\n\t        return self;\n\t    } else {\n\t        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\n\t        return new Sk.builtin.str(newstr + self.v);\n\t    }\n\n\t});\n\n\tSk.builtin.str.prototype[\"center\"] = new Sk.builtin.func(function (self, len, fillchar) {\n\t    var newstr;\n\t    var newstr1;\n\t    Sk.builtin.pyCheckArgs(\"center\", arguments, 2, 3);\n\t    if (!Sk.builtin.checkInt(len)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n\t    }\n\t    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n\t        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n\t    }\n\t    if (fillchar === undefined) {\n\t        fillchar = \" \";\n\t    } else {\n\t        fillchar = fillchar.v;\n\t    }\n\t    len = Sk.builtin.asnum$(len);\n\t    if (self.v.length >= len) {\n\t        return self;\n\t    } else {\n\t        newstr1 = Array.prototype.join.call({length: Math.floor((len - self.v.length) / 2) + 1}, fillchar);\n\t        newstr = newstr1 + self.v + newstr1;\n\t        if (newstr.length < len) {\n\t            newstr = newstr + fillchar;\n\t        }\n\t        return new Sk.builtin.str(newstr);\n\t    }\n\n\t});\n\n\tSk.builtin.str.prototype[\"find\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n\t    var idx;\n\t    Sk.builtin.pyCheckArgs(\"find\", arguments, 2, 4);\n\t    if (!Sk.builtin.checkString(tgt)) {\n\t        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n\t    }\n\t    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\t    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\n\t    if (start === undefined) {\n\t        start = 0;\n\t    } else {\n\t        start = Sk.builtin.asnum$(start);\n\t        start = start >= 0 ? start : self.v.length + start;\n\t    }\n\n\t    if (end === undefined) {\n\t        end = self.v.length;\n\t    } else {\n\t        end = Sk.builtin.asnum$(end);\n\t        end = end >= 0 ? end : self.v.length + end;\n\t    }\n\n\t    idx = self.v.indexOf(tgt.v, start);\n\t    idx = ((idx >= start) && (idx < end)) ? idx : -1;\n\n\t    return new Sk.builtin.int_(idx);\n\t});\n\n\tSk.builtin.str.prototype[\"index\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n\t    var idx;\n\t    Sk.builtin.pyCheckArgs(\"index\", arguments, 2, 4);\n\t    idx = Sk.misceval.callsim(self[\"find\"], self, tgt, start, end);\n\t    if (Sk.builtin.asnum$(idx) === -1) {\n\t        throw new Sk.builtin.ValueError(\"substring not found\");\n\t    }\n\t    return idx;\n\t});\n\n\tSk.builtin.str.prototype[\"rfind\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n\t    var idx;\n\t    Sk.builtin.pyCheckArgs(\"rfind\", arguments, 2, 4);\n\t    if (!Sk.builtin.checkString(tgt)) {\n\t        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n\t    }\n\t    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\t    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\n\t    if (start === undefined) {\n\t        start = 0;\n\t    } else {\n\t        start = Sk.builtin.asnum$(start);\n\t        start = start >= 0 ? start : self.v.length + start;\n\t    }\n\n\t    if (end === undefined) {\n\t        end = self.v.length;\n\t    } else {\n\t        end = Sk.builtin.asnum$(end);\n\t        end = end >= 0 ? end : self.v.length + end;\n\t    }\n\n\t    idx = self.v.lastIndexOf(tgt.v, end);\n\t    idx = (idx !== end) ? idx : self.v.lastIndexOf(tgt.v, end - 1);\n\t    idx = ((idx >= start) && (idx < end)) ? idx : -1;\n\n\t    return new Sk.builtin.int_(idx);\n\t});\n\n\tSk.builtin.str.prototype[\"rindex\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n\t    var idx;\n\t    Sk.builtin.pyCheckArgs(\"rindex\", arguments, 2, 4);\n\t    idx = Sk.misceval.callsim(self[\"rfind\"], self, tgt, start, end);\n\t    if (Sk.builtin.asnum$(idx) === -1) {\n\t        throw new Sk.builtin.ValueError(\"substring not found\");\n\t    }\n\t    return idx;\n\t});\n\n\tSk.builtin.str.prototype[\"startswith\"] = new Sk.builtin.func(function (self, tgt) {\n\t    Sk.builtin.pyCheckArgs(\"startswith\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\n\t    return new Sk.builtin.bool( self.v.indexOf(tgt.v) === 0);\n\t});\n\n\t// http://stackoverflow.com/questions/280634/endswith-in-javascript\n\tSk.builtin.str.prototype[\"endswith\"] = new Sk.builtin.func(function (self, tgt) {\n\t    Sk.builtin.pyCheckArgs(\"endswith\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\n\t    return new Sk.builtin.bool( self.v.indexOf(tgt.v, self.v.length - tgt.v.length) !== -1);\n\t});\n\n\tSk.builtin.str.prototype[\"replace\"] = new Sk.builtin.func(function (self, oldS, newS, count) {\n\t    var c;\n\t    var patt;\n\t    Sk.builtin.pyCheckArgs(\"replace\", arguments, 3, 4);\n\t    Sk.builtin.pyCheckType(\"oldS\", \"string\", Sk.builtin.checkString(oldS));\n\t    Sk.builtin.pyCheckType(\"newS\", \"string\", Sk.builtin.checkString(newS));\n\t    if ((count !== undefined) && !Sk.builtin.checkInt(count)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument expected, got \" +\n\t            Sk.abstr.typeName(count));\n\t    }\n\t    count = Sk.builtin.asnum$(count);\n\t    patt = new RegExp(Sk.builtin.str.re_escape_(oldS.v), \"g\");\n\n\t    if ((count === undefined) || (count < 0)) {\n\t        return new Sk.builtin.str(self.v.replace(patt, newS.v));\n\t    }\n\n\t    c = 0;\n\n\t    function replacer (match) {\n\t        c++;\n\t        if (c <= count) {\n\t            return newS.v;\n\t        }\n\t        return match;\n\t    }\n\n\t    return new Sk.builtin.str(self.v.replace(patt, replacer));\n\t});\n\n\tSk.builtin.str.prototype[\"zfill\"] = new Sk.builtin.func(function (self, len) {\n\t    var str = self.v;\n\t    var ret;\n\t    var zeroes;\n\t    var offset;\n\t    var pad = \"\";\n\n\t    Sk.builtin.pyCheckArgs(\"zfill\", arguments, 2, 2);\n\t    if (! Sk.builtin.checkInt(len)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(len));\n\t    }\n\n\t    // figure out how many zeroes are needed to make the proper length\n\t    zeroes = len.v - str.length;\n\t    // offset by 1 if there is a +/- at the beginning of the string\n\t    offset = (str[0] === \"+\" || str[0] === \"-\") ? 1 : 0;\n\t    for(var i = 0; i < zeroes; i++){\n\t        pad += \"0\";\n\t    }\n\t    // combine the string and the zeroes\n\t    ret = str.substr(0, offset) + pad + str.substr(offset);\n\t    return new Sk.builtin.str(ret);\n\n\n\t});\n\n\tSk.builtin.str.prototype[\"isdigit\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isdigit\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( /^\\d+$/.test(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"isspace\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isspace\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( /^\\s+$/.test(self.v));\n\t});\n\n\n\tSk.builtin.str.prototype[\"expandtabs\"] = new Sk.builtin.func(function (self, tabsize) {\n\t    // var input = self.v;\n\t    // var expanded = \"\";\n\t    // var split;\n\t    // var spacestr = \"\";\n\t    // var spacerem;\n\n\n\t    var spaces;\n\t    var expanded;\n\n\t    Sk.builtin.pyCheckArgs(\"expandtabs\", arguments, 1, 2);\n\n\n\t    if ((tabsize !== undefined) && ! Sk.builtin.checkInt(tabsize)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(tabsize));\n\t    }\n\t    if (tabsize === undefined) {\n\t        tabsize = 8;\n\t    } else {\n\t        tabsize = Sk.builtin.asnum$(tabsize);\n\t    }\n\n\t    spaces = (new Array(tabsize + 1)).join(\" \");\n\t    expanded = self.v.replace(/([^\\r\\n\\t]*)\\t/g, function(a, b) {\n\t        return b + spaces.slice(b.length % tabsize);\n\t    });\n\t    return new Sk.builtin.str(expanded);\n\t});\n\n\tSk.builtin.str.prototype[\"swapcase\"] = new Sk.builtin.func(function (self) {\n\t    var ret;\n\t    Sk.builtin.pyCheckArgs(\"swapcase\", arguments, 1, 1);\n\n\n\t    ret = self.v.replace(/[a-z]/gi, function(c) {\n\t        var lc = c.toLowerCase();\n\t        return lc === c ? c.toUpperCase() : lc;\n\t    });\n\n\t    return new Sk.builtin.str(ret);\n\t});\n\n\tSk.builtin.str.prototype[\"splitlines\"] = new Sk.builtin.func(function (self, keepends) {\n\t    var data = self.v;\n\t    var i = 0;\n\t    var j = i;\n\t    var selflen = self.v.length;\n\t    var strs_w = [];\n\t    var ch;\n\t    var eol;\n\t    var sol = 0;\n\t    var slice;\n\t    Sk.builtin.pyCheckArgs(\"splitlines\", arguments, 1, 2);\n\t    if ((keepends !== undefined) && ! Sk.builtin.checkBool(keepends)) {\n\t        throw new Sk.builtin.TypeError(\"boolean argument expected, got \" + Sk.abstr.typeName(keepends));\n\t    }\n\t    if (keepends === undefined) {\n\t        keepends = false;\n\t    } else {\n\t        keepends = keepends.v;\n\t    }\n\n\n\t    for (i = 0; i < selflen; i ++) {\n\t        ch = data.charAt(i);\n\t        if (data.charAt(i + 1) === \"\\n\" && ch === \"\\r\") {\n\t            eol = i + 2;\n\t            slice = data.slice(sol, eol);\n\t            if (! keepends) {\n\t                slice = slice.replace(/(\\r|\\n)/g, \"\");\n\t            }\n\t            strs_w.push(new Sk.builtin.str(slice));\n\t            sol = eol;\n\t        } else if ((ch === \"\\n\" && data.charAt(i - 1) !== \"\\r\") || ch === \"\\r\") {\n\t            eol = i + 1;\n\t            slice = data.slice(sol, eol);\n\t            if (! keepends) {\n\t                slice = slice.replace(/(\\r|\\n)/g, \"\");\n\t            }\n\t            strs_w.push(new Sk.builtin.str(slice));\n\t            sol = eol;\n\t        }\n\n\t    }\n\t    if (sol < selflen) {\n\t        eol = selflen;\n\t        slice = data.slice(sol, eol);\n\t        if (! keepends) {\n\t            slice = slice.replace(/(\\r|\\n)/g, \"\");\n\t        }\n\t        strs_w.push(new Sk.builtin.str(slice));\n\t    }\n\t    return new Sk.builtin.list(strs_w);\n\t});\n\n\tSk.builtin.str.prototype[\"title\"] = new Sk.builtin.func(function (self) {\n\t    var ret;\n\n\t    Sk.builtin.pyCheckArgs(\"title\", arguments, 1, 1);\n\n\t    ret = self.v.replace(/[a-z][a-z]*/gi, function(str) {\n\t        return str[0].toUpperCase() + str.substr(1).toLowerCase();\n\t    });\n\n\t    return new Sk.builtin.str(ret);\n\t});\n\n\tSk.builtin.str.prototype[\"isalpha\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isalpha\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && goog.string.isAlpha(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"isalnum\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isalnum\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && goog.string.isAlphaNumeric(self.v));\n\t});\n\n\t// does not account for unicode numeric values\n\tSk.builtin.str.prototype[\"isnumeric\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isnumeric\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && goog.string.isNumeric(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"islower\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"islower\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && /[a-z]/.test(self.v) && !/[A-Z]/.test(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"isupper\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isupper\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && !/[a-z]/.test(self.v) && /[A-Z]/.test(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"istitle\"] = new Sk.builtin.func(function (self) {\n\t    // Comparing to str.title() seems the most intuitive thing, but it fails on \"\",\n\t    // Other empty-ish strings with no change.\n\t    var input = self.v;\n\t    var cased = false;\n\t    var previous_is_cased = false;\n\t    var pos;\n\t    var ch;\n\t    Sk.builtin.pyCheckArgs(\"istitle\", arguments, 1, 1);\n\t    for (pos = 0; pos < input.length; pos ++) {\n\t        ch = input.charAt(pos);\n\t        if (! /[a-z]/.test(ch) && /[A-Z]/.test(ch)) {\n\t            if (previous_is_cased) {\n\t                return new Sk.builtin.bool( false);\n\t            }\n\t            previous_is_cased = true;\n\t            cased = true;\n\t        } else if (/[a-z]/.test(ch) && ! /[A-Z]/.test(ch)) {\n\t            if (! previous_is_cased) {\n\t                return new Sk.builtin.bool( false);\n\t            }\n\t            cased = true;\n\t        } else {\n\t            previous_is_cased = false;\n\t        }\n\t    }\n\t    return new Sk.builtin.bool( cased);\n\t});\n\n\tSk.builtin.str.prototype.nb$remainder = function (rhs) {\n\t    // % format op. rhs can be a value, a tuple, or something with __getitem__ (dict)\n\n\t    // From http://docs.python.org/library/stdtypes.html#string-formatting the\n\t    // format looks like:\n\t    // 1. The '%' character, which marks the start of the specifier.\n\t    // 2. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)).\n\t    // 3. Conversion flags (optional), which affect the result of some conversion types.\n\t    // 4. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next\n\t    // element of the tuple in values, and the object to convert comes after the minimum field width and optional\n\t    // precision. 5. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an\n\t    // asterisk), the actual width is read from the next element of the tuple in values, and the value to convert comes\n\t    // after the precision. 6. Length modifier (optional). 7. Conversion type.  length modifier is ignored\n\n\t    var ret;\n\t    var replFunc;\n\t    var index;\n\t    var regex;\n\t    if (rhs.constructor !== Sk.builtin.tuple && (rhs.mp$subscript === undefined || rhs.constructor === Sk.builtin.str)) {\n\t        rhs = new Sk.builtin.tuple([rhs]);\n\t    }\n\n\t    // general approach is to use a regex that matches the format above, and\n\t    // do an re.sub with a function as replacement to make the subs.\n\n\t    //           1 2222222222222222   33333333   444444444   5555555555555  66666  777777777777777777\n\t    regex = /%(\\([a-zA-Z0-9]+\\))?([#0 +\\-]+)?(\\*|[0-9]+)?(\\.(\\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g;\n\t    index = 0;\n\t    replFunc = function (substring, mappingKey, conversionFlags, fieldWidth, precision, precbody, conversionType) {\n\t        var result;\n\t        var convName;\n\t        var convValue;\n\t        var base;\n\t        var r;\n\t        var mk;\n\t        var value;\n\t        var handleWidth;\n\t        var formatNumber;\n\t        var alternateForm;\n\t        var precedeWithSign;\n\t        var blankBeforePositive;\n\t        var leftAdjust;\n\t        var zeroPad;\n\t        var i;\n\t        fieldWidth = Sk.builtin.asnum$(fieldWidth);\n\t        precision = Sk.builtin.asnum$(precision);\n\n\t        if (mappingKey === undefined || mappingKey === \"\") {\n\t            i = index++;\n\t        } // ff passes '' not undef for some reason\n\n\t        if (precision === \"\") { // ff passes '' here aswell causing problems with G,g, etc.\n\t            precision = undefined;\n\t        }\n\n\t        zeroPad = false;\n\t        leftAdjust = false;\n\t        blankBeforePositive = false;\n\t        precedeWithSign = false;\n\t        alternateForm = false;\n\t        if (conversionFlags) {\n\t            if (conversionFlags.indexOf(\"-\") !== -1) {\n\t                leftAdjust = true;\n\t            } else if (conversionFlags.indexOf(\"0\") !== -1) {\n\t                zeroPad = true;\n\t            }\n\n\t            if (conversionFlags.indexOf(\"+\") !== -1) {\n\t                precedeWithSign = true;\n\t            } else if (conversionFlags.indexOf(\" \") !== -1) {\n\t                blankBeforePositive = true;\n\t            }\n\n\t            alternateForm = conversionFlags.indexOf(\"#\") !== -1;\n\t        }\n\n\t        if (precision) {\n\t            precision = parseInt(precision.substr(1), 10);\n\t        }\n\n\t        formatNumber = function (n, base) {\n\t            var precZeroPadded;\n\t            var prefix;\n\t            var didSign;\n\t            var neg;\n\t            var r;\n\t            var j;\n\t            base = Sk.builtin.asnum$(base);\n\t            neg = false;\n\t            didSign = false;\n\t            if (typeof n === \"number\") {\n\t                if (n < 0) {\n\t                    n = -n;\n\t                    neg = true;\n\t                }\n\t                r = n.toString(base);\n\t            } else if (n instanceof Sk.builtin.float_) {\n\t                r = n.str$(base, false);\n\t                if (r.length > 2 && r.substr(-2) === \".0\") {\n\t                    r = r.substr(0, r.length - 2);\n\t                }\n\t                neg = n.nb$isnegative();\n\t            } else if (n instanceof Sk.builtin.int_) {\n\t                r = n.str$(base, false);\n\t                neg = n.nb$isnegative();\n\t            } else if (n instanceof Sk.builtin.lng) {\n\t                r = n.str$(base, false);\n\t                neg = n.nb$isnegative();\t//\tneg = n.size$ < 0;\tRNL long.js change\n\t            }\n\n\t            goog.asserts.assert(r !== undefined, \"unhandled number format\");\n\n\t            precZeroPadded = false;\n\n\t            if (precision) {\n\t                //print(\"r.length\",r.length,\"precision\",precision);\n\t                for (j = r.length; j < precision; ++j) {\n\t                    r = \"0\" + r;\n\t                    precZeroPadded = true;\n\t                }\n\t            }\n\n\t            prefix = \"\";\n\n\t            if (neg) {\n\t                prefix = \"-\";\n\t            } else if (precedeWithSign) {\n\t                prefix = \"+\" + prefix;\n\t            } else if (blankBeforePositive) {\n\t                prefix = \" \" + prefix;\n\t            }\n\n\t            if (alternateForm) {\n\t                if (base === 16) {\n\t                    prefix += \"0x\";\n\t                } else if (base === 8 && !precZeroPadded && r !== \"0\") {\n\t                    prefix += \"0\";\n\t                }\n\t            }\n\n\t            return [prefix, r];\n\t        };\n\n\t        handleWidth = function (args) {\n\t            var totLen;\n\t            var prefix = args[0];\n\t            var r = args[1];\n\t            var j;\n\t            if (fieldWidth) {\n\t                fieldWidth = parseInt(fieldWidth, 10);\n\t                totLen = r.length + prefix.length;\n\t                if (zeroPad) {\n\t                    for (j = totLen; j < fieldWidth; ++j) {\n\t                        r = \"0\" + r;\n\t                    }\n\t                } else if (leftAdjust) {\n\t                    for (j = totLen; j < fieldWidth; ++j) {\n\t                        r = r + \" \";\n\t                    }\n\t                } else {\n\t                    for (j = totLen; j < fieldWidth; ++j) {\n\t                        prefix = \" \" + prefix;\n\t                    }\n\t                }\n\t            }\n\t            return prefix + r;\n\t        };\n\n\t        //print(\"Rhs:\",rhs, \"ctor\", rhs.constructor);\n\t        if (rhs.constructor === Sk.builtin.tuple) {\n\t            value = rhs.v[i];\n\t        } else if (rhs.mp$subscript !== undefined && mappingKey !== undefined) {\n\t            mk = mappingKey.substring(1, mappingKey.length - 1);\n\t            //print(\"mk\",mk);\n\t            value = rhs.mp$subscript(new Sk.builtin.str(mk));\n\t        } else if (rhs.constructor === Sk.builtin.dict || rhs.constructor === Sk.builtin.list) {\n\t            // new case where only one argument is provided\n\t            value = rhs;\n\t        } else {\n\t            throw new Sk.builtin.AttributeError(rhs.tp$name + \" instance has no attribute 'mp$subscript'\");\n\t        }\n\t        base = 10;\n\t        if (conversionType === \"d\" || conversionType === \"i\") {\n\t            return handleWidth(formatNumber(value, 10));\n\t        } else if (conversionType === \"o\") {\n\t            return handleWidth(formatNumber(value, 8));\n\t        } else if (conversionType === \"x\") {\n\t            return handleWidth(formatNumber(value, 16));\n\t        } else if (conversionType === \"X\") {\n\t            return handleWidth(formatNumber(value, 16)).toUpperCase();\n\t        } else if (conversionType === \"f\" || conversionType === \"F\" || conversionType === \"e\" || conversionType === \"E\" || conversionType === \"g\" || conversionType === \"G\") {\n\t            convValue = Sk.builtin.asnum$(value);\n\t            if (typeof convValue === \"string\") {\n\t                convValue = Number(convValue);\n\t            }\n\t            if (convValue === Infinity) {\n\t                return \"inf\";\n\t            }\n\t            if (convValue === -Infinity) {\n\t                return \"-inf\";\n\t            }\n\t            if (isNaN(convValue)) {\n\t                return \"nan\";\n\t            }\n\t            convName = [\"toExponential\", \"toFixed\", \"toPrecision\"][\"efg\".indexOf(conversionType.toLowerCase())];\n\t            if (precision === undefined || precision === \"\") {\n\t                if (conversionType === \"e\" || conversionType === \"E\") {\n\t                    precision = 6;\n\t                } else if (conversionType === \"f\" || conversionType === \"F\") {\n\t                    precision = 7;\n\t                }\n\t            }\n\t            result = (convValue)[convName](precision); // possible loose of negative zero sign\n\n\t            // apply sign to negative zeros, floats only!\n\t            if(Sk.builtin.checkFloat(value)) {\n\t                if(convValue === 0 && 1/convValue === -Infinity) {\n\t                    result = \"-\" + result; // add sign for zero\n\t                }\n\t            }\n\n\t            if (\"EFG\".indexOf(conversionType) !== -1) {\n\t                result = result.toUpperCase();\n\t            }\n\t            return handleWidth([\"\", result]);\n\t        } else if (conversionType === \"c\") {\n\t            if (typeof value === \"number\") {\n\t                return String.fromCharCode(value);\n\t            } else if (value instanceof Sk.builtin.int_) {\n\t                return String.fromCharCode(value.v);\n\t            } else if (value instanceof Sk.builtin.float_) {\n\t                return String.fromCharCode(value.v);\n\t            } else if (value instanceof Sk.builtin.lng) {\n\t                return String.fromCharCode(value.str$(10, false)[0]);\n\t            } else if (value.constructor === Sk.builtin.str) {\n\t                return value.v.substr(0, 1);\n\t            } else {\n\t                throw new Sk.builtin.TypeError(\"an integer is required\");\n\t            }\n\t        } else if (conversionType === \"r\") {\n\t            r = Sk.builtin.repr(value);\n\t            if (precision) {\n\t                return r.v.substr(0, precision);\n\t            }\n\t            return r.v;\n\t        } else if (conversionType === \"s\") {\n\t            r = new Sk.builtin.str(value);\n\t            if (precision) {\n\t                return r.v.substr(0, precision);\n\t            }\n\t            if(fieldWidth) {\n\t                r.v = handleWidth([\" \", r.v]);\n\t            }\n\t            return r.v;\n\t        } else if (conversionType === \"%\") {\n\t            return \"%\";\n\t        }\n\t    };\n\n\t    ret = this.v.replace(regex, replFunc);\n\t    return new Sk.builtin.str(ret);\n\t};\n\n\t/**\n\t * @constructor\n\t * @param {Object} obj\n\t */\n\tSk.builtin.str_iter_ = function (obj) {\n\t    if (!(this instanceof Sk.builtin.str_iter_)) {\n\t        return new Sk.builtin.str_iter_(obj);\n\t    }\n\t    this.$index = 0;\n\t    this.$obj = obj.v.slice();\n\t    this.sq$length = this.$obj.length;\n\t    this.tp$iter = this;\n\t    this.tp$iternext = function () {\n\t        if (this.$index >= this.sq$length) {\n\t            return undefined;\n\t        }\n\t        return new Sk.builtin.str(this.$obj.substr(this.$index++, 1));\n\t    };\n\t    this.$r = function () {\n\t        return new Sk.builtin.str(\"iterator\");\n\t    };\n\t    return this;\n\t};\n\n\tSk.abstr.setUpInheritance(\"iterator\", Sk.builtin.str_iter_, Sk.builtin.object);\n\n\tSk.builtin.str_iter_.prototype.__class__ = Sk.builtin.str_iter_;\n\n\tSk.builtin.str_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"__iter__\", arguments, 0, 0, true, false);\n\t    return self;\n\t});\n\n\tSk.builtin.str_iter_.prototype[\"next\"] = new Sk.builtin.func(function (self) {\n\t    var ret = self.tp$iternext();\n\t    if (ret === undefined) {\n\t        throw new Sk.builtin.StopIteration();\n\t    }\n\t    return ret;\n\t});\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/tokenize.js ---- */ \n\n\t/*\n\t * This is a port of tokenize.py by Ka-Ping Yee.\n\t *\n\t * each call to readline should return one line of input as a string, or\n\t * undefined if it's finished.\n\t *\n\t * callback is called for each token with 5 args:\n\t * 1. the token type\n\t * 2. the token string\n\t * 3. [ start_row, start_col ]\n\t * 4. [ end_row, end_col ]\n\t * 5. logical line where the token was found, including continuation lines\n\t *\n\t * callback can return true to abort.\n\t *\n\t */\n\n\t/**\n\t * @constructor\n\t */\n\tSk.Tokenizer = function (filename, interactive, callback) {\n\t    this.filename = filename;\n\t    this.callback = callback;\n\t    this.lnum = 0;\n\t    this.parenlev = 0;\n\t    this.parenstack = [];\n\t    this.continued = false;\n\t    this.namechars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\";\n\t    this.numchars = \"0123456789\";\n\t    this.contstr = \"\";\n\t    this.needcont = false;\n\t    this.contline = undefined;\n\t    this.indents = [0];\n\t    this.endprog = /.*/;\n\t    this.strstart = [-1, -1];\n\t    this.interactive = interactive;\n\t    this.doneFunc = function () {\n\t        var i;\n\t        for (i = 1; i < this.indents.length; ++i) // pop remaining indent levels\n\t        {\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, \"\", [this.lnum, 0], [this.lnum, 0], \"\")) {\n\t                return \"done\";\n\t            }\n\t        }\n\t        if (this.callback(Sk.Tokenizer.Tokens.T_ENDMARKER, \"\", [this.lnum, 0], [this.lnum, 0], \"\")) {\n\t            return \"done\";\n\t        }\n\n\t        return \"failed\";\n\t    };\n\n\t};\n\n\t/**\n\t * @enum {number}\n\t */\n\tSk.Tokenizer.Tokens = {\n\t    T_ENDMARKER       : 0,\n\t    T_NAME            : 1,\n\t    T_NUMBER          : 2,\n\t    T_STRING          : 3,\n\t    T_NEWLINE         : 4,\n\t    T_INDENT          : 5,\n\t    T_DEDENT          : 6,\n\t    T_LPAR            : 7,\n\t    T_RPAR            : 8,\n\t    T_LSQB            : 9,\n\t    T_RSQB            : 10,\n\t    T_COLON           : 11,\n\t    T_COMMA           : 12,\n\t    T_SEMI            : 13,\n\t    T_PLUS            : 14,\n\t    T_MINUS           : 15,\n\t    T_STAR            : 16,\n\t    T_SLASH           : 17,\n\t    T_VBAR            : 18,\n\t    T_AMPER           : 19,\n\t    T_LESS            : 20,\n\t    T_GREATER         : 21,\n\t    T_EQUAL           : 22,\n\t    T_DOT             : 23,\n\t    T_PERCENT         : 24,\n\t    T_BACKQUOTE       : 25,\n\t    T_LBRACE          : 26,\n\t    T_RBRACE          : 27,\n\t    T_EQEQUAL         : 28,\n\t    T_NOTEQUAL        : 29,\n\t    T_LESSEQUAL       : 30,\n\t    T_GREATEREQUAL    : 31,\n\t    T_TILDE           : 32,\n\t    T_CIRCUMFLEX      : 33,\n\t    T_LEFTSHIFT       : 34,\n\t    T_RIGHTSHIFT      : 35,\n\t    T_DOUBLESTAR      : 36,\n\t    T_PLUSEQUAL       : 37,\n\t    T_MINEQUAL        : 38,\n\t    T_STAREQUAL       : 39,\n\t    T_SLASHEQUAL      : 40,\n\t    T_PERCENTEQUAL    : 41,\n\t    T_AMPEREQUAL      : 42,\n\t    T_VBAREQUAL       : 43,\n\t    T_CIRCUMFLEXEQUAL : 44,\n\t    T_LEFTSHIFTEQUAL  : 45,\n\t    T_RIGHTSHIFTEQUAL : 46,\n\t    T_DOUBLESTAREQUAL : 47,\n\t    T_DOUBLESLASH     : 48,\n\t    T_DOUBLESLASHEQUAL: 49,\n\t    T_AT              : 50,\n\t    T_OP              : 51,\n\t    T_COMMENT         : 52,\n\t    T_NL              : 53,\n\t    T_RARROW          : 54,\n\t    T_ERRORTOKEN      : 55,\n\t    T_N_TOKENS        : 56,\n\t    T_NT_OFFSET       : 256\n\t};\n\n\t/** @param {...*} x */\n\tfunction group (x) {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    return \"(\" + args.join(\"|\") + \")\";\n\t}\n\n\t/** @param {...*} x */\n\tfunction any (x) {\n\t    return group.apply(null, arguments) + \"*\";\n\t}\n\n\t/** @param {...*} x */\n\tfunction maybe (x) {\n\t    return group.apply(null, arguments) + \"?\";\n\t}\n\n\t/* we have to use string and ctor to be able to build patterns up. + on /.../\n\t * does something strange. */\n\tvar Whitespace = \"[ \\\\f\\\\t]*\";\n\tvar Comment_ = \"#[^\\\\r\\\\n]*\";\n\tvar Ident = \"[a-zA-Z_]\\\\w*\";\n\n\tvar Binnumber = \"0[bB][01]*\";\n\tvar Hexnumber = \"0[xX][\\\\da-fA-F]*[lL]?\";\n\tvar Octnumber = \"0[oO]?[0-7]*[lL]?\";\n\tvar Decnumber = \"[1-9]\\\\d*[lL]?\";\n\tvar Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber);\n\n\tvar Exponent = \"[eE][-+]?\\\\d+\";\n\tvar Pointfloat = group(\"\\\\d+\\\\.\\\\d*\", \"\\\\.\\\\d+\") + maybe(Exponent);\n\tvar Expfloat = \"\\\\d+\" + Exponent;\n\tvar Floatnumber = group(Pointfloat, Expfloat);\n\tvar Imagnumber = group(\"\\\\d+[jJ]\", Floatnumber + \"[jJ]\");\n\tvar Number_ = group(Imagnumber, Floatnumber, Intnumber);\n\n\t// tail end of ' string\n\tvar Single = \"^[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*'\";\n\t// tail end of \" string\n\tvar Double_ = '^[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"';\n\t// tail end of ''' string\n\tvar Single3 = \"[^'\\\\\\\\]*(?:(?:\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*'''\";\n\t// tail end of \"\"\" string\n\tvar Double3 = '[^\"\\\\\\\\]*(?:(?:\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*\"\"\"';\n\tvar Triple = group(\"[ubUB]?[rR]?'''\", '[ubUB]?[rR]?\"\"\"');\n\tvar String_ = group(\"[uU]?[rR]?'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*'\",\n\t    '[uU]?[rR]?\"[^\\\\n\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\"\\\\\\\\]*)*\"');\n\n\t// Because of leftmost-then-longest match semantics, be sure to put the\n\t// longest operators first (e.g., if = came before ==, == would get\n\t// recognized as two instances of =).\n\tvar Operator = group(\"\\\\*\\\\*=?\", \">>=?\", \"<<=?\", \"<>\", \"!=\",\n\t    \"//=?\", \"->\",\n\t    \"[+\\\\-*/%&|^=<>]=?\",\n\t    \"~\");\n\n\tvar Bracket = \"[\\\\][(){}]\";\n\tvar Special = group(\"\\\\r?\\\\n\", \"[:;.,`@]\");\n\tvar Funny = group(Operator, Bracket, Special);\n\n\tvar ContStr = group(\"[uUbB]?[rR]?'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*\" +\n\t        group(\"'\", \"\\\\\\\\\\\\r?\\\\n\"),\n\t        \"[uUbB]?[rR]?\\\"[^\\\\n\\\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\\\"\\\\\\\\]*)*\" +\n\t        group(\"\\\"\", \"\\\\\\\\\\\\r?\\\\n\"));\n\tvar PseudoExtras = group(\"\\\\\\\\\\\\r?\\\\n\", Comment_, Triple);\n\t// Need to prefix with \"^\" as we only want to match what's next\n\tvar PseudoToken = \"^\" + group(PseudoExtras, Number_, Funny, ContStr, Ident);\n\n\n\tvar triple_quoted = {\n\t    \"'''\"  : true, '\"\"\"': true,\n\t    \"r'''\" : true, 'r\"\"\"': true, \"R'''\": true, 'R\"\"\"': true,\n\t    \"u'''\" : true, 'u\"\"\"': true, \"U'''\": true, 'U\"\"\"': true,\n\t    \"b'''\" : true, 'b\"\"\"': true, \"B'''\": true, 'B\"\"\"': true,\n\t    \"ur'''\": true, 'ur\"\"\"': true, \"Ur'''\": true, 'Ur\"\"\"': true,\n\t    \"uR'''\": true, 'uR\"\"\"': true, \"UR'''\": true, 'UR\"\"\"': true,\n\t    \"br'''\": true, 'br\"\"\"': true, \"Br'''\": true, 'Br\"\"\"': true,\n\t    \"bR'''\": true, 'bR\"\"\"': true, \"BR'''\": true, 'BR\"\"\"': true\n\t};\n\n\tvar single_quoted = {\n\t    \"'\"  : true, '\"': true,\n\t    \"r'\" : true, 'r\"': true, \"R'\": true, 'R\"': true,\n\t    \"u'\" : true, 'u\"': true, \"U'\": true, 'U\"': true,\n\t    \"b'\" : true, 'b\"': true, \"B'\": true, 'B\"': true,\n\t    \"ur'\": true, 'ur\"': true, \"Ur'\": true, 'Ur\"': true,\n\t    \"uR'\": true, 'uR\"': true, \"UR'\": true, 'UR\"': true,\n\t    \"br'\": true, 'br\"': true, \"Br'\": true, 'Br\"': true,\n\t    \"bR'\": true, 'bR\"': true, \"BR'\": true, 'BR\"': true\n\t};\n\n\t// hack to make closure keep those objects. not sure what a better way is.\n\t(function () {\n\t    var k;\n\t    for (k in triple_quoted) {\n\t    }\n\t    for (k in single_quoted) {\n\t    }\n\t}());\n\n\n\tvar tabsize = 8;\n\n\tfunction contains (a, obj) {\n\t    var i = a.length;\n\t    while (i--) {\n\t        if (a[i] === obj) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\tfunction rstrip (input, what) {\n\t    var i;\n\t    for (i = input.length; i > 0; --i) {\n\t        if (what.indexOf(input.charAt(i - 1)) === -1) {\n\t            break;\n\t        }\n\t    }\n\t    return input.substring(0, i);\n\t}\n\n\tSk.Tokenizer.prototype.generateTokens = function (line) {\n\t    var nl_pos;\n\t    var newl;\n\t    var initial;\n\t    var token;\n\t    var epos;\n\t    var spos;\n\t    var start;\n\t    var pseudomatch;\n\t    var capos;\n\t    var comment_token;\n\t    var endmatch, pos, column, end, max;\n\n\n\t    // bnm - Move these definitions in this function otherwise test state is preserved between\n\t    // calls on single3prog and double3prog causing weird errors with having multiple instances\n\t    // of triple quoted strings in the same program.\n\n\t    var pseudoprog = new RegExp(PseudoToken);\n\t    var single3prog = new RegExp(Single3, \"g\");\n\t    var double3prog = new RegExp(Double3, \"g\");\n\n\t    var endprogs = {     \"'\": new RegExp(Single, \"g\"), \"\\\"\": new RegExp(Double_, \"g\"),\n\t        \"'''\"               : single3prog, '\"\"\"': double3prog,\n\t        \"r'''\"              : single3prog, 'r\"\"\"': double3prog,\n\t        \"u'''\"              : single3prog, 'u\"\"\"': double3prog,\n\t        \"b'''\"              : single3prog, 'b\"\"\"': double3prog,\n\t        \"ur'''\"             : single3prog, 'ur\"\"\"': double3prog,\n\t        \"br'''\"             : single3prog, 'br\"\"\"': double3prog,\n\t        \"R'''\"              : single3prog, 'R\"\"\"': double3prog,\n\t        \"U'''\"              : single3prog, 'U\"\"\"': double3prog,\n\t        \"B'''\"              : single3prog, 'B\"\"\"': double3prog,\n\t        \"uR'''\"             : single3prog, 'uR\"\"\"': double3prog,\n\t        \"Ur'''\"             : single3prog, 'Ur\"\"\"': double3prog,\n\t        \"UR'''\"             : single3prog, 'UR\"\"\"': double3prog,\n\t        \"bR'''\"             : single3prog, 'bR\"\"\"': double3prog,\n\t        \"Br'''\"             : single3prog, 'Br\"\"\"': double3prog,\n\t        \"BR'''\"             : single3prog, 'BR\"\"\"': double3prog,\n\t        'r'                 : null, 'R': null,\n\t        'u'                 : null, 'U': null,\n\t        'b'                 : null, 'B': null\n\t    };\n\n\n\t    if (!line) {\n\t        line = '';\n\t    }\n\t    //print(\"LINE:'\"+line+\"'\");\n\n\t    this.lnum += 1;\n\t    pos = 0;\n\t    max = line.length;\n\n\t    if (this.contstr.length > 0) {\n\t        if (!line) {\n\t            throw new Sk.builtin.SyntaxError(\"EOF in multi-line string\", this.filename, this.strstart[0], this.strstart[1], {\n\t                kind: \"STRING_EOF\",\n\t                line: this.contline\n\t            });\n\t        }\n\t        this.endprog.lastIndex = 0;\n\t        endmatch = this.endprog.test(line);\n\t        if (endmatch) {\n\t            pos = end = this.endprog.lastIndex;\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_STRING, this.contstr + line.substring(0, end),\n\t                this.strstart, [this.lnum, end], this.contline + line)) {\n\t                return 'done';\n\t            }\n\t            this.contstr = '';\n\t            this.needcont = false;\n\t            this.contline = undefined;\n\t        }\n\t        else if (this.needcont && line.substring(line.length - 2) !== \"\\\\\\n\" && line.substring(line.length - 3) !== \"\\\\\\r\\n\") {\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, this.contstr + line,\n\t                this.strstart, [this.lnum, line.length], this.contline)) {\n\t                return 'done';\n\t            }\n\t            this.contstr = '';\n\t            this.contline = undefined;\n\t            return false;\n\t        }\n\t        else {\n\t            this.contstr += line;\n\t            this.contline = this.contline + line;\n\t            return false;\n\t        }\n\t    }\n\t    else if (this.parenlev === 0 && !this.continued) {\n\t        if (!line) {\n\t            return this.doneFunc();\n\t        }\n\t        column = 0;\n\t        while (pos < max) {\n\t            if (line.charAt(pos) === ' ') {\n\t                column += 1;\n\t            }\n\t            else if (line.charAt(pos) === '\\t') {\n\t                column = (column / tabsize + 1) * tabsize;\n\t            }\n\t            else if (line.charAt(pos) === '\\f') {\n\t                column = 0;\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t            pos = pos + 1;\n\t        }\n\t        if (pos === max) {\n\t            return this.doneFunc();\n\t        }\n\n\t        if (\"#\\r\\n\".indexOf(line.charAt(pos)) !== -1) // skip comments or blank lines\n\t        {\n\t            if (line.charAt(pos) === '#') {\n\t                comment_token = rstrip(line.substring(pos), '\\r\\n');\n\t                nl_pos = pos + comment_token.length;\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, comment_token,\n\t                    [this.lnum, pos], [this.lnum, pos + comment_token.length], line)) {\n\t                    return 'done';\n\t                }\n\t                //print(\"HERE:1\");\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(nl_pos),\n\t                    [this.lnum, nl_pos], [this.lnum, line.length], line)) {\n\t                    return 'done';\n\t                }\n\t                return false;\n\t            }\n\t            else {\n\t                //print(\"HERE:2\");\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(pos),\n\t                    [this.lnum, pos], [this.lnum, line.length], line)) {\n\t                    return 'done';\n\t                }\n\t                if (!this.interactive) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\n\t        if (column > this.indents[this.indents.length - 1]) // count indents or dedents\n\t        {\n\t            this.indents.push(column);\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_INDENT, line.substring(0, pos), [this.lnum, 0], [this.lnum, pos], line)) {\n\t                return 'done';\n\t            }\n\t        }\n\t        while (column < this.indents[this.indents.length - 1]) {\n\t            if (!contains(this.indents, column)) {\n\t                throw new Sk.builtin.IndentationError(\"unindent does not match any outer indentation level\",\n\t                    this.filename, this.lnum, pos, line);\n\t            }\n\t            this.indents.splice(this.indents.length - 1, 1);\n\t            //print(\"dedent here\");\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [this.lnum, pos], [this.lnum, pos], line)) {\n\t                return 'done';\n\t            }\n\t        }\n\t    }\n\t    else // continued statement\n\t    {\n\t        if (!line) {\n\t            throw new Sk.builtin.SyntaxError(\"EOF in multi-line statement\", this.filename, this.lnum, 0, {\n\t                kind: 'STATEMENT_EOF',\n\t                parenlev: this.parenlev,\n\t                parenstack: this.parenstack\n\t            });\n\t        }\n\t        this.continued = false;\n\t    }\n\n\t    while (pos < max) {\n\t        //print(\"pos:\"+pos+\":\"+max);\n\t        // js regexes don't return any info about matches, other than the\n\t        // content. we'd like to put a \\w+ before pseudomatch, but then we\n\t        // can't get any data\n\t        capos = line.charAt(pos);\n\t        while (capos === ' ' || capos === '\\f' || capos === '\\t') {\n\t            pos += 1;\n\t            capos = line.charAt(pos);\n\t        }\n\t        pseudoprog.lastIndex = 0;\n\t        pseudomatch = pseudoprog.exec(line.substring(pos));\n\t        if (pseudomatch) {\n\t            start = pos;\n\t            end = start + pseudomatch[1].length;\n\t            spos = [this.lnum, start];\n\t            epos = [this.lnum, end];\n\t            pos = end;\n\t            token = line.substring(start, end);\n\t            initial = line.charAt(start);\n\t            //Sk.debugout(\"token:\",token, \"initial:\",initial, start, end);\n\t            if (this.numchars.indexOf(initial) !== -1 || (initial === '.' && token !== '.')) {\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NUMBER, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t            else if (initial === '\\r' || initial === '\\n') {\n\t                newl = Sk.Tokenizer.Tokens.T_NEWLINE;\n\t                //print(\"HERE:3\");\n\t                if (this.parenlev > 0) {\n\t                    newl = Sk.Tokenizer.Tokens.T_NL;\n\t                }\n\t                if (this.callback(newl, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t            else if (initial === '#') {\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t            else if (triple_quoted.hasOwnProperty(token)) {\n\t                this.endprog = endprogs[token];\n\t                this.endprog.lastIndex = 0;\n\t                endmatch = this.endprog.test(line.substring(pos));\n\t                if (endmatch) {\n\t                    pos = this.endprog.lastIndex + pos;\n\t                    token = line.substring(start, pos);\n\t                    if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, [this.lnum, pos], line)) {\n\t                        return 'done';\n\t                    }\n\t                }\n\t                else {\n\t                    this.strstart = [this.lnum, start];\n\t                    this.contstr = line.substring(start);\n\t                    this.contline = line;\n\t                    return false;\n\t                }\n\t            }\n\t            else if (single_quoted.hasOwnProperty(initial) ||\n\t                single_quoted.hasOwnProperty(token.substring(0, 2)) ||\n\t                single_quoted.hasOwnProperty(token.substring(0, 3))) {\n\t                if (token[token.length - 1] === '\\n') {\n\t                    this.strstart = [this.lnum, start];\n\t                    this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];\n\t                    this.contstr = line.substring(start);\n\t                    this.needcont = true;\n\t                    this.contline = line;\n\t                    //print(\"i, t1, t2\", initial, token[1], token[2]);\n\t                    //print(\"ep, cs\", this.endprog, this.contstr);\n\t                    return false;\n\t                }\n\t                else {\n\t                    if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, epos, line)) {\n\t                        return 'done';\n\t                    }\n\t                }\n\t            }\n\t            else if (this.namechars.indexOf(initial) !== -1) {\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NAME, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t            else if (initial === '\\\\') {\n\t                //print(\"HERE:4\");\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NL, token, spos, [this.lnum, pos], line)) {\n\t                    return 'done';\n\t                }\n\t                this.continued = true;\n\t            }\n\t            else {\n\t                if ('([{'.indexOf(initial) !== -1) {\n\t                    this.parenlev += 1;\n\t                    this.parenstack.push([initial, this.lnum, pos]);\n\t                }\n\t                else if (')]}'.indexOf(initial) !== -1) {\n\t                    this.parenlev -= 1;\n\t                    this.parenstack.pop();\n\t                }\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_OP, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, line.charAt(pos),\n\t                [this.lnum, pos], [this.lnum, pos + 1], line)) {\n\t                return 'done';\n\t            }\n\t            pos += 1;\n\t        }\n\t    }\n\n\t    return false;\n\t};\n\n\tSk.Tokenizer.tokenNames = {\n\t    0  : 'T_ENDMARKER', 1: 'T_NAME', 2: 'T_NUMBER', 3: 'T_STRING', 4: 'T_NEWLINE',\n\t    5  : 'T_INDENT', 6: 'T_DEDENT', 7: 'T_LPAR', 8: 'T_RPAR', 9: 'T_LSQB',\n\t    10 : 'T_RSQB', 11: 'T_COLON', 12: 'T_COMMA', 13: 'T_SEMI', 14: 'T_PLUS',\n\t    15 : 'T_MINUS', 16: 'T_STAR', 17: 'T_SLASH', 18: 'T_VBAR', 19: 'T_AMPER',\n\t    20 : 'T_LESS', 21: 'T_GREATER', 22: 'T_EQUAL', 23: 'T_DOT', 24: 'T_PERCENT',\n\t    25 : 'T_BACKQUOTE', 26: 'T_LBRACE', 27: 'T_RBRACE', 28: 'T_EQEQUAL', 29: 'T_NOTEQUAL',\n\t    30 : 'T_LESSEQUAL', 31: 'T_GREATEREQUAL', 32: 'T_TILDE', 33: 'T_CIRCUMFLEX', 34: 'T_LEFTSHIFT',\n\t    35 : 'T_RIGHTSHIFT', 36: 'T_DOUBLESTAR', 37: 'T_PLUSEQUAL', 38: 'T_MINEQUAL', 39: 'T_STAREQUAL',\n\t    40 : 'T_SLASHEQUAL', 41: 'T_PERCENTEQUAL', 42: 'T_AMPEREQUAL', 43: 'T_VBAREQUAL', 44: 'T_CIRCUMFLEXEQUAL',\n\t    45 : 'T_LEFTSHIFTEQUAL', 46: 'T_RIGHTSHIFTEQUAL', 47: 'T_DOUBLESTAREQUAL', 48: 'T_DOUBLESLASH', 49: 'T_DOUBLESLASHEQUAL',\n\t    50 : 'T_AT', 51: 'T_OP', 52: 'T_COMMENT', 53: 'T_NL', 54: 'T_RARROW',\n\t    55 : 'T_ERRORTOKEN', 56: 'T_N_TOKENS',\n\t    256: 'T_NT_OFFSET'\n\t};\n\n\tgoog.exportSymbol(\"Sk.Tokenizer\", Sk.Tokenizer);\n\tgoog.exportSymbol(\"Sk.Tokenizer.prototype.generateTokens\", Sk.Tokenizer.prototype.generateTokens);\n\tgoog.exportSymbol(\"Sk.Tokenizer.tokenNames\", Sk.Tokenizer.tokenNames);\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/gen/parse_tables.js ---- */ \n\n\t// generated by pgen/main.py\n\tSk.OpMap = {\n\t\"(\": Sk.Tokenizer.Tokens.T_LPAR,\n\t\")\": Sk.Tokenizer.Tokens.T_RPAR,\n\t\"[\": Sk.Tokenizer.Tokens.T_LSQB,\n\t\"]\": Sk.Tokenizer.Tokens.T_RSQB,\n\t\":\": Sk.Tokenizer.Tokens.T_COLON,\n\t\",\": Sk.Tokenizer.Tokens.T_COMMA,\n\t\";\": Sk.Tokenizer.Tokens.T_SEMI,\n\t\"+\": Sk.Tokenizer.Tokens.T_PLUS,\n\t\"-\": Sk.Tokenizer.Tokens.T_MINUS,\n\t\"*\": Sk.Tokenizer.Tokens.T_STAR,\n\t\"/\": Sk.Tokenizer.Tokens.T_SLASH,\n\t\"|\": Sk.Tokenizer.Tokens.T_VBAR,\n\t\"&\": Sk.Tokenizer.Tokens.T_AMPER,\n\t\"<\": Sk.Tokenizer.Tokens.T_LESS,\n\t\">\": Sk.Tokenizer.Tokens.T_GREATER,\n\t\"=\": Sk.Tokenizer.Tokens.T_EQUAL,\n\t\".\": Sk.Tokenizer.Tokens.T_DOT,\n\t\"%\": Sk.Tokenizer.Tokens.T_PERCENT,\n\t\"`\": Sk.Tokenizer.Tokens.T_BACKQUOTE,\n\t\"{\": Sk.Tokenizer.Tokens.T_LBRACE,\n\t\"}\": Sk.Tokenizer.Tokens.T_RBRACE,\n\t\"@\": Sk.Tokenizer.Tokens.T_AT,\n\t\"==\": Sk.Tokenizer.Tokens.T_EQEQUAL,\n\t\"!=\": Sk.Tokenizer.Tokens.T_NOTEQUAL,\n\t\"<>\": Sk.Tokenizer.Tokens.T_NOTEQUAL,\n\t\"<=\": Sk.Tokenizer.Tokens.T_LESSEQUAL,\n\t\">=\": Sk.Tokenizer.Tokens.T_GREATEREQUAL,\n\t\"~\": Sk.Tokenizer.Tokens.T_TILDE,\n\t\"^\": Sk.Tokenizer.Tokens.T_CIRCUMFLEX,\n\t\"<<\": Sk.Tokenizer.Tokens.T_LEFTSHIFT,\n\t\">>\": Sk.Tokenizer.Tokens.T_RIGHTSHIFT,\n\t\"**\": Sk.Tokenizer.Tokens.T_DOUBLESTAR,\n\t\"+=\": Sk.Tokenizer.Tokens.T_PLUSEQUAL,\n\t\"-=\": Sk.Tokenizer.Tokens.T_MINEQUAL,\n\t\"*=\": Sk.Tokenizer.Tokens.T_STAREQUAL,\n\t\"/=\": Sk.Tokenizer.Tokens.T_SLASHEQUAL,\n\t\"%=\": Sk.Tokenizer.Tokens.T_PERCENTEQUAL,\n\t\"&=\": Sk.Tokenizer.Tokens.T_AMPEREQUAL,\n\t\"|=\": Sk.Tokenizer.Tokens.T_VBAREQUAL,\n\t\"^=\": Sk.Tokenizer.Tokens.T_CIRCUMFLEXEQUAL,\n\t\"<<=\": Sk.Tokenizer.Tokens.T_LEFTSHIFTEQUAL,\n\t\">>=\": Sk.Tokenizer.Tokens.T_RIGHTSHIFTEQUAL,\n\t\"**=\": Sk.Tokenizer.Tokens.T_DOUBLESTAREQUAL,\n\t\"//\": Sk.Tokenizer.Tokens.T_DOUBLESLASH,\n\t\"//=\": Sk.Tokenizer.Tokens.T_DOUBLESLASHEQUAL,\n\t\"->\": Sk.Tokenizer.Tokens.T_RARROW\n\t};\n\tSk.ParseTables = {\n\tsym:\n\t{and_expr: 257,\n\t and_test: 258,\n\t arglist: 259,\n\t argument: 260,\n\t arith_expr: 261,\n\t assert_stmt: 262,\n\t atom: 263,\n\t augassign: 264,\n\t break_stmt: 265,\n\t classdef: 266,\n\t comp_for: 267,\n\t comp_if: 268,\n\t comp_iter: 269,\n\t comp_op: 270,\n\t comparison: 271,\n\t compound_stmt: 272,\n\t continue_stmt: 273,\n\t debugger_stmt: 274,\n\t decorated: 275,\n\t decorator: 276,\n\t decorators: 277,\n\t del_stmt: 278,\n\t dictorsetmaker: 279,\n\t dotted_as_name: 280,\n\t dotted_as_names: 281,\n\t dotted_name: 282,\n\t encoding_decl: 283,\n\t eval_input: 284,\n\t except_clause: 285,\n\t exec_stmt: 286,\n\t expr: 287,\n\t expr_stmt: 288,\n\t exprlist: 289,\n\t factor: 290,\n\t file_input: 291,\n\t flow_stmt: 292,\n\t for_stmt: 293,\n\t fpdef: 294,\n\t fplist: 295,\n\t funcdef: 296,\n\t global_stmt: 297,\n\t if_stmt: 298,\n\t import_as_name: 299,\n\t import_as_names: 300,\n\t import_from: 301,\n\t import_name: 302,\n\t import_stmt: 303,\n\t lambdef: 304,\n\t list_for: 305,\n\t list_if: 306,\n\t list_iter: 307,\n\t listmaker: 308,\n\t not_test: 309,\n\t old_lambdef: 310,\n\t old_test: 311,\n\t or_test: 312,\n\t parameters: 313,\n\t pass_stmt: 314,\n\t power: 315,\n\t print_stmt: 316,\n\t raise_stmt: 317,\n\t return_stmt: 318,\n\t shift_expr: 319,\n\t simple_stmt: 320,\n\t single_input: 256,\n\t sliceop: 321,\n\t small_stmt: 322,\n\t stmt: 323,\n\t subscript: 324,\n\t subscriptlist: 325,\n\t suite: 326,\n\t term: 327,\n\t test: 328,\n\t testlist: 329,\n\t testlist1: 330,\n\t testlist_comp: 331,\n\t testlist_safe: 332,\n\t trailer: 333,\n\t try_stmt: 334,\n\t varargslist: 335,\n\t while_stmt: 336,\n\t with_item: 337,\n\t with_stmt: 338,\n\t xor_expr: 339,\n\t yield_expr: 340,\n\t yield_stmt: 341},\n\tnumber2symbol:\n\t{256: 'single_input',\n\t 257: 'and_expr',\n\t 258: 'and_test',\n\t 259: 'arglist',\n\t 260: 'argument',\n\t 261: 'arith_expr',\n\t 262: 'assert_stmt',\n\t 263: 'atom',\n\t 264: 'augassign',\n\t 265: 'break_stmt',\n\t 266: 'classdef',\n\t 267: 'comp_for',\n\t 268: 'comp_if',\n\t 269: 'comp_iter',\n\t 270: 'comp_op',\n\t 271: 'comparison',\n\t 272: 'compound_stmt',\n\t 273: 'continue_stmt',\n\t 274: 'debugger_stmt',\n\t 275: 'decorated',\n\t 276: 'decorator',\n\t 277: 'decorators',\n\t 278: 'del_stmt',\n\t 279: 'dictorsetmaker',\n\t 280: 'dotted_as_name',\n\t 281: 'dotted_as_names',\n\t 282: 'dotted_name',\n\t 283: 'encoding_decl',\n\t 284: 'eval_input',\n\t 285: 'except_clause',\n\t 286: 'exec_stmt',\n\t 287: 'expr',\n\t 288: 'expr_stmt',\n\t 289: 'exprlist',\n\t 290: 'factor',\n\t 291: 'file_input',\n\t 292: 'flow_stmt',\n\t 293: 'for_stmt',\n\t 294: 'fpdef',\n\t 295: 'fplist',\n\t 296: 'funcdef',\n\t 297: 'global_stmt',\n\t 298: 'if_stmt',\n\t 299: 'import_as_name',\n\t 300: 'import_as_names',\n\t 301: 'import_from',\n\t 302: 'import_name',\n\t 303: 'import_stmt',\n\t 304: 'lambdef',\n\t 305: 'list_for',\n\t 306: 'list_if',\n\t 307: 'list_iter',\n\t 308: 'listmaker',\n\t 309: 'not_test',\n\t 310: 'old_lambdef',\n\t 311: 'old_test',\n\t 312: 'or_test',\n\t 313: 'parameters',\n\t 314: 'pass_stmt',\n\t 315: 'power',\n\t 316: 'print_stmt',\n\t 317: 'raise_stmt',\n\t 318: 'return_stmt',\n\t 319: 'shift_expr',\n\t 320: 'simple_stmt',\n\t 321: 'sliceop',\n\t 322: 'small_stmt',\n\t 323: 'stmt',\n\t 324: 'subscript',\n\t 325: 'subscriptlist',\n\t 326: 'suite',\n\t 327: 'term',\n\t 328: 'test',\n\t 329: 'testlist',\n\t 330: 'testlist1',\n\t 331: 'testlist_comp',\n\t 332: 'testlist_safe',\n\t 333: 'trailer',\n\t 334: 'try_stmt',\n\t 335: 'varargslist',\n\t 336: 'while_stmt',\n\t 337: 'with_item',\n\t 338: 'with_stmt',\n\t 339: 'xor_expr',\n\t 340: 'yield_expr',\n\t 341: 'yield_stmt'},\n\tdfas:\n\t{256: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\n\t       {2: 1,\n\t        4: 1,\n\t        5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        10: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        16: 1,\n\t        17: 1,\n\t        18: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        29: 1,\n\t        30: 1,\n\t        31: 1,\n\t        32: 1,\n\t        33: 1,\n\t        34: 1,\n\t        35: 1,\n\t        36: 1,\n\t        37: 1}],\n\t 257: [[[[38, 1]], [[39, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 258: [[[[40, 1]], [[41, 0], [0, 1]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 259: [[[[42, 1], [43, 2], [44, 3]],\n\t        [[45, 4]],\n\t        [[46, 5], [0, 2]],\n\t        [[45, 6]],\n\t        [[46, 7], [0, 4]],\n\t        [[42, 1], [43, 2], [44, 3], [0, 5]],\n\t        [[0, 6]],\n\t        [[43, 4], [44, 3]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1,\n\t        42: 1,\n\t        44: 1}],\n\t 260: [[[[45, 1]], [[47, 2], [48, 3], [0, 1]], [[45, 3]], [[0, 3]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 261: [[[[49, 1]], [[26, 0], [37, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 262: [[[[21, 1]], [[45, 2]], [[46, 3], [0, 2]], [[45, 4]], [[0, 4]]],\n\t       {21: 1}],\n\t 263: [[[[19, 1], [8, 2], [9, 5], [30, 4], [14, 3], [15, 6], [22, 2]],\n\t        [[19, 1], [0, 1]],\n\t        [[0, 2]],\n\t        [[50, 7], [51, 2]],\n\t        [[52, 2], [53, 8], [54, 8]],\n\t        [[55, 2], [56, 9]],\n\t        [[57, 10]],\n\t        [[51, 2]],\n\t        [[52, 2]],\n\t        [[55, 2]],\n\t        [[15, 2]]],\n\t       {8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 30: 1}],\n\t 264: [[[[58, 1],\n\t         [59, 1],\n\t         [60, 1],\n\t         [61, 1],\n\t         [62, 1],\n\t         [63, 1],\n\t         [64, 1],\n\t         [65, 1],\n\t         [66, 1],\n\t         [67, 1],\n\t         [68, 1],\n\t         [69, 1]],\n\t        [[0, 1]]],\n\t       {58: 1,\n\t        59: 1,\n\t        60: 1,\n\t        61: 1,\n\t        62: 1,\n\t        63: 1,\n\t        64: 1,\n\t        65: 1,\n\t        66: 1,\n\t        67: 1,\n\t        68: 1,\n\t        69: 1}],\n\t 265: [[[[33, 1]], [[0, 1]]], {33: 1}],\n\t 266: [[[[10, 1]],\n\t        [[22, 2]],\n\t        [[70, 3], [30, 4]],\n\t        [[71, 5]],\n\t        [[52, 6], [72, 7]],\n\t        [[0, 5]],\n\t        [[70, 3]],\n\t        [[52, 6]]],\n\t       {10: 1}],\n\t 267: [[[[29, 1]],\n\t        [[73, 2]],\n\t        [[74, 3]],\n\t        [[75, 4]],\n\t        [[76, 5], [0, 4]],\n\t        [[0, 5]]],\n\t       {29: 1}],\n\t 268: [[[[32, 1]], [[77, 2]], [[76, 3], [0, 2]], [[0, 3]]], {32: 1}],\n\t 269: [[[[78, 1], [48, 1]], [[0, 1]]], {29: 1, 32: 1}],\n\t 270: [[[[79, 1],\n\t         [80, 1],\n\t         [7, 2],\n\t         [81, 1],\n\t         [79, 1],\n\t         [74, 1],\n\t         [82, 1],\n\t         [83, 3],\n\t         [84, 1],\n\t         [85, 1]],\n\t        [[0, 1]],\n\t        [[74, 1]],\n\t        [[7, 1], [0, 3]]],\n\t       {7: 1, 74: 1, 79: 1, 80: 1, 81: 1, 82: 1, 83: 1, 84: 1, 85: 1}],\n\t 271: [[[[86, 1]], [[87, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 272: [[[[88, 1],\n\t         [89, 1],\n\t         [90, 1],\n\t         [91, 1],\n\t         [92, 1],\n\t         [93, 1],\n\t         [94, 1],\n\t         [95, 1]],\n\t        [[0, 1]]],\n\t       {4: 1, 10: 1, 16: 1, 18: 1, 29: 1, 32: 1, 35: 1, 36: 1}],\n\t 273: [[[[34, 1]], [[0, 1]]], {34: 1}],\n\t 274: [[[[13, 1]], [[0, 1]]], {13: 1}],\n\t 275: [[[[96, 1]], [[94, 2], [91, 2]], [[0, 2]]], {35: 1}],\n\t 276: [[[[35, 1]],\n\t        [[97, 2]],\n\t        [[2, 4], [30, 3]],\n\t        [[52, 5], [98, 6]],\n\t        [[0, 4]],\n\t        [[2, 4]],\n\t        [[52, 5]]],\n\t       {35: 1}],\n\t 277: [[[[99, 1]], [[99, 1], [0, 1]]], {35: 1}],\n\t 278: [[[[23, 1]], [[73, 2]], [[0, 2]]], {23: 1}],\n\t 279: [[[[45, 1]],\n\t        [[70, 2], [48, 3], [46, 4], [0, 1]],\n\t        [[45, 5]],\n\t        [[0, 3]],\n\t        [[45, 6], [0, 4]],\n\t        [[48, 3], [46, 7], [0, 5]],\n\t        [[46, 4], [0, 6]],\n\t        [[45, 8], [0, 7]],\n\t        [[70, 9]],\n\t        [[45, 10]],\n\t        [[46, 7], [0, 10]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 280: [[[[97, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], {22: 1}],\n\t 281: [[[[101, 1]], [[46, 0], [0, 1]]], {22: 1}],\n\t 282: [[[[22, 1]], [[102, 0], [0, 1]]], {22: 1}],\n\t 283: [[[[22, 1]], [[0, 1]]], {22: 1}],\n\t 284: [[[[72, 1]], [[2, 1], [103, 2]], [[0, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 285: [[[[104, 1]],\n\t        [[45, 2], [0, 1]],\n\t        [[100, 3], [46, 3], [0, 2]],\n\t        [[45, 4]],\n\t        [[0, 4]]],\n\t       {104: 1}],\n\t 286: [[[[17, 1]],\n\t        [[86, 2]],\n\t        [[74, 3], [0, 2]],\n\t        [[45, 4]],\n\t        [[46, 5], [0, 4]],\n\t        [[45, 6]],\n\t        [[0, 6]]],\n\t       {17: 1}],\n\t 287: [[[[105, 1]], [[106, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 288: [[[[72, 1]],\n\t        [[107, 2], [47, 3], [0, 1]],\n\t        [[72, 4], [53, 4]],\n\t        [[72, 5], [53, 5]],\n\t        [[0, 4]],\n\t        [[47, 3], [0, 5]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 289: [[[[86, 1]], [[46, 2], [0, 1]], [[86, 1], [0, 2]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 290: [[[[37, 2], [26, 2], [6, 2], [108, 1]], [[0, 1]], [[109, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 291: [[[[2, 0], [103, 1], [110, 0]], [[0, 1]]],\n\t       {2: 1,\n\t        4: 1,\n\t        5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        10: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        16: 1,\n\t        17: 1,\n\t        18: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        29: 1,\n\t        30: 1,\n\t        31: 1,\n\t        32: 1,\n\t        33: 1,\n\t        34: 1,\n\t        35: 1,\n\t        36: 1,\n\t        37: 1,\n\t        103: 1}],\n\t 292: [[[[111, 1], [112, 1], [113, 1], [114, 1], [115, 1]], [[0, 1]]],\n\t       {5: 1, 20: 1, 27: 1, 33: 1, 34: 1}],\n\t 293: [[[[29, 1]],\n\t        [[73, 2]],\n\t        [[74, 3]],\n\t        [[72, 4]],\n\t        [[70, 5]],\n\t        [[71, 6]],\n\t        [[116, 7], [0, 6]],\n\t        [[70, 8]],\n\t        [[71, 9]],\n\t        [[0, 9]]],\n\t       {29: 1}],\n\t 294: [[[[30, 1], [22, 2]], [[117, 3]], [[0, 2]], [[52, 2]]], {22: 1, 30: 1}],\n\t 295: [[[[118, 1]], [[46, 2], [0, 1]], [[118, 1], [0, 2]]], {22: 1, 30: 1}],\n\t 296: [[[[4, 1]], [[22, 2]], [[119, 3]], [[70, 4]], [[71, 5]], [[0, 5]]],\n\t       {4: 1}],\n\t 297: [[[[28, 1]], [[22, 2]], [[46, 1], [0, 2]]], {28: 1}],\n\t 298: [[[[32, 1]],\n\t        [[45, 2]],\n\t        [[70, 3]],\n\t        [[71, 4]],\n\t        [[116, 5], [120, 1], [0, 4]],\n\t        [[70, 6]],\n\t        [[71, 7]],\n\t        [[0, 7]]],\n\t       {32: 1}],\n\t 299: [[[[22, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], {22: 1}],\n\t 300: [[[[121, 1]], [[46, 2], [0, 1]], [[121, 1], [0, 2]]], {22: 1}],\n\t 301: [[[[31, 1]],\n\t        [[97, 2], [102, 3]],\n\t        [[25, 4]],\n\t        [[97, 2], [25, 4], [102, 3]],\n\t        [[122, 5], [42, 5], [30, 6]],\n\t        [[0, 5]],\n\t        [[122, 7]],\n\t        [[52, 5]]],\n\t       {31: 1}],\n\t 302: [[[[25, 1]], [[123, 2]], [[0, 2]]], {25: 1}],\n\t 303: [[[[124, 1], [125, 1]], [[0, 1]]], {25: 1, 31: 1}],\n\t 304: [[[[11, 1]], [[70, 2], [126, 3]], [[45, 4]], [[70, 2]], [[0, 4]]],\n\t       {11: 1}],\n\t 305: [[[[29, 1]],\n\t        [[73, 2]],\n\t        [[74, 3]],\n\t        [[127, 4]],\n\t        [[128, 5], [0, 4]],\n\t        [[0, 5]]],\n\t       {29: 1}],\n\t 306: [[[[32, 1]], [[77, 2]], [[128, 3], [0, 2]], [[0, 3]]], {32: 1}],\n\t 307: [[[[129, 1], [130, 1]], [[0, 1]]], {29: 1, 32: 1}],\n\t 308: [[[[45, 1]],\n\t        [[129, 2], [46, 3], [0, 1]],\n\t        [[0, 2]],\n\t        [[45, 4], [0, 3]],\n\t        [[46, 3], [0, 4]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 309: [[[[7, 1], [131, 2]], [[40, 2]], [[0, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 310: [[[[11, 1]], [[70, 2], [126, 3]], [[77, 4]], [[70, 2]], [[0, 4]]],\n\t       {11: 1}],\n\t 311: [[[[132, 1], [75, 1]], [[0, 1]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 312: [[[[133, 1]], [[134, 0], [0, 1]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 313: [[[[30, 1]], [[52, 2], [126, 3]], [[0, 2]], [[52, 2]]], {30: 1}],\n\t 314: [[[[24, 1]], [[0, 1]]], {24: 1}],\n\t 315: [[[[135, 1]], [[44, 2], [136, 1], [0, 1]], [[109, 3]], [[0, 3]]],\n\t       {8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 30: 1}],\n\t 316: [[[[12, 1]],\n\t        [[45, 2], [137, 3], [0, 1]],\n\t        [[46, 4], [0, 2]],\n\t        [[45, 5]],\n\t        [[45, 2], [0, 4]],\n\t        [[46, 6], [0, 5]],\n\t        [[45, 7]],\n\t        [[46, 8], [0, 7]],\n\t        [[45, 7], [0, 8]]],\n\t       {12: 1}],\n\t 317: [[[[5, 1]],\n\t        [[45, 2], [0, 1]],\n\t        [[46, 3], [0, 2]],\n\t        [[45, 4]],\n\t        [[46, 5], [0, 4]],\n\t        [[45, 6]],\n\t        [[0, 6]]],\n\t       {5: 1}],\n\t 318: [[[[20, 1]], [[72, 2], [0, 1]], [[0, 2]]], {20: 1}],\n\t 319: [[[[138, 1]], [[139, 0], [137, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 320: [[[[140, 1]], [[2, 2], [141, 3]], [[0, 2]], [[140, 1], [2, 2]]],\n\t       {5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        17: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        30: 1,\n\t        31: 1,\n\t        33: 1,\n\t        34: 1,\n\t        37: 1}],\n\t 321: [[[[70, 1]], [[45, 2], [0, 1]], [[0, 2]]], {70: 1}],\n\t 322: [[[[142, 1],\n\t         [143, 1],\n\t         [144, 1],\n\t         [145, 1],\n\t         [146, 1],\n\t         [147, 1],\n\t         [148, 1],\n\t         [149, 1],\n\t         [150, 1],\n\t         [151, 1]],\n\t        [[0, 1]]],\n\t       {5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        17: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        30: 1,\n\t        31: 1,\n\t        33: 1,\n\t        34: 1,\n\t        37: 1}],\n\t 323: [[[[1, 1], [3, 1]], [[0, 1]]],\n\t       {4: 1,\n\t        5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        10: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        16: 1,\n\t        17: 1,\n\t        18: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        29: 1,\n\t        30: 1,\n\t        31: 1,\n\t        32: 1,\n\t        33: 1,\n\t        34: 1,\n\t        35: 1,\n\t        36: 1,\n\t        37: 1}],\n\t 324: [[[[45, 1], [70, 2], [102, 3]],\n\t        [[70, 2], [0, 1]],\n\t        [[45, 4], [152, 5], [0, 2]],\n\t        [[102, 6]],\n\t        [[152, 5], [0, 4]],\n\t        [[0, 5]],\n\t        [[102, 5]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1,\n\t        70: 1,\n\t        102: 1}],\n\t 325: [[[[153, 1]], [[46, 2], [0, 1]], [[153, 1], [0, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1,\n\t        70: 1,\n\t        102: 1}],\n\t 326: [[[[1, 1], [2, 2]],\n\t        [[0, 1]],\n\t        [[154, 3]],\n\t        [[110, 4]],\n\t        [[155, 1], [110, 4]]],\n\t       {2: 1,\n\t        5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        17: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        30: 1,\n\t        31: 1,\n\t        33: 1,\n\t        34: 1,\n\t        37: 1}],\n\t 327: [[[[109, 1]], [[156, 0], [42, 0], [157, 0], [158, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 328: [[[[75, 1], [159, 2]],\n\t        [[32, 3], [0, 1]],\n\t        [[0, 2]],\n\t        [[75, 4]],\n\t        [[116, 5]],\n\t        [[45, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 329: [[[[45, 1]], [[46, 2], [0, 1]], [[45, 1], [0, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 330: [[[[45, 1]], [[46, 0], [0, 1]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 331: [[[[45, 1]],\n\t        [[48, 2], [46, 3], [0, 1]],\n\t        [[0, 2]],\n\t        [[45, 4], [0, 3]],\n\t        [[46, 3], [0, 4]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 332: [[[[77, 1]],\n\t        [[46, 2], [0, 1]],\n\t        [[77, 3]],\n\t        [[46, 4], [0, 3]],\n\t        [[77, 3], [0, 4]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 333: [[[[30, 1], [102, 2], [14, 3]],\n\t        [[52, 4], [98, 5]],\n\t        [[22, 4]],\n\t        [[160, 6]],\n\t        [[0, 4]],\n\t        [[52, 4]],\n\t        [[51, 4]]],\n\t       {14: 1, 30: 1, 102: 1}],\n\t 334: [[[[16, 1]],\n\t        [[70, 2]],\n\t        [[71, 3]],\n\t        [[161, 4], [162, 5]],\n\t        [[70, 6]],\n\t        [[70, 7]],\n\t        [[71, 8]],\n\t        [[71, 9]],\n\t        [[161, 4], [116, 10], [162, 5], [0, 8]],\n\t        [[0, 9]],\n\t        [[70, 11]],\n\t        [[71, 12]],\n\t        [[162, 5], [0, 12]]],\n\t       {16: 1}],\n\t 335: [[[[42, 1], [118, 2], [44, 3]],\n\t        [[22, 4]],\n\t        [[47, 5], [46, 6], [0, 2]],\n\t        [[22, 7]],\n\t        [[46, 8], [0, 4]],\n\t        [[45, 9]],\n\t        [[42, 1], [118, 2], [44, 3], [0, 6]],\n\t        [[0, 7]],\n\t        [[44, 3]],\n\t        [[46, 6], [0, 9]]],\n\t       {22: 1, 30: 1, 42: 1, 44: 1}],\n\t 336: [[[[18, 1]],\n\t        [[45, 2]],\n\t        [[70, 3]],\n\t        [[71, 4]],\n\t        [[116, 5], [0, 4]],\n\t        [[70, 6]],\n\t        [[71, 7]],\n\t        [[0, 7]]],\n\t       {18: 1}],\n\t 337: [[[[45, 1]], [[100, 2], [0, 1]], [[86, 3]], [[0, 3]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 338: [[[[36, 1]], [[163, 2]], [[70, 3], [46, 1]], [[71, 4]], [[0, 4]]],\n\t       {36: 1}],\n\t 339: [[[[164, 1]], [[165, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 340: [[[[27, 1]], [[72, 2], [0, 1]], [[0, 2]]], {27: 1}],\n\t 341: [[[[53, 1]], [[0, 1]]], {27: 1}]},\n\tstates:\n\t[[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\n\t [[[38, 1]], [[39, 0], [0, 1]]],\n\t [[[40, 1]], [[41, 0], [0, 1]]],\n\t [[[42, 1], [43, 2], [44, 3]],\n\t  [[45, 4]],\n\t  [[46, 5], [0, 2]],\n\t  [[45, 6]],\n\t  [[46, 7], [0, 4]],\n\t  [[42, 1], [43, 2], [44, 3], [0, 5]],\n\t  [[0, 6]],\n\t  [[43, 4], [44, 3]]],\n\t [[[45, 1]], [[47, 2], [48, 3], [0, 1]], [[45, 3]], [[0, 3]]],\n\t [[[49, 1]], [[26, 0], [37, 0], [0, 1]]],\n\t [[[21, 1]], [[45, 2]], [[46, 3], [0, 2]], [[45, 4]], [[0, 4]]],\n\t [[[19, 1], [8, 2], [9, 5], [30, 4], [14, 3], [15, 6], [22, 2]],\n\t  [[19, 1], [0, 1]],\n\t  [[0, 2]],\n\t  [[50, 7], [51, 2]],\n\t  [[52, 2], [53, 8], [54, 8]],\n\t  [[55, 2], [56, 9]],\n\t  [[57, 10]],\n\t  [[51, 2]],\n\t  [[52, 2]],\n\t  [[55, 2]],\n\t  [[15, 2]]],\n\t [[[58, 1],\n\t   [59, 1],\n\t   [60, 1],\n\t   [61, 1],\n\t   [62, 1],\n\t   [63, 1],\n\t   [64, 1],\n\t   [65, 1],\n\t   [66, 1],\n\t   [67, 1],\n\t   [68, 1],\n\t   [69, 1]],\n\t  [[0, 1]]],\n\t [[[33, 1]], [[0, 1]]],\n\t [[[10, 1]],\n\t  [[22, 2]],\n\t  [[70, 3], [30, 4]],\n\t  [[71, 5]],\n\t  [[52, 6], [72, 7]],\n\t  [[0, 5]],\n\t  [[70, 3]],\n\t  [[52, 6]]],\n\t [[[29, 1]], [[73, 2]], [[74, 3]], [[75, 4]], [[76, 5], [0, 4]], [[0, 5]]],\n\t [[[32, 1]], [[77, 2]], [[76, 3], [0, 2]], [[0, 3]]],\n\t [[[78, 1], [48, 1]], [[0, 1]]],\n\t [[[79, 1],\n\t   [80, 1],\n\t   [7, 2],\n\t   [81, 1],\n\t   [79, 1],\n\t   [74, 1],\n\t   [82, 1],\n\t   [83, 3],\n\t   [84, 1],\n\t   [85, 1]],\n\t  [[0, 1]],\n\t  [[74, 1]],\n\t  [[7, 1], [0, 3]]],\n\t [[[86, 1]], [[87, 0], [0, 1]]],\n\t [[[88, 1], [89, 1], [90, 1], [91, 1], [92, 1], [93, 1], [94, 1], [95, 1]],\n\t  [[0, 1]]],\n\t [[[34, 1]], [[0, 1]]],\n\t [[[13, 1]], [[0, 1]]],\n\t [[[96, 1]], [[94, 2], [91, 2]], [[0, 2]]],\n\t [[[35, 1]],\n\t  [[97, 2]],\n\t  [[2, 4], [30, 3]],\n\t  [[52, 5], [98, 6]],\n\t  [[0, 4]],\n\t  [[2, 4]],\n\t  [[52, 5]]],\n\t [[[99, 1]], [[99, 1], [0, 1]]],\n\t [[[23, 1]], [[73, 2]], [[0, 2]]],\n\t [[[45, 1]],\n\t  [[70, 2], [48, 3], [46, 4], [0, 1]],\n\t  [[45, 5]],\n\t  [[0, 3]],\n\t  [[45, 6], [0, 4]],\n\t  [[48, 3], [46, 7], [0, 5]],\n\t  [[46, 4], [0, 6]],\n\t  [[45, 8], [0, 7]],\n\t  [[70, 9]],\n\t  [[45, 10]],\n\t  [[46, 7], [0, 10]]],\n\t [[[97, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]],\n\t [[[101, 1]], [[46, 0], [0, 1]]],\n\t [[[22, 1]], [[102, 0], [0, 1]]],\n\t [[[22, 1]], [[0, 1]]],\n\t [[[72, 1]], [[2, 1], [103, 2]], [[0, 2]]],\n\t [[[104, 1]],\n\t  [[45, 2], [0, 1]],\n\t  [[100, 3], [46, 3], [0, 2]],\n\t  [[45, 4]],\n\t  [[0, 4]]],\n\t [[[17, 1]],\n\t  [[86, 2]],\n\t  [[74, 3], [0, 2]],\n\t  [[45, 4]],\n\t  [[46, 5], [0, 4]],\n\t  [[45, 6]],\n\t  [[0, 6]]],\n\t [[[105, 1]], [[106, 0], [0, 1]]],\n\t [[[72, 1]],\n\t  [[107, 2], [47, 3], [0, 1]],\n\t  [[72, 4], [53, 4]],\n\t  [[72, 5], [53, 5]],\n\t  [[0, 4]],\n\t  [[47, 3], [0, 5]]],\n\t [[[86, 1]], [[46, 2], [0, 1]], [[86, 1], [0, 2]]],\n\t [[[37, 2], [26, 2], [6, 2], [108, 1]], [[0, 1]], [[109, 1]]],\n\t [[[2, 0], [103, 1], [110, 0]], [[0, 1]]],\n\t [[[111, 1], [112, 1], [113, 1], [114, 1], [115, 1]], [[0, 1]]],\n\t [[[29, 1]],\n\t  [[73, 2]],\n\t  [[74, 3]],\n\t  [[72, 4]],\n\t  [[70, 5]],\n\t  [[71, 6]],\n\t  [[116, 7], [0, 6]],\n\t  [[70, 8]],\n\t  [[71, 9]],\n\t  [[0, 9]]],\n\t [[[30, 1], [22, 2]], [[117, 3]], [[0, 2]], [[52, 2]]],\n\t [[[118, 1]], [[46, 2], [0, 1]], [[118, 1], [0, 2]]],\n\t [[[4, 1]], [[22, 2]], [[119, 3]], [[70, 4]], [[71, 5]], [[0, 5]]],\n\t [[[28, 1]], [[22, 2]], [[46, 1], [0, 2]]],\n\t [[[32, 1]],\n\t  [[45, 2]],\n\t  [[70, 3]],\n\t  [[71, 4]],\n\t  [[116, 5], [120, 1], [0, 4]],\n\t  [[70, 6]],\n\t  [[71, 7]],\n\t  [[0, 7]]],\n\t [[[22, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]],\n\t [[[121, 1]], [[46, 2], [0, 1]], [[121, 1], [0, 2]]],\n\t [[[31, 1]],\n\t  [[97, 2], [102, 3]],\n\t  [[25, 4]],\n\t  [[97, 2], [25, 4], [102, 3]],\n\t  [[122, 5], [42, 5], [30, 6]],\n\t  [[0, 5]],\n\t  [[122, 7]],\n\t  [[52, 5]]],\n\t [[[25, 1]], [[123, 2]], [[0, 2]]],\n\t [[[124, 1], [125, 1]], [[0, 1]]],\n\t [[[11, 1]], [[70, 2], [126, 3]], [[45, 4]], [[70, 2]], [[0, 4]]],\n\t [[[29, 1]], [[73, 2]], [[74, 3]], [[127, 4]], [[128, 5], [0, 4]], [[0, 5]]],\n\t [[[32, 1]], [[77, 2]], [[128, 3], [0, 2]], [[0, 3]]],\n\t [[[129, 1], [130, 1]], [[0, 1]]],\n\t [[[45, 1]],\n\t  [[129, 2], [46, 3], [0, 1]],\n\t  [[0, 2]],\n\t  [[45, 4], [0, 3]],\n\t  [[46, 3], [0, 4]]],\n\t [[[7, 1], [131, 2]], [[40, 2]], [[0, 2]]],\n\t [[[11, 1]], [[70, 2], [126, 3]], [[77, 4]], [[70, 2]], [[0, 4]]],\n\t [[[132, 1], [75, 1]], [[0, 1]]],\n\t [[[133, 1]], [[134, 0], [0, 1]]],\n\t [[[30, 1]], [[52, 2], [126, 3]], [[0, 2]], [[52, 2]]],\n\t [[[24, 1]], [[0, 1]]],\n\t [[[135, 1]], [[44, 2], [136, 1], [0, 1]], [[109, 3]], [[0, 3]]],\n\t [[[12, 1]],\n\t  [[45, 2], [137, 3], [0, 1]],\n\t  [[46, 4], [0, 2]],\n\t  [[45, 5]],\n\t  [[45, 2], [0, 4]],\n\t  [[46, 6], [0, 5]],\n\t  [[45, 7]],\n\t  [[46, 8], [0, 7]],\n\t  [[45, 7], [0, 8]]],\n\t [[[5, 1]],\n\t  [[45, 2], [0, 1]],\n\t  [[46, 3], [0, 2]],\n\t  [[45, 4]],\n\t  [[46, 5], [0, 4]],\n\t  [[45, 6]],\n\t  [[0, 6]]],\n\t [[[20, 1]], [[72, 2], [0, 1]], [[0, 2]]],\n\t [[[138, 1]], [[139, 0], [137, 0], [0, 1]]],\n\t [[[140, 1]], [[2, 2], [141, 3]], [[0, 2]], [[140, 1], [2, 2]]],\n\t [[[70, 1]], [[45, 2], [0, 1]], [[0, 2]]],\n\t [[[142, 1],\n\t   [143, 1],\n\t   [144, 1],\n\t   [145, 1],\n\t   [146, 1],\n\t   [147, 1],\n\t   [148, 1],\n\t   [149, 1],\n\t   [150, 1],\n\t   [151, 1]],\n\t  [[0, 1]]],\n\t [[[1, 1], [3, 1]], [[0, 1]]],\n\t [[[45, 1], [70, 2], [102, 3]],\n\t  [[70, 2], [0, 1]],\n\t  [[45, 4], [152, 5], [0, 2]],\n\t  [[102, 6]],\n\t  [[152, 5], [0, 4]],\n\t  [[0, 5]],\n\t  [[102, 5]]],\n\t [[[153, 1]], [[46, 2], [0, 1]], [[153, 1], [0, 2]]],\n\t [[[1, 1], [2, 2]], [[0, 1]], [[154, 3]], [[110, 4]], [[155, 1], [110, 4]]],\n\t [[[109, 1]], [[156, 0], [42, 0], [157, 0], [158, 0], [0, 1]]],\n\t [[[75, 1], [159, 2]],\n\t  [[32, 3], [0, 1]],\n\t  [[0, 2]],\n\t  [[75, 4]],\n\t  [[116, 5]],\n\t  [[45, 2]]],\n\t [[[45, 1]], [[46, 2], [0, 1]], [[45, 1], [0, 2]]],\n\t [[[45, 1]], [[46, 0], [0, 1]]],\n\t [[[45, 1]],\n\t  [[48, 2], [46, 3], [0, 1]],\n\t  [[0, 2]],\n\t  [[45, 4], [0, 3]],\n\t  [[46, 3], [0, 4]]],\n\t [[[77, 1]],\n\t  [[46, 2], [0, 1]],\n\t  [[77, 3]],\n\t  [[46, 4], [0, 3]],\n\t  [[77, 3], [0, 4]]],\n\t [[[30, 1], [102, 2], [14, 3]],\n\t  [[52, 4], [98, 5]],\n\t  [[22, 4]],\n\t  [[160, 6]],\n\t  [[0, 4]],\n\t  [[52, 4]],\n\t  [[51, 4]]],\n\t [[[16, 1]],\n\t  [[70, 2]],\n\t  [[71, 3]],\n\t  [[161, 4], [162, 5]],\n\t  [[70, 6]],\n\t  [[70, 7]],\n\t  [[71, 8]],\n\t  [[71, 9]],\n\t  [[161, 4], [116, 10], [162, 5], [0, 8]],\n\t  [[0, 9]],\n\t  [[70, 11]],\n\t  [[71, 12]],\n\t  [[162, 5], [0, 12]]],\n\t [[[42, 1], [118, 2], [44, 3]],\n\t  [[22, 4]],\n\t  [[47, 5], [46, 6], [0, 2]],\n\t  [[22, 7]],\n\t  [[46, 8], [0, 4]],\n\t  [[45, 9]],\n\t  [[42, 1], [118, 2], [44, 3], [0, 6]],\n\t  [[0, 7]],\n\t  [[44, 3]],\n\t  [[46, 6], [0, 9]]],\n\t [[[18, 1]],\n\t  [[45, 2]],\n\t  [[70, 3]],\n\t  [[71, 4]],\n\t  [[116, 5], [0, 4]],\n\t  [[70, 6]],\n\t  [[71, 7]],\n\t  [[0, 7]]],\n\t [[[45, 1]], [[100, 2], [0, 1]], [[86, 3]], [[0, 3]]],\n\t [[[36, 1]], [[163, 2]], [[70, 3], [46, 1]], [[71, 4]], [[0, 4]]],\n\t [[[164, 1]], [[165, 0], [0, 1]]],\n\t [[[27, 1]], [[72, 2], [0, 1]], [[0, 2]]],\n\t [[[53, 1]], [[0, 1]]]],\n\tlabels:\n\t[[0, 'EMPTY'],\n\t [320, null],\n\t [4, null],\n\t [272, null],\n\t [1, 'def'],\n\t [1, 'raise'],\n\t [32, null],\n\t [1, 'not'],\n\t [2, null],\n\t [26, null],\n\t [1, 'class'],\n\t [1, 'lambda'],\n\t [1, 'print'],\n\t [1, 'debugger'],\n\t [9, null],\n\t [25, null],\n\t [1, 'try'],\n\t [1, 'exec'],\n\t [1, 'while'],\n\t [3, null],\n\t [1, 'return'],\n\t [1, 'assert'],\n\t [1, null],\n\t [1, 'del'],\n\t [1, 'pass'],\n\t [1, 'import'],\n\t [15, null],\n\t [1, 'yield'],\n\t [1, 'global'],\n\t [1, 'for'],\n\t [7, null],\n\t [1, 'from'],\n\t [1, 'if'],\n\t [1, 'break'],\n\t [1, 'continue'],\n\t [50, null],\n\t [1, 'with'],\n\t [14, null],\n\t [319, null],\n\t [19, null],\n\t [309, null],\n\t [1, 'and'],\n\t [16, null],\n\t [260, null],\n\t [36, null],\n\t [328, null],\n\t [12, null],\n\t [22, null],\n\t [267, null],\n\t [327, null],\n\t [308, null],\n\t [10, null],\n\t [8, null],\n\t [340, null],\n\t [331, null],\n\t [27, null],\n\t [279, null],\n\t [330, null],\n\t [46, null],\n\t [39, null],\n\t [41, null],\n\t [47, null],\n\t [42, null],\n\t [43, null],\n\t [37, null],\n\t [44, null],\n\t [49, null],\n\t [45, null],\n\t [38, null],\n\t [40, null],\n\t [11, null],\n\t [326, null],\n\t [329, null],\n\t [289, null],\n\t [1, 'in'],\n\t [312, null],\n\t [269, null],\n\t [311, null],\n\t [268, null],\n\t [29, null],\n\t [21, null],\n\t [28, null],\n\t [30, null],\n\t [1, 'is'],\n\t [31, null],\n\t [20, null],\n\t [287, null],\n\t [270, null],\n\t [334, null],\n\t [298, null],\n\t [293, null],\n\t [266, null],\n\t [338, null],\n\t [336, null],\n\t [296, null],\n\t [275, null],\n\t [277, null],\n\t [282, null],\n\t [259, null],\n\t [276, null],\n\t [1, 'as'],\n\t [280, null],\n\t [23, null],\n\t [0, null],\n\t [1, 'except'],\n\t [339, null],\n\t [18, null],\n\t [264, null],\n\t [315, null],\n\t [290, null],\n\t [323, null],\n\t [265, null],\n\t [273, null],\n\t [317, null],\n\t [318, null],\n\t [341, null],\n\t [1, 'else'],\n\t [295, null],\n\t [294, null],\n\t [313, null],\n\t [1, 'elif'],\n\t [299, null],\n\t [300, null],\n\t [281, null],\n\t [302, null],\n\t [301, null],\n\t [335, null],\n\t [332, null],\n\t [307, null],\n\t [305, null],\n\t [306, null],\n\t [271, null],\n\t [310, null],\n\t [258, null],\n\t [1, 'or'],\n\t [263, null],\n\t [333, null],\n\t [35, null],\n\t [261, null],\n\t [34, null],\n\t [322, null],\n\t [13, null],\n\t [292, null],\n\t [278, null],\n\t [288, null],\n\t [314, null],\n\t [316, null],\n\t [262, null],\n\t [286, null],\n\t [297, null],\n\t [303, null],\n\t [274, null],\n\t [321, null],\n\t [324, null],\n\t [5, null],\n\t [6, null],\n\t [48, null],\n\t [17, null],\n\t [24, null],\n\t [304, null],\n\t [325, null],\n\t [285, null],\n\t [1, 'finally'],\n\t [337, null],\n\t [257, null],\n\t [33, null]],\n\tkeywords:\n\t{'and': 41,\n\t 'as': 100,\n\t 'assert': 21,\n\t 'break': 33,\n\t 'class': 10,\n\t 'continue': 34,\n\t 'debugger': 13,\n\t 'def': 4,\n\t 'del': 23,\n\t 'elif': 120,\n\t 'else': 116,\n\t 'except': 104,\n\t 'exec': 17,\n\t 'finally': 162,\n\t 'for': 29,\n\t 'from': 31,\n\t 'global': 28,\n\t 'if': 32,\n\t 'import': 25,\n\t 'in': 74,\n\t 'is': 83,\n\t 'lambda': 11,\n\t 'not': 7,\n\t 'or': 134,\n\t 'pass': 24,\n\t 'print': 12,\n\t 'raise': 5,\n\t 'return': 20,\n\t 'try': 16,\n\t 'while': 18,\n\t 'with': 36,\n\t 'yield': 27},\n\ttokens:\n\t{0: 103,\n\t 1: 22,\n\t 2: 8,\n\t 3: 19,\n\t 4: 2,\n\t 5: 154,\n\t 6: 155,\n\t 7: 30,\n\t 8: 52,\n\t 9: 14,\n\t 10: 51,\n\t 11: 70,\n\t 12: 46,\n\t 13: 141,\n\t 14: 37,\n\t 15: 26,\n\t 16: 42,\n\t 17: 157,\n\t 18: 106,\n\t 19: 39,\n\t 20: 85,\n\t 21: 80,\n\t 22: 47,\n\t 23: 102,\n\t 24: 158,\n\t 25: 15,\n\t 26: 9,\n\t 27: 55,\n\t 28: 81,\n\t 29: 79,\n\t 30: 82,\n\t 31: 84,\n\t 32: 6,\n\t 33: 165,\n\t 34: 139,\n\t 35: 137,\n\t 36: 44,\n\t 37: 64,\n\t 38: 68,\n\t 39: 59,\n\t 40: 69,\n\t 41: 60,\n\t 42: 62,\n\t 43: 63,\n\t 44: 65,\n\t 45: 67,\n\t 46: 58,\n\t 47: 61,\n\t 48: 156,\n\t 49: 66,\n\t 50: 35},\n\tstart: 256\n\t};\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/parser.js ---- */ \n\n\t// low level parser to a concrete syntax tree, derived from cpython's lib2to3\n\n\t/**\n\t *\n\t * @constructor\n\t * @param {Object} grammar\n\t *\n\t * p = new Parser(grammar);\n\t * p.setup([start]);\n\t * foreach input token:\n\t *     if p.addtoken(...):\n\t *         break\n\t * root = p.rootnode\n\t *\n\t * can throw SyntaxError\n\t */\n\tfunction Parser (filename, grammar) {\n\t    this.filename = filename;\n\t    this.grammar = grammar;\n\t    this.p_flags = 0;\n\t    return this;\n\t}\n\n\t// all possible parser flags\n\tParser.FUTURE_PRINT_FUNCTION = \"print_function\";\n\tParser.FUTURE_UNICODE_LITERALS = \"unicode_literals\";\n\tParser.FUTURE_DIVISION = \"division\";\n\tParser.FUTURE_ABSOLUTE_IMPORT = \"absolute_import\";\n\tParser.FUTURE_WITH_STATEMENT = \"with_statement\";\n\tParser.FUTURE_NESTED_SCOPES = \"nested_scopes\";\n\tParser.FUTURE_GENERATORS = \"generators\";\n\tParser.CO_FUTURE_PRINT_FUNCTION = 0x10000;\n\tParser.CO_FUTURE_UNICODE_LITERALS = 0x20000;\n\tParser.CO_FUTURE_DIVISON = 0x2000;\n\tParser.CO_FUTURE_ABSOLUTE_IMPORT = 0x4000;\n\tParser.CO_FUTURE_WITH_STATEMENT = 0x8000;\n\n\tParser.prototype.setup = function (start) {\n\t    var stackentry;\n\t    var newnode;\n\t    start = start || this.grammar.start;\n\t    //print(\"START:\"+start);\n\n\t    newnode =\n\t    {\n\t        type    : start,\n\t        value   : null,\n\t        context : null,\n\t        children: []\n\t    };\n\t    stackentry =\n\t    {\n\t        dfa  : this.grammar.dfas[start],\n\t        state: 0,\n\t        node : newnode\n\t    };\n\t    this.stack = [stackentry];\n\t    this.used_names = {};\n\t};\n\n\tfunction findInDfa (a, obj) {\n\t    var i = a.length;\n\t    while (i--) {\n\t        if (a[i][0] === obj[0] && a[i][1] === obj[1]) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\n\t// Add a token; return true if we're done\n\tParser.prototype.addtoken = function (type, value, context) {\n\t    var errline;\n\t    var itsfirst;\n\t    var itsdfa;\n\t    var state;\n\t    var v;\n\t    var t;\n\t    var newstate;\n\t    var i;\n\t    var a;\n\t    var arcs;\n\t    var first;\n\t    var states;\n\t    var tp;\n\t    var ilabel = this.classify(type, value, context);\n\t    //print(\"ilabel:\"+ilabel);\n\n\t    OUTERWHILE:\n\t    while (true) {\n\t        tp = this.stack[this.stack.length - 1];\n\t        states = tp.dfa[0];\n\t        first = tp.dfa[1];\n\t        arcs = states[tp.state];\n\n\t        // look for a state with this label\n\t        for (a = 0; a < arcs.length; ++a) {\n\t            i = arcs[a][0];\n\t            newstate = arcs[a][1];\n\t            t = this.grammar.labels[i][0];\n\t            v = this.grammar.labels[i][1];\n\t            if (ilabel === i) {\n\t                // look it up in the list of labels\n\t                goog.asserts.assert(t < 256);\n\t                // shift a token; we're done with it\n\t                this.shift(type, value, newstate, context);\n\t                // pop while we are in an accept-only state\n\t                state = newstate;\n\t                //print(\"before:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n\t                /* jshint ignore:start */\n\t                while (states[state].length === 1\n\t                    && states[state][0][0] === 0\n\t                    && states[state][0][1] === state) {\n\t                    // states[state] == [(0, state)])\n\t                    this.pop();\n\t                    //print(\"in after pop:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n\t                    if (this.stack.length === 0) {\n\t                        // done!\n\t                        return true;\n\t                    }\n\t                    tp = this.stack[this.stack.length - 1];\n\t                    state = tp.state;\n\t                    states = tp.dfa[0];\n\t                    first = tp.dfa[1];\n\t                    //print(JSON.stringify(states), JSON.stringify(first));\n\t                    //print(\"bottom:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n\t                }\n\t                /* jshint ignore:end */\n\t                // done with this token\n\t                //print(\"DONE, return false\");\n\t                return false;\n\t            } else if (t >= 256) {\n\t                itsdfa = this.grammar.dfas[t];\n\t                itsfirst = itsdfa[1];\n\t                if (itsfirst.hasOwnProperty(ilabel)) {\n\t                    // push a symbol\n\t                    this.push(t, this.grammar.dfas[t], newstate, context);\n\t                    continue OUTERWHILE;\n\t                }\n\t            }\n\t        }\n\n\t        //print(\"findInDfa: \" + JSON.stringify(arcs)+\" vs. \" + tp.state);\n\t        if (findInDfa(arcs, [0, tp.state])) {\n\t            // an accepting state, pop it and try somethign else\n\t            //print(\"WAA\");\n\t            this.pop();\n\t            if (this.stack.length === 0) {\n\t                throw new Sk.builtin.SyntaxError(\"too much input\", this.filename);\n\t            }\n\t        } else {\n\t            // no transition\n\t            errline = context[0][0];\n\n\t            var that = this;\n\t            var ar = arcs.map(function(a) {\n\t                var i = a[0];\n\t                var t = that.grammar.labels[i][0];\n\t                return Sk.nameForToken(t);\n\t            });\n\t            var extra = {\n\t                kind: \"DAG_MISS\",\n\t                expected: ar,\n\t                found: Sk.nameForToken(type),\n\t                found_val: value,\n\t                inside: Sk.nameForToken(tp.node.type),\n\t                node: tp.node,\n\t                parent: this.stack.length > 1 ? this.stack[this.stack.length - 2].node : undefined\n\t            };\n\t            var reason = \"expected \" + ar.join(', ') + \" but found \" + extra.found + \" while parsing \" + extra.inside;\n\n\t            throw new Sk.builtin.SyntaxError(reason, this.filename, errline, context, extra);\n\t        }\n\t    }\n\t};\n\n\t// turn a token into a label\n\tParser.prototype.classify = function (type, value, context) {\n\t    var ilabel;\n\t    if (type === Sk.Tokenizer.Tokens.T_NAME) {\n\t        this.used_names[value] = true;\n\t        ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];\n\n\t        /* Check for handling print as an builtin function */\n\t        if(value === \"print\" && (this.p_flags & Parser.CO_FUTURE_PRINT_FUNCTION || Sk.python3 === true)) {\n\t            ilabel = false; // ilabel determines if the value is a keyword\n\t        }\n\n\t        if (ilabel) {\n\t            //print(\"is keyword\");\n\t            return ilabel;\n\t        }\n\t    }\n\t    ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];\n\t    if (!ilabel) {\n\t        // throw new Sk.builtin.SyntaxError(\"bad token\", type, value, context);\n\t        // Questionable modification to put line number in position 2\n\t        // like everywhere else and filename in position 1.\n\t        var extra = {\n\t            kind: \"CLASSIFY\",\n\t            type: type,\n\t            value: value\n\t        };\n\t        throw new Sk.builtin.SyntaxError(\"bad token\", this.filename, context[0][0], context, extra);\n\t    }\n\t    return ilabel;\n\t};\n\n\t// shift a token\n\tParser.prototype.shift = function (type, value, newstate, context) {\n\t    var dfa = this.stack[this.stack.length - 1].dfa;\n\t    var state = this.stack[this.stack.length - 1].state;\n\t    var node = this.stack[this.stack.length - 1].node;\n\t    //print(\"context\", context);\n\t    var newnode = {\n\t        type      : type,\n\t        value     : value,\n\t        lineno    : context[0][0],         // throwing away end here to match cpython\n\t        col_offset: context[0][1],\n\t        children  : null\n\t    };\n\t    if (newnode) {\n\t        node.children.push(newnode);\n\t    }\n\t    this.stack[this.stack.length - 1] = {\n\t        dfa  : dfa,\n\t        state: newstate,\n\t        node : node\n\t    };\n\t};\n\n\t// push a nonterminal\n\tParser.prototype.push = function (type, newdfa, newstate, context) {\n\t    var dfa = this.stack[this.stack.length - 1].dfa;\n\t    var node = this.stack[this.stack.length - 1].node;\n\t    var newnode = {\n\t        type      : type,\n\t        value     : null,\n\t        lineno    : context[0][0],      // throwing away end here to match cpython\n\t        col_offset: context[0][1],\n\t        children  : []\n\t    };\n\t    this.stack[this.stack.length - 1] = {\n\t        dfa  : dfa,\n\t        state: newstate,\n\t        node : node\n\t    };\n\t    this.stack.push({\n\t        dfa  : newdfa,\n\t        state: 0,\n\t        node : newnode\n\t    });\n\t};\n\n\t//var ac = 0;\n\t//var bc = 0;\n\n\t// pop a nonterminal\n\tParser.prototype.pop = function () {\n\t    var node;\n\t    var pop = this.stack.pop();\n\t    var newnode = pop.node;\n\t    //print(\"POP\");\n\t    if (newnode) {\n\t        //print(\"A\", ac++, newnode.type);\n\t        //print(\"stacklen:\"+this.stack.length);\n\t        if (this.stack.length !== 0) {\n\t            //print(\"B\", bc++);\n\t            node = this.stack[this.stack.length - 1].node;\n\t            node.children.push(newnode);\n\t        } else {\n\t            //print(\"C\");\n\t            this.rootnode = newnode;\n\t            this.rootnode.used_names = this.used_names;\n\t        }\n\t    }\n\t};\n\n\t/**\n\t * parser for interactive input. returns a function that should be called with\n\t * lines of input as they are entered. the function will return false\n\t * until the input is complete, when it will return the rootnode of the parse.\n\t *\n\t * @param {string} filename\n\t * @param {string=} style root of parse tree (optional)\n\t */\n\tfunction makeParser (filename, style) {\n\t    var tokenizer;\n\t    var T_OP;\n\t    var T_NL;\n\t    var T_COMMENT;\n\t    var prefix;\n\t    var column;\n\t    var lineno;\n\t    var p;\n\t    if (style === undefined) {\n\t        style = \"file_input\";\n\t    }\n\t    p = new Parser(filename, Sk.ParseTables);\n\t    // for closure's benefit\n\t    if (style === \"file_input\") {\n\t        p.setup(Sk.ParseTables.sym.file_input);\n\t    } else {\n\t        goog.asserts.fail(\"todo;\");\n\t    }\n\t    lineno = 1;\n\t    column = 0;\n\t    prefix = \"\";\n\t    T_COMMENT = Sk.Tokenizer.Tokens.T_COMMENT;\n\t    T_NL = Sk.Tokenizer.Tokens.T_NL;\n\t    T_OP = Sk.Tokenizer.Tokens.T_OP;\n\t    tokenizer = new Sk.Tokenizer(filename, style === \"single_input\", function (type, value, start, end, line) {\n\t        var s_lineno = start[0];\n\t        var s_column = start[1];\n\t        /*\n\t         if (s_lineno !== lineno && s_column !== column)\n\t         {\n\t         // todo; update prefix and line/col\n\t         }\n\t         */\n\t        if (type === T_COMMENT || type === T_NL) {\n\t            prefix += value;\n\t            lineno = end[0];\n\t            column = end[1];\n\t            if (value[value.length - 1] === \"\\n\") {\n\t                lineno += 1;\n\t                column = 0;\n\t            }\n\t            //print(\"  not calling addtoken\");\n\t            return undefined;\n\t        }\n\t        if (type === T_OP) {\n\t            type = Sk.OpMap[value];\n\t        }\n\t        if (p.addtoken(type, value, [start, end, line])) {\n\t            return true;\n\t        }\n\t    });\n\n\t    // create parser function\n\t    var parseFunc = function (line) {\n\t        var ret = tokenizer.generateTokens(line);\n\t        //print(\"tok:\"+ret);\n\t        if (ret) {\n\t            if (ret !== \"done\") {\n\t                throw new Sk.builtin.SyntaxError(\"incomplete input\", this.filename);\n\t            }\n\t            return p.rootnode;\n\t        }\n\t        return false;\n\t    };\n\n\t    // set flags, and return\n\t    parseFunc.p_flags = p.p_flags;\n\t    return parseFunc;\n\t}\n\n\tSk.parse = function parse (filename, input) {\n\t    var i;\n\t    var ret;\n\t    var lines;\n\t    var parseFunc = makeParser(filename);\n\t    if (input.substr(input.length - 1, 1) !== \"\\n\") {\n\t        input += \"\\n\";\n\t    }\n\t    //print(\"input:\"+input);\n\t    lines = input.split(\"\\n\");\n\t    for (i = 0; i < lines.length; ++i) {\n\t        ret = parseFunc(lines[i] + ((i === lines.length - 1) ? \"\" : \"\\n\"));\n\t    }\n\n\t    /*\n\t     * Small adjustments here in order to return th flags and the cst\n\t     */\n\t    return {\"cst\": ret, \"flags\": parseFunc.p_flags};\n\t};\n\n\tSk.parseTreeDump = function parseTreeDump (n, indent) {\n\t    //return JSON.stringify(n, null, 2);\n\t    var i;\n\t    var ret;\n\t    indent = indent || \"\";\n\t    ret = \"\";\n\t    ret += indent;\n\t    if (n.type >= 256) { // non-term\n\t        ret += Sk.ParseTables.number2symbol[n.type] + \"\\n\";\n\t        for (i = 0; i < n.children.length; ++i) {\n\t            ret += Sk.parseTreeDump(n.children[i], indent + \"  \");\n\t        }\n\t    } else {\n\t        ret += Sk.Tokenizer.tokenNames[n.type] + \": \" + new Sk.builtin.str(n.value)[\"$r\"]().v + \"\\n\";\n\t    }\n\t    return ret;\n\t};\n\n\n\tgoog.exportSymbol(\"Sk.parse\", Sk.parse);\n\tgoog.exportSymbol(\"Sk.parseTreeDump\", Sk.parseTreeDump);\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/gen/astnodes.js ---- */ \n\n\t/* File automatically generated by ./asdl_js.py. */\n\n\t/* ----- expr_context ----- */\n\t/** @constructor */\n\tfunction Load() {}\n\t/** @constructor */\n\tfunction Store() {}\n\t/** @constructor */\n\tfunction Del() {}\n\t/** @constructor */\n\tfunction AugLoad() {}\n\t/** @constructor */\n\tfunction AugStore() {}\n\t/** @constructor */\n\tfunction Param() {}\n\n\t/* ----- boolop ----- */\n\t/** @constructor */\n\tfunction And() {}\n\t/** @constructor */\n\tfunction Or() {}\n\n\t/* ----- operator ----- */\n\t/** @constructor */\n\tfunction Add() {}\n\t/** @constructor */\n\tfunction Sub() {}\n\t/** @constructor */\n\tfunction Mult() {}\n\t/** @constructor */\n\tfunction Div() {}\n\t/** @constructor */\n\tfunction Mod() {}\n\t/** @constructor */\n\tfunction Pow() {}\n\t/** @constructor */\n\tfunction LShift() {}\n\t/** @constructor */\n\tfunction RShift() {}\n\t/** @constructor */\n\tfunction BitOr() {}\n\t/** @constructor */\n\tfunction BitXor() {}\n\t/** @constructor */\n\tfunction BitAnd() {}\n\t/** @constructor */\n\tfunction FloorDiv() {}\n\n\t/* ----- unaryop ----- */\n\t/** @constructor */\n\tfunction Invert() {}\n\t/** @constructor */\n\tfunction Not() {}\n\t/** @constructor */\n\tfunction UAdd() {}\n\t/** @constructor */\n\tfunction USub() {}\n\n\t/* ----- cmpop ----- */\n\t/** @constructor */\n\tfunction Eq() {}\n\t/** @constructor */\n\tfunction NotEq() {}\n\t/** @constructor */\n\tfunction Lt() {}\n\t/** @constructor */\n\tfunction LtE() {}\n\t/** @constructor */\n\tfunction Gt() {}\n\t/** @constructor */\n\tfunction GtE() {}\n\t/** @constructor */\n\tfunction Is() {}\n\t/** @constructor */\n\tfunction IsNot() {}\n\t/** @constructor */\n\tfunction In_() {}\n\t/** @constructor */\n\tfunction NotIn() {}\n\n\n\n\n\n\n\n\t/* ---------------------- */\n\t/* constructors for nodes */\n\t/* ---------------------- */\n\n\n\n\n\n\t/** @constructor */\n\tfunction Module(/* {asdl_seq *} */ body)\n\t{\n\t    this.body = body;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Interactive(/* {asdl_seq *} */ body)\n\t{\n\t    this.body = body;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Expression(/* {expr_ty} */ body)\n\t{\n\t    goog.asserts.assert(body !== null && body !== undefined);\n\t    this.body = body;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Suite(/* {asdl_seq *} */ body)\n\t{\n\t    this.body = body;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction FunctionDef(/* {identifier} */ name, /* {arguments__ty} */ args, /*\n\t                          {asdl_seq *} */ body, /* {asdl_seq *} */\n\t                          decorator_list, /* {int} */ lineno, /* {int} */\n\t                          col_offset)\n\t{\n\t    goog.asserts.assert(name !== null && name !== undefined);\n\t    goog.asserts.assert(args !== null && args !== undefined);\n\t    this.name = name;\n\t    this.args = args;\n\t    this.body = body;\n\t    this.decorator_list = decorator_list;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ClassDef(/* {identifier} */ name, /* {asdl_seq *} */ bases, /*\n\t                       {asdl_seq *} */ body, /* {asdl_seq *} */ decorator_list,\n\t                       /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(name !== null && name !== undefined);\n\t    this.name = name;\n\t    this.bases = bases;\n\t    this.body = body;\n\t    this.decorator_list = decorator_list;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Return_(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */\n\t                      col_offset)\n\t{\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Delete_(/* {asdl_seq *} */ targets, /* {int} */ lineno, /* {int} */\n\t                      col_offset)\n\t{\n\t    this.targets = targets;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Assign(/* {asdl_seq *} */ targets, /* {expr_ty} */ value, /* {int} */\n\t                     lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.targets = targets;\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction AugAssign(/* {expr_ty} */ target, /* {operator_ty} */ op, /* {expr_ty}\n\t                        */ value, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(target !== null && target !== undefined);\n\t    goog.asserts.assert(op !== null && op !== undefined);\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.target = target;\n\t    this.op = op;\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Print(/* {expr_ty} */ dest, /* {asdl_seq *} */ values, /* {bool} */\n\t                    nl, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.dest = dest;\n\t    this.values = values;\n\t    this.nl = nl;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction For_(/* {expr_ty} */ target, /* {expr_ty} */ iter, /* {asdl_seq *} */\n\t                   body, /* {asdl_seq *} */ orelse, /* {int} */ lineno, /*\n\t                   {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(target !== null && target !== undefined);\n\t    goog.asserts.assert(iter !== null && iter !== undefined);\n\t    this.target = target;\n\t    this.iter = iter;\n\t    this.body = body;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction While_(/* {expr_ty} */ test, /* {asdl_seq *} */ body, /* {asdl_seq *}\n\t                     */ orelse, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(test !== null && test !== undefined);\n\t    this.test = test;\n\t    this.body = body;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction If_(/* {expr_ty} */ test, /* {asdl_seq *} */ body, /* {asdl_seq *} */\n\t                  orelse, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(test !== null && test !== undefined);\n\t    this.test = test;\n\t    this.body = body;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction With_(/* {expr_ty} */ context_expr, /* {expr_ty} */ optional_vars, /*\n\t                    {asdl_seq *} */ body, /* {int} */ lineno, /* {int} */\n\t                    col_offset)\n\t{\n\t    goog.asserts.assert(context_expr !== null && context_expr !== undefined);\n\t    this.context_expr = context_expr;\n\t    this.optional_vars = optional_vars;\n\t    this.body = body;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Raise(/* {expr_ty} */ type, /* {expr_ty} */ inst, /* {expr_ty} */\n\t                    tback, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.type = type;\n\t    this.inst = inst;\n\t    this.tback = tback;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction TryExcept(/* {asdl_seq *} */ body, /* {asdl_seq *} */ handlers, /*\n\t                        {asdl_seq *} */ orelse, /* {int} */ lineno, /* {int} */\n\t                        col_offset)\n\t{\n\t    this.body = body;\n\t    this.handlers = handlers;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction TryFinally(/* {asdl_seq *} */ body, /* {asdl_seq *} */ finalbody, /*\n\t                         {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.body = body;\n\t    this.finalbody = finalbody;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Assert(/* {expr_ty} */ test, /* {expr_ty} */ msg, /* {int} */ lineno,\n\t                     /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(test !== null && test !== undefined);\n\t    this.test = test;\n\t    this.msg = msg;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Import_(/* {asdl_seq *} */ names, /* {int} */ lineno, /* {int} */\n\t                      col_offset)\n\t{\n\t    this.names = names;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ImportFrom(/* {identifier} */ module, /* {asdl_seq *} */ names, /*\n\t                         {int} */ level, /* {int} */ lineno, /* {int} */\n\t                         col_offset)\n\t{\n\t    goog.asserts.assert(module !== null && module !== undefined);\n\t    this.module = module;\n\t    this.names = names;\n\t    this.level = level;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Exec(/* {expr_ty} */ body, /* {expr_ty} */ globals, /* {expr_ty} */\n\t                   locals, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(body !== null && body !== undefined);\n\t    this.body = body;\n\t    this.globals = globals;\n\t    this.locals = locals;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Global(/* {asdl_seq *} */ names, /* {int} */ lineno, /* {int} */\n\t                     col_offset)\n\t{\n\t    this.names = names;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Expr(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Pass(/* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Break_(/* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Continue_(/* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Debugger_(/* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction BoolOp(/* {boolop_ty} */ op, /* {asdl_seq *} */ values, /* {int} */\n\t                     lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(op !== null && op !== undefined);\n\t    this.op = op;\n\t    this.values = values;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction BinOp(/* {expr_ty} */ left, /* {operator_ty} */ op, /* {expr_ty} */\n\t                    right, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(left !== null && left !== undefined);\n\t    goog.asserts.assert(op !== null && op !== undefined);\n\t    goog.asserts.assert(right !== null && right !== undefined);\n\t    this.left = left;\n\t    this.op = op;\n\t    this.right = right;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction UnaryOp(/* {unaryop_ty} */ op, /* {expr_ty} */ operand, /* {int} */\n\t                      lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(op !== null && op !== undefined);\n\t    goog.asserts.assert(operand !== null && operand !== undefined);\n\t    this.op = op;\n\t    this.operand = operand;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Lambda(/* {arguments__ty} */ args, /* {expr_ty} */ body, /* {int} */\n\t                     lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(args !== null && args !== undefined);\n\t    goog.asserts.assert(body !== null && body !== undefined);\n\t    this.args = args;\n\t    this.body = body;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction IfExp(/* {expr_ty} */ test, /* {expr_ty} */ body, /* {expr_ty} */\n\t                    orelse, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(test !== null && test !== undefined);\n\t    goog.asserts.assert(body !== null && body !== undefined);\n\t    goog.asserts.assert(orelse !== null && orelse !== undefined);\n\t    this.test = test;\n\t    this.body = body;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Dict(/* {asdl_seq *} */ keys, /* {asdl_seq *} */ values, /* {int} */\n\t                   lineno, /* {int} */ col_offset)\n\t{\n\t    this.keys = keys;\n\t    this.values = values;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Set(/* {asdl_seq *} */ elts, /* {int} */ lineno, /* {int} */\n\t                  col_offset)\n\t{\n\t    this.elts = elts;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ListComp(/* {expr_ty} */ elt, /* {asdl_seq *} */ generators, /* {int}\n\t                       */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(elt !== null && elt !== undefined);\n\t    this.elt = elt;\n\t    this.generators = generators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction SetComp(/* {expr_ty} */ elt, /* {asdl_seq *} */ generators, /* {int}\n\t                      */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(elt !== null && elt !== undefined);\n\t    this.elt = elt;\n\t    this.generators = generators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction DictComp(/* {expr_ty} */ key, /* {expr_ty} */ value, /* {asdl_seq *}\n\t                       */ generators, /* {int} */ lineno, /* {int} */\n\t                       col_offset)\n\t{\n\t    goog.asserts.assert(key !== null && key !== undefined);\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.key = key;\n\t    this.value = value;\n\t    this.generators = generators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction GeneratorExp(/* {expr_ty} */ elt, /* {asdl_seq *} */ generators, /*\n\t                           {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(elt !== null && elt !== undefined);\n\t    this.elt = elt;\n\t    this.generators = generators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Yield(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */\n\t                    col_offset)\n\t{\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Compare(/* {expr_ty} */ left, /* {asdl_int_seq *} */ ops, /* {asdl_seq\n\t                      *} */ comparators, /* {int} */ lineno, /* {int} */\n\t                      col_offset)\n\t{\n\t    goog.asserts.assert(left !== null && left !== undefined);\n\t    this.left = left;\n\t    this.ops = ops;\n\t    this.comparators = comparators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Call(/* {expr_ty} */ func, /* {asdl_seq *} */ args, /* {asdl_seq *} */\n\t                   keywords, /* {expr_ty} */ starargs, /* {expr_ty} */ kwargs,\n\t                   /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(func !== null && func !== undefined);\n\t    this.func = func;\n\t    this.args = args;\n\t    this.keywords = keywords;\n\t    this.starargs = starargs;\n\t    this.kwargs = kwargs;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Repr(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Num(/* {object} */ n, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(n !== null && n !== undefined);\n\t    this.n = n;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Str(/* {string} */ s, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(s !== null && s !== undefined);\n\t    this.s = s;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Attribute(/* {expr_ty} */ value, /* {identifier} */ attr, /*\n\t                        {expr_context_ty} */ ctx, /* {int} */ lineno, /* {int}\n\t                        */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    goog.asserts.assert(attr !== null && attr !== undefined);\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.value = value;\n\t    this.attr = attr;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Subscript(/* {expr_ty} */ value, /* {slice_ty} */ slice, /*\n\t                        {expr_context_ty} */ ctx, /* {int} */ lineno, /* {int}\n\t                        */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    goog.asserts.assert(slice !== null && slice !== undefined);\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.value = value;\n\t    this.slice = slice;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Name(/* {identifier} */ id, /* {expr_context_ty} */ ctx, /* {int} */\n\t                   lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(id !== null && id !== undefined);\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.id = id;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction List(/* {asdl_seq *} */ elts, /* {expr_context_ty} */ ctx, /* {int} */\n\t                   lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.elts = elts;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Tuple(/* {asdl_seq *} */ elts, /* {expr_context_ty} */ ctx, /* {int}\n\t                    */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.elts = elts;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Ellipsis()\n\t{\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Slice(/* {expr_ty} */ lower, /* {expr_ty} */ upper, /* {expr_ty} */\n\t                    step)\n\t{\n\t    this.lower = lower;\n\t    this.upper = upper;\n\t    this.step = step;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ExtSlice(/* {asdl_seq *} */ dims)\n\t{\n\t    this.dims = dims;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Index(/* {expr_ty} */ value)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.value = value;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction comprehension(/* {expr_ty} */ target, /* {expr_ty} */ iter, /*\n\t                            {asdl_seq *} */ ifs)\n\t{\n\t    goog.asserts.assert(target !== null && target !== undefined);\n\t    goog.asserts.assert(iter !== null && iter !== undefined);\n\t    this.target = target;\n\t    this.iter = iter;\n\t    this.ifs = ifs;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ExceptHandler(/* {expr_ty} */ type, /* {expr_ty} */ name, /* {asdl_seq\n\t                            *} */ body, /* {int} */ lineno, /* {int} */\n\t                            col_offset)\n\t{\n\t    this.type = type;\n\t    this.name = name;\n\t    this.body = body;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction arguments_(/* {asdl_seq *} */ args, /* {identifier} */ vararg, /*\n\t                         {identifier} */ kwarg, /* {asdl_seq *} */ defaults)\n\t{\n\t    this.args = args;\n\t    this.vararg = vararg;\n\t    this.kwarg = kwarg;\n\t    this.defaults = defaults;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction keyword(/* {identifier} */ arg, /* {expr_ty} */ value)\n\t{\n\t    goog.asserts.assert(arg !== null && arg !== undefined);\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.arg = arg;\n\t    this.value = value;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction alias(/* {identifier} */ name, /* {identifier} */ asname)\n\t{\n\t    goog.asserts.assert(name !== null && name !== undefined);\n\t    this.name = name;\n\t    this.asname = asname;\n\t    return this;\n\t}\n\n\n\tModule.prototype._astname = \"Module\";\n\tModule.prototype._fields = [\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tInteractive.prototype._astname = \"Interactive\";\n\tInteractive.prototype._fields = [\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tExpression.prototype._astname = \"Expression\";\n\tExpression.prototype._fields = [\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tSuite.prototype._astname = \"Suite\";\n\tSuite.prototype._fields = [\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tFunctionDef.prototype._astname = \"FunctionDef\";\n\tFunctionDef.prototype._fields = [\n\t    \"name\", function(n) { return n.name; },\n\t    \"args\", function(n) { return n.args; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"decorator_list\", function(n) { return n.decorator_list; }\n\t];\n\tClassDef.prototype._astname = \"ClassDef\";\n\tClassDef.prototype._fields = [\n\t    \"name\", function(n) { return n.name; },\n\t    \"bases\", function(n) { return n.bases; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"decorator_list\", function(n) { return n.decorator_list; }\n\t];\n\tReturn_.prototype._astname = \"Return\";\n\tReturn_.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tDelete_.prototype._astname = \"Delete\";\n\tDelete_.prototype._fields = [\n\t    \"targets\", function(n) { return n.targets; }\n\t];\n\tAssign.prototype._astname = \"Assign\";\n\tAssign.prototype._fields = [\n\t    \"targets\", function(n) { return n.targets; },\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tAugAssign.prototype._astname = \"AugAssign\";\n\tAugAssign.prototype._fields = [\n\t    \"target\", function(n) { return n.target; },\n\t    \"op\", function(n) { return n.op; },\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tPrint.prototype._astname = \"Print\";\n\tPrint.prototype._fields = [\n\t    \"dest\", function(n) { return n.dest; },\n\t    \"values\", function(n) { return n.values; },\n\t    \"nl\", function(n) { return n.nl; }\n\t];\n\tFor_.prototype._astname = \"For\";\n\tFor_.prototype._fields = [\n\t    \"target\", function(n) { return n.target; },\n\t    \"iter\", function(n) { return n.iter; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tWhile_.prototype._astname = \"While\";\n\tWhile_.prototype._fields = [\n\t    \"test\", function(n) { return n.test; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tIf_.prototype._astname = \"If\";\n\tIf_.prototype._fields = [\n\t    \"test\", function(n) { return n.test; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tWith_.prototype._astname = \"With\";\n\tWith_.prototype._fields = [\n\t    \"context_expr\", function(n) { return n.context_expr; },\n\t    \"optional_vars\", function(n) { return n.optional_vars; },\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tRaise.prototype._astname = \"Raise\";\n\tRaise.prototype._fields = [\n\t    \"type\", function(n) { return n.type; },\n\t    \"inst\", function(n) { return n.inst; },\n\t    \"tback\", function(n) { return n.tback; }\n\t];\n\tTryExcept.prototype._astname = \"TryExcept\";\n\tTryExcept.prototype._fields = [\n\t    \"body\", function(n) { return n.body; },\n\t    \"handlers\", function(n) { return n.handlers; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tTryFinally.prototype._astname = \"TryFinally\";\n\tTryFinally.prototype._fields = [\n\t    \"body\", function(n) { return n.body; },\n\t    \"finalbody\", function(n) { return n.finalbody; }\n\t];\n\tAssert.prototype._astname = \"Assert\";\n\tAssert.prototype._fields = [\n\t    \"test\", function(n) { return n.test; },\n\t    \"msg\", function(n) { return n.msg; }\n\t];\n\tImport_.prototype._astname = \"Import\";\n\tImport_.prototype._fields = [\n\t    \"names\", function(n) { return n.names; }\n\t];\n\tImportFrom.prototype._astname = \"ImportFrom\";\n\tImportFrom.prototype._fields = [\n\t    \"module\", function(n) { return n.module; },\n\t    \"names\", function(n) { return n.names; },\n\t    \"level\", function(n) { return n.level; }\n\t];\n\tExec.prototype._astname = \"Exec\";\n\tExec.prototype._fields = [\n\t    \"body\", function(n) { return n.body; },\n\t    \"globals\", function(n) { return n.globals; },\n\t    \"locals\", function(n) { return n.locals; }\n\t];\n\tGlobal.prototype._astname = \"Global\";\n\tGlobal.prototype._fields = [\n\t    \"names\", function(n) { return n.names; }\n\t];\n\tExpr.prototype._astname = \"Expr\";\n\tExpr.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tPass.prototype._astname = \"Pass\";\n\tPass.prototype._fields = [\n\t];\n\tBreak_.prototype._astname = \"Break\";\n\tBreak_.prototype._fields = [\n\t];\n\tContinue_.prototype._astname = \"Continue\";\n\tContinue_.prototype._fields = [\n\t];\n\tDebugger_.prototype._astname = \"Debugger\";\n\tDebugger_.prototype._fields = [\n\t];\n\tBoolOp.prototype._astname = \"BoolOp\";\n\tBoolOp.prototype._fields = [\n\t    \"op\", function(n) { return n.op; },\n\t    \"values\", function(n) { return n.values; }\n\t];\n\tBinOp.prototype._astname = \"BinOp\";\n\tBinOp.prototype._fields = [\n\t    \"left\", function(n) { return n.left; },\n\t    \"op\", function(n) { return n.op; },\n\t    \"right\", function(n) { return n.right; }\n\t];\n\tUnaryOp.prototype._astname = \"UnaryOp\";\n\tUnaryOp.prototype._fields = [\n\t    \"op\", function(n) { return n.op; },\n\t    \"operand\", function(n) { return n.operand; }\n\t];\n\tLambda.prototype._astname = \"Lambda\";\n\tLambda.prototype._fields = [\n\t    \"args\", function(n) { return n.args; },\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tIfExp.prototype._astname = \"IfExp\";\n\tIfExp.prototype._fields = [\n\t    \"test\", function(n) { return n.test; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tDict.prototype._astname = \"Dict\";\n\tDict.prototype._fields = [\n\t    \"keys\", function(n) { return n.keys; },\n\t    \"values\", function(n) { return n.values; }\n\t];\n\tSet.prototype._astname = \"Set\";\n\tSet.prototype._fields = [\n\t    \"elts\", function(n) { return n.elts; }\n\t];\n\tListComp.prototype._astname = \"ListComp\";\n\tListComp.prototype._fields = [\n\t    \"elt\", function(n) { return n.elt; },\n\t    \"generators\", function(n) { return n.generators; }\n\t];\n\tSetComp.prototype._astname = \"SetComp\";\n\tSetComp.prototype._fields = [\n\t    \"elt\", function(n) { return n.elt; },\n\t    \"generators\", function(n) { return n.generators; }\n\t];\n\tDictComp.prototype._astname = \"DictComp\";\n\tDictComp.prototype._fields = [\n\t    \"key\", function(n) { return n.key; },\n\t    \"value\", function(n) { return n.value; },\n\t    \"generators\", function(n) { return n.generators; }\n\t];\n\tGeneratorExp.prototype._astname = \"GeneratorExp\";\n\tGeneratorExp.prototype._fields = [\n\t    \"elt\", function(n) { return n.elt; },\n\t    \"generators\", function(n) { return n.generators; }\n\t];\n\tYield.prototype._astname = \"Yield\";\n\tYield.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tCompare.prototype._astname = \"Compare\";\n\tCompare.prototype._fields = [\n\t    \"left\", function(n) { return n.left; },\n\t    \"ops\", function(n) { return n.ops; },\n\t    \"comparators\", function(n) { return n.comparators; }\n\t];\n\tCall.prototype._astname = \"Call\";\n\tCall.prototype._fields = [\n\t    \"func\", function(n) { return n.func; },\n\t    \"args\", function(n) { return n.args; },\n\t    \"keywords\", function(n) { return n.keywords; },\n\t    \"starargs\", function(n) { return n.starargs; },\n\t    \"kwargs\", function(n) { return n.kwargs; }\n\t];\n\tRepr.prototype._astname = \"Repr\";\n\tRepr.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tNum.prototype._astname = \"Num\";\n\tNum.prototype._fields = [\n\t    \"n\", function(n) { return n.n; }\n\t];\n\tStr.prototype._astname = \"Str\";\n\tStr.prototype._fields = [\n\t    \"s\", function(n) { return n.s; }\n\t];\n\tAttribute.prototype._astname = \"Attribute\";\n\tAttribute.prototype._fields = [\n\t    \"value\", function(n) { return n.value; },\n\t    \"attr\", function(n) { return n.attr; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tSubscript.prototype._astname = \"Subscript\";\n\tSubscript.prototype._fields = [\n\t    \"value\", function(n) { return n.value; },\n\t    \"slice\", function(n) { return n.slice; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tName.prototype._astname = \"Name\";\n\tName.prototype._fields = [\n\t    \"id\", function(n) { return n.id; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tList.prototype._astname = \"List\";\n\tList.prototype._fields = [\n\t    \"elts\", function(n) { return n.elts; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tTuple.prototype._astname = \"Tuple\";\n\tTuple.prototype._fields = [\n\t    \"elts\", function(n) { return n.elts; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tLoad.prototype._astname = \"Load\";\n\tLoad.prototype._isenum = true;\n\tStore.prototype._astname = \"Store\";\n\tStore.prototype._isenum = true;\n\tDel.prototype._astname = \"Del\";\n\tDel.prototype._isenum = true;\n\tAugLoad.prototype._astname = \"AugLoad\";\n\tAugLoad.prototype._isenum = true;\n\tAugStore.prototype._astname = \"AugStore\";\n\tAugStore.prototype._isenum = true;\n\tParam.prototype._astname = \"Param\";\n\tParam.prototype._isenum = true;\n\tEllipsis.prototype._astname = \"Ellipsis\";\n\tEllipsis.prototype._fields = [\n\t];\n\tSlice.prototype._astname = \"Slice\";\n\tSlice.prototype._fields = [\n\t    \"lower\", function(n) { return n.lower; },\n\t    \"upper\", function(n) { return n.upper; },\n\t    \"step\", function(n) { return n.step; }\n\t];\n\tExtSlice.prototype._astname = \"ExtSlice\";\n\tExtSlice.prototype._fields = [\n\t    \"dims\", function(n) { return n.dims; }\n\t];\n\tIndex.prototype._astname = \"Index\";\n\tIndex.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tAnd.prototype._astname = \"And\";\n\tAnd.prototype._isenum = true;\n\tOr.prototype._astname = \"Or\";\n\tOr.prototype._isenum = true;\n\tAdd.prototype._astname = \"Add\";\n\tAdd.prototype._isenum = true;\n\tSub.prototype._astname = \"Sub\";\n\tSub.prototype._isenum = true;\n\tMult.prototype._astname = \"Mult\";\n\tMult.prototype._isenum = true;\n\tDiv.prototype._astname = \"Div\";\n\tDiv.prototype._isenum = true;\n\tMod.prototype._astname = \"Mod\";\n\tMod.prototype._isenum = true;\n\tPow.prototype._astname = \"Pow\";\n\tPow.prototype._isenum = true;\n\tLShift.prototype._astname = \"LShift\";\n\tLShift.prototype._isenum = true;\n\tRShift.prototype._astname = \"RShift\";\n\tRShift.prototype._isenum = true;\n\tBitOr.prototype._astname = \"BitOr\";\n\tBitOr.prototype._isenum = true;\n\tBitXor.prototype._astname = \"BitXor\";\n\tBitXor.prototype._isenum = true;\n\tBitAnd.prototype._astname = \"BitAnd\";\n\tBitAnd.prototype._isenum = true;\n\tFloorDiv.prototype._astname = \"FloorDiv\";\n\tFloorDiv.prototype._isenum = true;\n\tInvert.prototype._astname = \"Invert\";\n\tInvert.prototype._isenum = true;\n\tNot.prototype._astname = \"Not\";\n\tNot.prototype._isenum = true;\n\tUAdd.prototype._astname = \"UAdd\";\n\tUAdd.prototype._isenum = true;\n\tUSub.prototype._astname = \"USub\";\n\tUSub.prototype._isenum = true;\n\tEq.prototype._astname = \"Eq\";\n\tEq.prototype._isenum = true;\n\tNotEq.prototype._astname = \"NotEq\";\n\tNotEq.prototype._isenum = true;\n\tLt.prototype._astname = \"Lt\";\n\tLt.prototype._isenum = true;\n\tLtE.prototype._astname = \"LtE\";\n\tLtE.prototype._isenum = true;\n\tGt.prototype._astname = \"Gt\";\n\tGt.prototype._isenum = true;\n\tGtE.prototype._astname = \"GtE\";\n\tGtE.prototype._isenum = true;\n\tIs.prototype._astname = \"Is\";\n\tIs.prototype._isenum = true;\n\tIsNot.prototype._astname = \"IsNot\";\n\tIsNot.prototype._isenum = true;\n\tIn_.prototype._astname = \"In\";\n\tIn_.prototype._isenum = true;\n\tNotIn.prototype._astname = \"NotIn\";\n\tNotIn.prototype._isenum = true;\n\tcomprehension.prototype._astname = \"comprehension\";\n\tcomprehension.prototype._fields = [\n\t    \"target\", function(n) { return n.target; },\n\t    \"iter\", function(n) { return n.iter; },\n\t    \"ifs\", function(n) { return n.ifs; }\n\t];\n\tExceptHandler.prototype._astname = \"ExceptHandler\";\n\tExceptHandler.prototype._fields = [\n\t    \"type\", function(n) { return n.type; },\n\t    \"name\", function(n) { return n.name; },\n\t    \"body\", function(n) { return n.body; }\n\t];\n\targuments_.prototype._astname = \"arguments\";\n\targuments_.prototype._fields = [\n\t    \"args\", function(n) { return n.args; },\n\t    \"vararg\", function(n) { return n.vararg; },\n\t    \"kwarg\", function(n) { return n.kwarg; },\n\t    \"defaults\", function(n) { return n.defaults; }\n\t];\n\tkeyword.prototype._astname = \"keyword\";\n\tkeyword.prototype._fields = [\n\t    \"arg\", function(n) { return n.arg; },\n\t    \"value\", function(n) { return n.value; }\n\t];\n\talias.prototype._astname = \"alias\";\n\talias.prototype._fields = [\n\t    \"name\", function(n) { return n.name; },\n\t    \"asname\", function(n) { return n.asname; }\n\t];\n\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/ast.js ---- */ \n\n\t//\n\t// This is pretty much a straight port of ast.c from CPython 2.6.5.\n\t//\n\t// The previous version was easier to work with and more JS-ish, but having a\n\t// somewhat different ast structure than cpython makes testing more difficult.\n\t//\n\t// This way, we can use a dump from the ast module on any arbitrary python\n\t// code and know that we're the same up to ast level, at least.\n\t//\n\n\tvar SYM = Sk.ParseTables.sym;\n\tvar TOK = Sk.Tokenizer.Tokens;\n\tvar COMP_GENEXP = 0;\n\tvar COMP_SETCOMP = 1;\n\n\t/** @constructor */\n\tfunction Compiling (encoding, filename, c_flags) {\n\t    this.c_encoding = encoding;\n\t    this.c_filename = filename;\n\t    this.c_flags = c_flags || 0;\n\t}\n\n\t/**\n\t * @return {number}\n\t */\n\tfunction NCH (n) {\n\t    goog.asserts.assert(n !== undefined);\n\t    if (n.children === null) {\n\t        return 0;\n\t    }\n\t    return n.children.length;\n\t}\n\n\tfunction CHILD (n, i) {\n\t    goog.asserts.assert(n !== undefined);\n\t    goog.asserts.assert(i !== undefined);\n\t    return n.children[i];\n\t}\n\n\tfunction REQ (n, type) {\n\t    goog.asserts.assert(n.type === type, \"node wasn't expected type\");\n\t}\n\n\tfunction strobj (s) {\n\t    goog.asserts.assert(typeof s === \"string\", \"expecting string, got \" + (typeof s));\n\t    return new Sk.builtin.str(s);\n\t}\n\n\t/** @return {number} */\n\tfunction numStmts (n) {\n\t    var ch;\n\t    var i;\n\t    var cnt;\n\t    switch (n.type) {\n\t        case SYM.single_input:\n\t            if (CHILD(n, 0).type === TOK.T_NEWLINE) {\n\t                return 0;\n\t            }\n\t            else {\n\t                return numStmts(CHILD(n, 0));\n\t            }\n\t        case SYM.file_input:\n\t            cnt = 0;\n\t            for (i = 0; i < NCH(n); ++i) {\n\t                ch = CHILD(n, i);\n\t                if (ch.type === SYM.stmt) {\n\t                    cnt += numStmts(ch);\n\t                }\n\t            }\n\t            return cnt;\n\t        case SYM.stmt:\n\t            return numStmts(CHILD(n, 0));\n\t        case SYM.compound_stmt:\n\t            return 1;\n\t        case SYM.simple_stmt:\n\t            return Math.floor(NCH(n) / 2); // div 2 is to remove count of ;s\n\t        case SYM.suite:\n\t            if (NCH(n) === 1) {\n\t                return numStmts(CHILD(n, 0));\n\t            }\n\t            else {\n\t                cnt = 0;\n\t                for (i = 2; i < NCH(n) - 1; ++i) {\n\t                    cnt += numStmts(CHILD(n, i));\n\t                }\n\t                return cnt;\n\t            }\n\t            break;\n\t        default:\n\t            goog.asserts.fail(\"Non-statement found\");\n\t    }\n\t    return 0;\n\t}\n\n\tfunction forbiddenCheck (c, n, x, lineno) {\n\t    if (x === \"None\") {\n\t        throw new Sk.builtin.SyntaxError(\"assignment to None\", c.c_filename, lineno, [], {node: n});\n\t    }\n\t    if (x === \"True\" || x === \"False\") {\n\t        throw new Sk.builtin.SyntaxError(\"assignment to True or False is forbidden\", c.c_filename, lineno, [], {node: n});\n\t    }\n\t}\n\n\t/**\n\t * Set the context ctx for e, recursively traversing e.\n\t *\n\t * Only sets context for expr kinds that can appear in assignment context as\n\t * per the asdl file.\n\t */\n\tfunction setContext (c, e, ctx, n) {\n\t    var i;\n\t    var exprName;\n\t    var s;\n\t    goog.asserts.assert(ctx !== AugStore && ctx !== AugLoad);\n\t    s = null;\n\t    exprName = null;\n\n\t    switch (e.constructor) {\n\t        case Attribute:\n\t        case Name:\n\t            if (ctx === Store) {\n\t                forbiddenCheck(c, n, e.attr, n.lineno);\n\t            }\n\t            e.ctx = ctx;\n\t            break;\n\t        case Subscript:\n\t            e.ctx = ctx;\n\t            break;\n\t        case List:\n\t            e.ctx = ctx;\n\t            s = e.elts;\n\t            break;\n\t        case Tuple:\n\t            if (e.elts.length === 0) {\n\t                throw new Sk.builtin.SyntaxError(\"can't assign to ()\", c.c_filename, n.lineno, ctx, {node: n});\n\t            }\n\t            e.ctx = ctx;\n\t            s = e.elts;\n\t            break;\n\t        case Lambda:\n\t            exprName = \"lambda\";\n\t            break;\n\t        case Call:\n\t            exprName = \"function call\";\n\t            break;\n\t        case BoolOp:\n\t        case BinOp:\n\t        case UnaryOp:\n\t            exprName = \"operator\";\n\t            break;\n\t        case GeneratorExp:\n\t            exprName = \"generator expression\";\n\t            break;\n\t        case Yield:\n\t            exprName = \"yield expression\";\n\t            break;\n\t        case ListComp:\n\t            exprName = \"list comprehension\";\n\t            break;\n\t        case SetComp:\n\t            exprName = \"set comprehension\";\n\t            break;\n\t        case DictComp:\n\t            exprName = \"dict comprehension\";\n\t            break;\n\t        case Dict:\n\t        case Set:\n\t        case Num:\n\t        case Str:\n\t            exprName = \"literal\";\n\t            break;\n\t        case Compare:\n\t            exprName = \"comparison\";\n\t            break;\n\t        case Repr:\n\t            exprName = \"repr\";\n\t            break;\n\t        case IfExp:\n\t            exprName = \"conditional expression\";\n\t            break;\n\t        default:\n\t            goog.asserts.fail(\"unhandled expression in assignment\");\n\t    }\n\t    if (exprName) {\n\t        throw new Sk.builtin.SyntaxError(\"can't \" + (ctx === Store ? \"assign to\" : \"delete\") + \" \" + exprName, c.c_filename, n.lineno, [], {node: n});\n\t    }\n\n\t    if (s) {\n\t        for (i = 0; i < s.length; ++i) {\n\t            setContext(c, s[i], ctx, n);\n\t        }\n\t    }\n\t}\n\n\tvar operatorMap = {};\n\t(function () {\n\t    operatorMap[TOK.T_VBAR] = BitOr;\n\t    operatorMap[TOK.T_CIRCUMFLEX] = BitXor;\n\t    operatorMap[TOK.T_AMPER] = BitAnd;\n\t    operatorMap[TOK.T_LEFTSHIFT] = LShift;\n\t    operatorMap[TOK.T_RIGHTSHIFT] = RShift;\n\t    operatorMap[TOK.T_PLUS] = Add;\n\t    operatorMap[TOK.T_MINUS] = Sub;\n\t    operatorMap[TOK.T_STAR] = Mult;\n\t    operatorMap[TOK.T_SLASH] = Div;\n\t    operatorMap[TOK.T_DOUBLESLASH] = FloorDiv;\n\t    operatorMap[TOK.T_PERCENT] = Mod;\n\t}());\n\n\tfunction getOperator (n) {\n\t    goog.asserts.assert(operatorMap[n.type] !== undefined);\n\t    return operatorMap[n.type];\n\t}\n\n\tfunction astForCompOp (c, n) {\n\t    /* comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'\n\t     |'is' 'not'\n\t     */\n\t    REQ(n, SYM.comp_op);\n\t    if (NCH(n) === 1) {\n\t        n = CHILD(n, 0);\n\t        switch (n.type) {\n\t            case TOK.T_LESS:\n\t                return Lt;\n\t            case TOK.T_GREATER:\n\t                return Gt;\n\t            case TOK.T_EQEQUAL:\n\t                return Eq;\n\t            case TOK.T_LESSEQUAL:\n\t                return LtE;\n\t            case TOK.T_GREATEREQUAL:\n\t                return GtE;\n\t            case TOK.T_NOTEQUAL:\n\t                return NotEq;\n\t            case TOK.T_NAME:\n\t                if (n.value === \"in\") {\n\t                    return In_;\n\t                }\n\t                if (n.value === \"is\") {\n\t                    return Is;\n\t                }\n\t        }\n\t    }\n\t    else if (NCH(n) === 2) {\n\t        if (CHILD(n, 0).type === TOK.T_NAME) {\n\t            if (CHILD(n, 1).value === \"in\") {\n\t                return NotIn;\n\t            }\n\t            if (CHILD(n, 0).value === \"is\") {\n\t                return IsNot;\n\t            }\n\t        }\n\t    }\n\t    goog.asserts.fail(\"invalid comp_op\");\n\t}\n\n\tfunction seqForTestlist (c, n) {\n\t    /* testlist: test (',' test)* [','] */\n\t    var i;\n\t    var seq = [];\n\t    goog.asserts.assert(n.type === SYM.testlist ||\n\t        n.type === SYM.listmaker ||\n\t        n.type === SYM.testlist_comp ||\n\t        n.type === SYM.testlist_safe ||\n\t        n.type === SYM.testlist1);\n\t    for (i = 0; i < NCH(n); i += 2) {\n\t        goog.asserts.assert(CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test);\n\t        seq[i / 2] = astForExpr(c, CHILD(n, i));\n\t    }\n\t    return seq;\n\t}\n\n\tfunction astForSuite (c, n) {\n\t    /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */\n\t    var j;\n\t    var num;\n\t    var i;\n\t    var end;\n\t    var ch;\n\t    var pos;\n\t    var seq;\n\t    REQ(n, SYM.suite);\n\t    seq = [];\n\t    pos = 0;\n\t    if (CHILD(n, 0).type === SYM.simple_stmt) {\n\t        n = CHILD(n, 0);\n\t        /* simple_stmt always ends with an NEWLINE and may have a trailing\n\t         * SEMI. */\n\t        end = NCH(n) - 1;\n\t        if (CHILD(n, end - 1).type === TOK.T_SEMI) {\n\t            end -= 1;\n\t        }\n\t        for (i = 0; i < end; i += 2) // by 2 to skip ;\n\t        {\n\t            seq[pos++] = astForStmt(c, CHILD(n, i));\n\t        }\n\t    }\n\t    else {\n\t        for (i = 2; i < NCH(n) - 1; ++i) {\n\t            ch = CHILD(n, i);\n\t            REQ(ch, SYM.stmt);\n\t            num = numStmts(ch);\n\t            if (num === 1) {\n\t                // small_stmt or compound_stmt w/ only 1 child\n\t                seq[pos++] = astForStmt(c, ch);\n\t            }\n\t            else {\n\t                ch = CHILD(ch, 0);\n\t                REQ(ch, SYM.simple_stmt);\n\t                for (j = 0; j < NCH(ch); j += 2) {\n\t                    if (NCH(CHILD(ch, j)) === 0) {\n\t                        goog.asserts.assert(j + 1 === NCH(ch));\n\t                        break;\n\t                    }\n\t                    seq[pos++] = astForStmt(c, CHILD(ch, j));\n\t                }\n\t            }\n\t        }\n\t    }\n\t    goog.asserts.assert(pos === numStmts(n));\n\t    return seq;\n\t}\n\n\tfunction astForExceptClause (c, exc, body) {\n\t    /* except_clause: 'except' [test [(',' | 'as') test]] */\n\t    var e;\n\t    REQ(exc, SYM.except_clause);\n\t    REQ(body, SYM.suite);\n\t    if (NCH(exc) === 1) {\n\t        return new ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset);\n\t    }\n\t    else if (NCH(exc) === 2) {\n\t        return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset);\n\t    }\n\t    else if (NCH(exc) === 4) {\n\t        e = astForExpr(c, CHILD(exc, 3));\n\t        setContext(c, e, Store, CHILD(exc, 3));\n\t        return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset);\n\t    }\n\t    goog.asserts.fail(\"wrong number of children for except clause\");\n\t}\n\n\tfunction astForTryStmt (c, n) {\n\t    var exceptSt;\n\t    var i;\n\t    var handlers;\n\t    var nc = NCH(n);\n\t    var nexcept = (nc - 3) / 3;\n\t    var body, orelse = [],\n\t        finally_ = null;\n\n\t    REQ(n, SYM.try_stmt);\n\t    body = astForSuite(c, CHILD(n, 2));\n\t    if (CHILD(n, nc - 3).type === TOK.T_NAME) {\n\t        if (CHILD(n, nc - 3).value === \"finally\") {\n\t            if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {\n\t                /* we can assume it's an \"else\",\n\t                 because nc >= 9 for try-else-finally and\n\t                 it would otherwise have a type of except_clause */\n\t                orelse = astForSuite(c, CHILD(n, nc - 4));\n\t                nexcept--;\n\t            }\n\n\t            finally_ = astForSuite(c, CHILD(n, nc - 1));\n\t            nexcept--;\n\t        }\n\t        else {\n\t            /* we can assume it's an \"else\",\n\t             otherwise it would have a type of except_clause */\n\t            orelse = astForSuite(c, CHILD(n, nc - 1));\n\t            nexcept--;\n\t        }\n\t    }\n\t    else if (CHILD(n, nc - 3).type !== SYM.except_clause) {\n\t        throw new Sk.builtin.SyntaxError(\"malformed 'try' statement\", c.c_filename, n.lineno);\n\t    }\n\n\t    if (nexcept > 0) {\n\t        handlers = [];\n\t        for (i = 0; i < nexcept; ++i) {\n\t            handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));\n\t        }\n\t        exceptSt = new TryExcept(body, handlers, orelse, n.lineno, n.col_offset);\n\n\t        if (!finally_) {\n\t            return exceptSt;\n\t        }\n\n\t        /* if a 'finally' is present too, we nest the TryExcept within a\n\t         TryFinally to emulate try ... except ... finally */\n\t        body = [exceptSt];\n\t    }\n\n\t    goog.asserts.assert(finally_ !== null);\n\t    return new TryFinally(body, finally_, n.lineno, n.col_offset);\n\t}\n\n\n\tfunction astForDottedName (c, n) {\n\t    var i;\n\t    var e;\n\t    var id;\n\t    var col_offset;\n\t    var lineno;\n\t    REQ(n, SYM.dotted_name);\n\t    lineno = n.lineno;\n\t    col_offset = n.col_offset;\n\t    id = strobj(CHILD(n, 0).value);\n\t    e = new Name(id, Load, lineno, col_offset);\n\t    for (i = 2; i < NCH(n); i += 2) {\n\t        id = strobj(CHILD(n, i).value);\n\t        e = new Attribute(e, id, Load, lineno, col_offset);\n\t    }\n\t    return e;\n\t}\n\n\tfunction astForDecorator (c, n) {\n\t    /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */\n\t    var nameExpr;\n\t    REQ(n, SYM.decorator);\n\t    REQ(CHILD(n, 0), TOK.T_AT);\n\t    REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);\n\t    nameExpr = astForDottedName(c, CHILD(n, 1));\n\t    if (NCH(n) === 3) // no args\n\t    {\n\t        return nameExpr;\n\t    }\n\t    else if (NCH(n) === 5) // call with no args\n\t    {\n\t        return new Call(nameExpr, [], [], null, null, n.lineno, n.col_offset);\n\t    }\n\t    else {\n\t        return astForCall(c, CHILD(n, 3), nameExpr);\n\t    }\n\t}\n\n\tfunction astForDecorators (c, n) {\n\t    var i;\n\t    var decoratorSeq;\n\t    REQ(n, SYM.decorators);\n\t    decoratorSeq = [];\n\t    for (i = 0; i < NCH(n); ++i) {\n\t        decoratorSeq[i] = astForDecorator(c, CHILD(n, i));\n\t    }\n\t    return decoratorSeq;\n\t}\n\n\tfunction astForDecorated (c, n) {\n\t    var thing;\n\t    var decoratorSeq;\n\t    REQ(n, SYM.decorated);\n\t    decoratorSeq = astForDecorators(c, CHILD(n, 0));\n\t    goog.asserts.assert(CHILD(n, 1).type === SYM.funcdef || CHILD(n, 1).type === SYM.classdef);\n\n\t    thing = null;\n\t    if (CHILD(n, 1).type === SYM.funcdef) {\n\t        thing = astForFuncdef(c, CHILD(n, 1), decoratorSeq);\n\t    }\n\t    else if (CHILD(n, 1) === SYM.classdef) {\n\t        thing = astForClassdef(c, CHILD(n, 1), decoratorSeq);\n\t    }\n\t    if (thing) {\n\t        thing.lineno = n.lineno;\n\t        thing.col_offset = n.col_offset;\n\t    }\n\t    return thing;\n\t}\n\n\t//note: with statements need to be updated to 2.7\n\t//see: ast.c lines: 3127 -> 3185\n\n\tfunction astForWithVar (c, n) {\n\t    REQ(n, SYM.with_item);\n\t    return astForExpr(c, CHILD(n, 1));\n\t}\n\n\tfunction astForWithStmt (c, n) {\n\t    /* with_stmt: 'with' test [ with_var ] ':' suite */\n\t    var optionalVars;\n\t    var contextExpr;\n\t    var suiteIndex = 3; // skip with, test, :\n\t    goog.asserts.assert(n.type === SYM.with_stmt);\n\t    contextExpr = astForExpr(c, CHILD(n, 1));\n\t    if (CHILD(n, 2).type === SYM.with_item) {\n\t        optionalVars = astForWithVar(c, CHILD(n, 2));\n\t        setContext(c, optionalVars, Store, n);\n\t        suiteIndex = 4;\n\t    }\n\t    return new With_(contextExpr, optionalVars, astForSuite(c, CHILD(n, suiteIndex)), n.lineno, n.col_offset);\n\t}\n\n\tfunction astForExecStmt (c, n) {\n\t    var expr1, globals = null, locals = null;\n\t    var nchildren = NCH(n);\n\t    goog.asserts.assert(nchildren === 2 || nchildren === 4 || nchildren === 6);\n\n\t    /* exec_stmt: 'exec' expr ['in' test [',' test]] */\n\t    REQ(n, SYM.exec_stmt);\n\t    expr1 = astForExpr(c, CHILD(n, 1));\n\t    if (nchildren >= 4) {\n\t        globals = astForExpr(c, CHILD(n, 3));\n\t    }\n\t    if (nchildren === 6) {\n\t        locals = astForExpr(c, CHILD(n, 5));\n\t    }\n\t    return new Exec(expr1, globals, locals, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForIfStmt (c, n) {\n\t    /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*\n\t     ['else' ':' suite]\n\t     */\n\t    var off;\n\t    var i;\n\t    var orelse;\n\t    var hasElse;\n\t    var nElif;\n\t    var decider;\n\t    var s;\n\t    REQ(n, SYM.if_stmt);\n\t    if (NCH(n) === 4) {\n\t        return new If_(\n\t            astForExpr(c, CHILD(n, 1)),\n\t            astForSuite(c, CHILD(n, 3)),\n\t            [], n.lineno, n.col_offset);\n\t    }\n\n\t    s = CHILD(n, 4).value;\n\t    decider = s.charAt(2); // elSe or elIf\n\t    if (decider === \"s\") {\n\t        return new If_(\n\t            astForExpr(c, CHILD(n, 1)),\n\t            astForSuite(c, CHILD(n, 3)),\n\t            astForSuite(c, CHILD(n, 6)),\n\t            n.lineno, n.col_offset);\n\t    }\n\t    else if (decider === \"i\") {\n\t        nElif = NCH(n) - 4;\n\t        hasElse = false;\n\t        orelse = [];\n\n\t        /* must reference the child nElif+1 since 'else' token is third, not\n\t         * fourth child from the end. */\n\t        if (CHILD(n, nElif + 1).type === TOK.T_NAME &&\n\t            CHILD(n, nElif + 1).value.charAt(2) === \"s\") {\n\t            hasElse = true;\n\t            nElif -= 3;\n\t        }\n\t        nElif /= 4;\n\n\t        if (hasElse) {\n\t            orelse = [\n\t                new If_(\n\t                    astForExpr(c, CHILD(n, NCH(n) - 6)),\n\t                    astForSuite(c, CHILD(n, NCH(n) - 4)),\n\t                    astForSuite(c, CHILD(n, NCH(n) - 1)),\n\t                    CHILD(n, NCH(n) - 6).lineno,\n\t                    CHILD(n, NCH(n) - 6).col_offset)];\n\t            nElif--;\n\t        }\n\n\t        for (i = 0; i < nElif; ++i) {\n\t            off = 5 + (nElif - i - 1) * 4;\n\t            orelse = [\n\t                new If_(\n\t                    astForExpr(c, CHILD(n, off)),\n\t                    astForSuite(c, CHILD(n, off + 2)),\n\t                    orelse,\n\t                    CHILD(n, off).lineno,\n\t                    CHILD(n, off).col_offset)];\n\t        }\n\t        return new If_(\n\t            astForExpr(c, CHILD(n, 1)),\n\t            astForSuite(c, CHILD(n, 3)),\n\t            orelse, n.lineno, n.col_offset);\n\t    }\n\n\t    goog.asserts.fail(\"unexpected token in 'if' statement\");\n\t}\n\n\tfunction astForExprlist (c, n, context) {\n\t    var e;\n\t    var i;\n\t    var seq;\n\t    REQ(n, SYM.exprlist);\n\t    seq = [];\n\t    for (i = 0; i < NCH(n); i += 2) {\n\t        e = astForExpr(c, CHILD(n, i));\n\t        seq[i / 2] = e;\n\t        if (context) {\n\t            setContext(c, e, context, CHILD(n, i));\n\t        }\n\t    }\n\t    return seq;\n\t}\n\n\tfunction astForDelStmt (c, n) {\n\t    /* del_stmt: 'del' exprlist */\n\t    REQ(n, SYM.del_stmt);\n\t    return new Delete_(astForExprlist(c, CHILD(n, 1), Del), n.lineno, n.col_offset);\n\t}\n\n\tfunction astForGlobalStmt (c, n) {\n\t    /* global_stmt: 'global' NAME (',' NAME)* */\n\t    var i;\n\t    var s = [];\n\t    REQ(n, SYM.global_stmt);\n\t    for (i = 1; i < NCH(n); i += 2) {\n\t        s[(i - 1) / 2] = strobj(CHILD(n, i).value);\n\t    }\n\t    return new Global(s, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForAssertStmt (c, n) {\n\t    /* assert_stmt: 'assert' test [',' test] */\n\t    REQ(n, SYM.assert_stmt);\n\t    if (NCH(n) === 2) {\n\t        return new Assert(astForExpr(c, CHILD(n, 1)), null, n.lineno, n.col_offset);\n\t    }\n\t    else if (NCH(n) === 4) {\n\t        return new Assert(astForExpr(c, CHILD(n, 1)), astForExpr(c, CHILD(n, 3)), n.lineno, n.col_offset);\n\t    }\n\t    goog.asserts.fail(\"improper number of parts to assert stmt\");\n\t}\n\n\tfunction aliasForImportName (c, n) {\n\t    /*\n\t     import_as_name: NAME ['as' NAME]\n\t     dotted_as_name: dotted_name ['as' NAME]\n\t     dotted_name: NAME ('.' NAME)*\n\t     */\n\n\t    var i;\n\t    var a;\n\t    var name;\n\t    var str;\n\t    loop: while (true) {\n\t        switch (n.type) {\n\t            case SYM.import_as_name:\n\t                str = null;\n\t                name = strobj(CHILD(n, 0).value);\n\t                if (NCH(n) === 3) {\n\t                    str = CHILD(n, 2).value;\n\t                }\n\t                return new alias(name, str == null ? null : strobj(str));\n\t            case SYM.dotted_as_name:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue loop;\n\t                }\n\t                else {\n\t                    a = aliasForImportName(c, CHILD(n, 0));\n\t                    goog.asserts.assert(!a.asname);\n\t                    a.asname = strobj(CHILD(n, 2).value);\n\t                    return a;\n\t                }\n\t                break;\n\t            case SYM.dotted_name:\n\t                if (NCH(n) === 1) {\n\t                    return new alias(strobj(CHILD(n, 0).value), null);\n\t                }\n\t                else {\n\t                    // create a string of the form a.b.c\n\t                    str = \"\";\n\t                    for (i = 0; i < NCH(n); i += 2) {\n\t                        str += CHILD(n, i).value + \".\";\n\t                    }\n\t                    return new alias(strobj(str.substr(0, str.length - 1)), null);\n\t                }\n\t                break;\n\t            case TOK.T_STAR:\n\t                return new alias(strobj(\"*\"), null);\n\t            default:\n\t                throw new Sk.builtin.SyntaxError(\"unexpected import name\", c.c_filename, n.lineno);\n\t        }\n\t        break;\n\t    }\n\t}\n\n\tfunction astForImportStmt (c, n) {\n\t    /*\n\t     import_stmt: import_name | import_from\n\t     import_name: 'import' dotted_as_names\n\t     import_from: 'from' ('.'* dotted_name | '.') 'import'\n\t     ('*' | '(' import_as_names ')' | import_as_names)\n\t     */\n\t    var modname;\n\t    var idx;\n\t    var nchildren;\n\t    var ndots;\n\t    var mod;\n\t    var i;\n\t    var aliases;\n\t    var col_offset;\n\t    var lineno;\n\t    REQ(n, SYM.import_stmt);\n\t    lineno = n.lineno;\n\t    col_offset = n.col_offset;\n\t    n = CHILD(n, 0);\n\t    if (n.type === SYM.import_name) {\n\t        n = CHILD(n, 1);\n\t        REQ(n, SYM.dotted_as_names);\n\t        aliases = [];\n\t        for (i = 0; i < NCH(n); i += 2) {\n\t            aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\n\t        }\n\t        return new Import_(aliases, lineno, col_offset);\n\t    }\n\t    else if (n.type === SYM.import_from) {\n\t        mod = null;\n\t        ndots = 0;\n\n\t        for (idx = 1; idx < NCH(n); ++idx) {\n\t            if (CHILD(n, idx).type === SYM.dotted_name) {\n\t                mod = aliasForImportName(c, CHILD(n, idx));\n\t                idx++;\n\t                break;\n\t            }\n\t            else if (CHILD(n, idx).type !== TOK.T_DOT) {\n\t                break;\n\t            }\n\t            ndots++;\n\t        }\n\t        ++idx; // skip the import keyword\n\t        switch (CHILD(n, idx).type) {\n\t            case TOK.T_STAR:\n\t                // from ... import\n\t                n = CHILD(n, idx);\n\t                nchildren = 1;\n\t                break;\n\t            case TOK.T_LPAR:\n\t                // from ... import (x, y, z)\n\t                n = CHILD(n, idx + 1);\n\t                nchildren = NCH(n);\n\t                break;\n\t            case SYM.import_as_names:\n\t                // from ... import x, y, z\n\t                n = CHILD(n, idx);\n\t                nchildren = NCH(n);\n\t                if (nchildren % 2 === 0) {\n\t                    throw new Sk.builtin.SyntaxError(\"trailing comma not allowed without surrounding parentheses\", c.c_filename, n.lineno);\n\t                }\n\t                break;\n\t            default:\n\t                throw new Sk.builtin.SyntaxError(\"Unexpected node-type in from-import\", c.c_filename, n.lineno);\n\t        }\n\t        aliases = [];\n\t        if (n.type === TOK.T_STAR) {\n\t            aliases[0] = aliasForImportName(c, n);\n\t        }\n\t        else {\n\t            for (i = 0; i < NCH(n); i += 2) {\n\t                aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\n\t            }\n\t        }\n\t        modname = mod ? mod.name.v : \"\";\n\t        return new ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset);\n\t    }\n\t    throw new Sk.builtin.SyntaxError(\"unknown import statement\", c.c_filename, n.lineno);\n\t}\n\n\tfunction astForTestlistComp(c, n) {\n\t    /* testlist_comp: test ( comp_for | (',' test)* [','] ) */\n\t    /* argument: test [comp_for] */\n\t    goog.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\n\t    if (NCH(n) > 1 && CHILD(n, 1).type === SYM.comp_for) {\n\t        return astForGenExpr(c, n);\n\t    }\n\t    return astForTestlist(c, n);\n\t}\n\n\tfunction astForListcomp (c, n) {\n\t    /* listmaker: test ( list_for | (',' test)* [','] )\n\t     list_for: 'for' exprlist 'in' testlist_safe [list_iter]\n\t     list_iter: list_for | list_if\n\t     list_if: 'if' test [list_iter]\n\t     testlist_safe: test [(',' test)+ [',']]\n\t     */\n\n\t    function countListFors (c, n) {\n\t        var nfors = 0;\n\t        var ch = CHILD(n, 1);\n\t        count_list_for: while (true) {\n\t            nfors++;\n\t            REQ(ch, SYM.list_for);\n\t            if (NCH(ch) === 5) {\n\t                ch = CHILD(ch, 4);\n\t            }\n\t            else {\n\t                return nfors;\n\t            }\n\t            count_list_iter: while (true) {\n\t                REQ(ch, SYM.list_iter);\n\t                ch = CHILD(ch, 0);\n\t                if (ch.type === SYM.list_for) {\n\t                    continue count_list_for;\n\t                }\n\t                else if (ch.type === SYM.list_if) {\n\t                    if (NCH(ch) === 3) {\n\t                        ch = CHILD(ch, 2);\n\t                        continue count_list_iter;\n\t                    }\n\t                    else {\n\t                        return nfors;\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            break;\n\t        }\n\t    }\n\n\t    function countListIfs (c, n) {\n\t        var nifs = 0;\n\t        while (true) {\n\t            REQ(n, SYM.list_iter);\n\t            if (CHILD(n, 0).type === SYM.list_for) {\n\t                return nifs;\n\t            }\n\t            n = CHILD(n, 0);\n\t            REQ(n, SYM.list_if);\n\t            nifs++;\n\t            if (NCH(n) == 2) {\n\t                return nifs;\n\t            }\n\t            n = CHILD(n, 2);\n\t        }\n\t    }\n\n\t    var j;\n\t    var ifs;\n\t    var nifs;\n\t    var lc;\n\t    var expression;\n\t    var t;\n\t    var forch;\n\t    var i;\n\t    var ch;\n\t    var listcomps;\n\t    var nfors;\n\t    var elt;\n\t    REQ(n, SYM.listmaker);\n\t    goog.asserts.assert(NCH(n) > 1);\n\t    elt = astForExpr(c, CHILD(n, 0));\n\t    nfors = countListFors(c, n);\n\t    listcomps = [];\n\t    ch = CHILD(n, 1);\n\t    for (i = 0; i < nfors; ++i) {\n\t        REQ(ch, SYM.list_for);\n\t        forch = CHILD(ch, 1);\n\t        t = astForExprlist(c, forch, Store);\n\t        expression = astForTestlist(c, CHILD(ch, 3));\n\t        if (NCH(forch) === 1) {\n\t            lc = new comprehension(t[0], expression, []);\n\t        }\n\t        else {\n\t            lc = new comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);\n\t        }\n\n\t        if (NCH(ch) === 5) {\n\t            ch = CHILD(ch, 4);\n\t            nifs = countListIfs(c, ch);\n\t            ifs = [];\n\t            for (j = 0; j < nifs; ++j) {\n\t                REQ(ch, SYM.list_iter);\n\t                ch = CHILD(ch, 0);\n\t                REQ(ch, SYM.list_if);\n\t                ifs[j] = astForExpr(c, CHILD(ch, 1));\n\t                if (NCH(ch) === 3) {\n\t                    ch = CHILD(ch, 2);\n\t                }\n\t            }\n\t            if (ch.type === SYM.list_iter) {\n\t                ch = CHILD(ch, 0);\n\t            }\n\t            lc.ifs = ifs;\n\t        }\n\t        listcomps[i] = lc;\n\t    }\n\t    return new ListComp(elt, listcomps, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForFactor (c, n) {\n\t    /* some random peephole thing that cpy does */\n\t    var expression;\n\t    var pnum;\n\t    var patom;\n\t    var ppower;\n\t    var pfactor;\n\t    if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {\n\t        pfactor = CHILD(n, 1);\n\t        if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {\n\t            ppower = CHILD(pfactor, 0);\n\t            if (ppower.type === SYM.power && NCH(ppower) === 1) {\n\t                patom = CHILD(ppower, 0);\n\t                if (patom.type === SYM.atom) {\n\t                    pnum = CHILD(patom, 0);\n\t                    if (pnum.type === TOK.T_NUMBER) {\n\t                        pnum.value = \"-\" + pnum.value;\n\t                        return astForAtom(c, patom);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    expression = astForExpr(c, CHILD(n, 1));\n\t    switch (CHILD(n, 0).type) {\n\t        case TOK.T_PLUS:\n\t            return new UnaryOp(UAdd, expression, n.lineno, n.col_offset);\n\t        case TOK.T_MINUS:\n\t            return new UnaryOp(USub, expression, n.lineno, n.col_offset);\n\t        case TOK.T_TILDE:\n\t            return new UnaryOp(Invert, expression, n.lineno, n.col_offset);\n\t    }\n\n\t    goog.asserts.fail(\"unhandled factor\");\n\t}\n\n\tfunction astForForStmt (c, n) {\n\t    /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */\n\t    var target;\n\t    var _target;\n\t    var nodeTarget;\n\t    var seq = [];\n\t    REQ(n, SYM.for_stmt);\n\t    if (NCH(n) === 9) {\n\t        seq = astForSuite(c, CHILD(n, 8));\n\t    }\n\t    nodeTarget = CHILD(n, 1);\n\t    _target = astForExprlist(c, nodeTarget, Store);\n\t    if (NCH(nodeTarget) === 1) {\n\t        target = _target[0];\n\t    }\n\t    else {\n\t        target = new Tuple(_target, Store, n.lineno, n.col_offset);\n\t    }\n\n\t    return new For_(target,\n\t        astForTestlist(c, CHILD(n, 3)),\n\t        astForSuite(c, CHILD(n, 5)),\n\t        seq, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForCall (c, n, func) {\n\t    /*\n\t      arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]\n\t               | '**' test)\n\t      argument: test [comp_for] | test '=' test       # Really [keyword '='] test\n\t    */\n\t    var tmp;\n\t    var k;\n\t    var key;\n\t    var e;\n\t    var kwarg;\n\t    var vararg;\n\t    var keywords;\n\t    var args;\n\t    var ch;\n\t    var i;\n\t    var ngens;\n\t    var nkeywords;\n\t    var nargs;\n\n\t    REQ(n, SYM.arglist);\n\t    nargs = 0;\n\t    nkeywords = 0;\n\t    ngens = 0;\n\t    for (i = 0; i < NCH(n); i++) {\n\t        ch = CHILD(n, i);\n\t        if (ch.type === SYM.argument) {\n\t            if (NCH(ch) === 1) {\n\t                nargs++;\n\t            }\n\t            else if (CHILD(ch, 1).type === SYM.comp_for) {\n\t                ngens++;\n\t            }\n\t            else {\n\t                nkeywords++;\n\t            }\n\t        }\n\t    }\n\t    if (ngens > 1 || (ngens && (nargs || nkeywords))) {\n\t        throw new Sk.builtin.SyntaxError(\"Generator expression must be parenthesized if not sole argument\", c.c_filename, n.lineno);\n\t    }\n\t    if (nargs + nkeywords + ngens > 255) {\n\t        throw new Sk.builtin.SyntaxError(\"more than 255 arguments\", c.c_filename, n.lineno);\n\t    }\n\t    args = [];\n\t    keywords = [];\n\t    nargs = 0;\n\t    nkeywords = 0;\n\t    vararg = null;\n\t    kwarg = null;\n\t    for (i = 0; i < NCH(n); i++) {\n\t        ch = CHILD(n, i);\n\t        if (ch.type === SYM.argument) {\n\t            if (NCH(ch) === 1) {\n\t                if (nkeywords) {\n\t                    throw new Sk.builtin.SyntaxError(\"non-keyword arg after keyword arg\", c.c_filename, n.lineno);\n\t                }\n\t                if (vararg) {\n\t                    throw new Sk.builtin.SyntaxError(\"only named arguments may follow *expression\", c.c_filename, n.lineno);\n\t                }\n\t                args[nargs++] = astForExpr(c, CHILD(ch, 0));\n\t            }\n\t            else if (CHILD(ch, 1).type === SYM.comp_for) {\n\t                args[nargs++] = astForGenExpr(c, ch);\n\t            }\n\t            else {\n\t                e = astForExpr(c, CHILD(ch, 0));\n\t                if (e.constructor === Lambda) {\n\t                    throw new Sk.builtin.SyntaxError(\"lambda cannot contain assignment\", c.c_filename, n.lineno);\n\t                }\n\t                else if (e.constructor !== Name) {\n\t                    throw new Sk.builtin.SyntaxError(\"keyword can't be an expression\", c.c_filename, n.lineno);\n\t                }\n\t                key = e.id;\n\t                forbiddenCheck(c, CHILD(ch, 0), key, n.lineno);\n\t                for (k = 0; k < nkeywords; ++k) {\n\t                    tmp = keywords[k].arg;\n\t                    if (tmp === key) {\n\t                        throw new Sk.builtin.SyntaxError(\"keyword argument repeated\", c.c_filename, n.lineno);\n\t                    }\n\t                }\n\t                keywords[nkeywords++] = new keyword(key, astForExpr(c, CHILD(ch, 2)));\n\t            }\n\t        }\n\t        else if (ch.type === TOK.T_STAR) {\n\t            vararg = astForExpr(c, CHILD(n, ++i));\n\t        }\n\t        else if (ch.type === TOK.T_DOUBLESTAR) {\n\t            kwarg = astForExpr(c, CHILD(n, ++i));\n\t        }\n\t    }\n\t    return new Call(func, args, keywords, vararg, kwarg, func.lineno, func.col_offset);\n\t}\n\n\tfunction astForTrailer (c, n, leftExpr) {\n\t    /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME \n\t     subscriptlist: subscript (',' subscript)* [',']\n\t     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n\t     */\n\t    var e;\n\t    var elts;\n\t    var slc;\n\t    var j;\n\t    var slices;\n\t    var simple;\n\t    REQ(n, SYM.trailer);\n\t    if (CHILD(n, 0).type === TOK.T_LPAR) {\n\t        if (NCH(n) === 2) {\n\t            return new Call(leftExpr, [], [], null, null, n.lineno, n.col_offset);\n\t        }\n\t        else {\n\t            return astForCall(c, CHILD(n, 1), leftExpr);\n\t        }\n\t    }\n\t    else if (CHILD(n, 0).type === TOK.T_DOT) {\n\t        return new Attribute(leftExpr, strobj(CHILD(n, 1).value), Load, n.lineno, n.col_offset);\n\t    }\n\t    else {\n\t        REQ(CHILD(n, 0), TOK.T_LSQB);\n\t        REQ(CHILD(n, 2), TOK.T_RSQB);\n\t        n = CHILD(n, 1);\n\t        if (NCH(n) === 1) {\n\t            return new Subscript(leftExpr, astForSlice(c, CHILD(n, 0)), Load, n.lineno, n.col_offset);\n\t        }\n\t        else {\n\t            /* The grammar is ambiguous here. The ambiguity is resolved \n\t             by treating the sequence as a tuple literal if there are\n\t             no slice features.\n\t             */\n\t            simple = true;\n\t            slices = [];\n\t            for (j = 0; j < NCH(n); j += 2) {\n\t                slc = astForSlice(c, CHILD(n, j));\n\t                if (slc.constructor !== Index) {\n\t                    simple = false;\n\t                }\n\t                slices[j / 2] = slc;\n\t            }\n\t            if (!simple) {\n\t                return new Subscript(leftExpr, new ExtSlice(slices), Load, n.lineno, n.col_offset);\n\t            }\n\t            elts = [];\n\t            for (j = 0; j < slices.length; ++j) {\n\t                slc = slices[j];\n\t                goog.asserts.assert(slc.constructor === Index && slc.value !== null && slc.value !== undefined);\n\t                elts[j] = slc.value;\n\t            }\n\t            e = new Tuple(elts, Load, n.lineno, n.col_offset);\n\t            return new Subscript(leftExpr, new Index(e), Load, n.lineno, n.col_offset);\n\t        }\n\t    }\n\t}\n\n\tfunction astForFlowStmt (c, n) {\n\t    /*\n\t     flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n\t     | yield_stmt\n\t     break_stmt: 'break'\n\t     continue_stmt: 'continue'\n\t     return_stmt: 'return' [testlist]\n\t     yield_stmt: yield_expr\n\t     yield_expr: 'yield' testlist\n\t     raise_stmt: 'raise' [test [',' test [',' test]]]\n\t     */\n\t    var ch;\n\t    REQ(n, SYM.flow_stmt);\n\t    ch = CHILD(n, 0);\n\t    switch (ch.type) {\n\t        case SYM.break_stmt:\n\t            return new Break_(n.lineno, n.col_offset);\n\t        case SYM.continue_stmt:\n\t            return new Continue_(n.lineno, n.col_offset);\n\t        case SYM.yield_stmt:\n\t            return new Expr(astForExpr(c, CHILD(ch, 0)), n.lineno, n.col_offset);\n\t        case SYM.return_stmt:\n\t            if (NCH(ch) === 1) {\n\t                return new Return_(null, n.lineno, n.col_offset);\n\t            }\n\t            else {\n\t                return new Return_(astForTestlist(c, CHILD(ch, 1)), n.lineno, n.col_offset);\n\t            }\n\t            break;\n\t        case SYM.raise_stmt:\n\t            if (NCH(ch) === 1) {\n\t                return new Raise(null, null, null, n.lineno, n.col_offset);\n\t            }\n\t            else if (NCH(ch) === 2) {\n\t                return new Raise(astForExpr(c, CHILD(ch, 1)), null, null, n.lineno, n.col_offset);\n\t            }\n\t            else if (NCH(ch) === 4) {\n\t                return new Raise(\n\t                    astForExpr(c, CHILD(ch, 1)),\n\t                    astForExpr(c, CHILD(ch, 3)),\n\t                    null, n.lineno, n.col_offset);\n\t            }\n\t            else if (NCH(ch) === 6) {\n\t                return new Raise(\n\t                    astForExpr(c, CHILD(ch, 1)),\n\t                    astForExpr(c, CHILD(ch, 3)),\n\t                    astForExpr(c, CHILD(ch, 5)),\n\t                    n.lineno, n.col_offset);\n\t            }\n\t            break;\n\t        default:\n\t            goog.asserts.fail(\"unexpected flow_stmt\");\n\t    }\n\t    goog.asserts.fail(\"unhandled flow statement\");\n\t}\n\n\tfunction astForArguments (c, n) {\n\t    /* parameters: '(' [varargslist] ')'\n\t     varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME]\n\t     | '**' NAME) | fpdef ['=' test] (',' fpdef ['=' test])* [',']\n\t     */\n\t    var parenthesized;\n\t    var id;\n\t    var complexArgs;\n\t    var k;\n\t    var j;\n\t    var i;\n\t    var foundDefault;\n\t    var defaults;\n\t    var args;\n\t    var ch;\n\t    var vararg = null;\n\t    var kwarg = null;\n\t    if (n.type === SYM.parameters) {\n\t        if (NCH(n) === 2) // () as arglist\n\t        {\n\t            return new arguments_([], null, null, []);\n\t        }\n\t        n = CHILD(n, 1);\n\t    }\n\t    REQ(n, SYM.varargslist);\n\n\t    args = [];\n\t    defaults = [];\n\n\t    /* fpdef: NAME | '(' fplist ')'\n\t     fplist: fpdef (',' fpdef)* [',']\n\t     */\n\t    foundDefault = false;\n\t    i = 0;\n\t    j = 0; // index for defaults\n\t    k = 0; // index for args\n\t    while (i < NCH(n)) {\n\t        ch = CHILD(n, i);\n\t        switch (ch.type) {\n\t            case SYM.fpdef:\n\t                complexArgs = 0;\n\t                parenthesized = 0;\n\t                handle_fpdef: while (true) {\n\t                    if (i + 1 < NCH(n) && CHILD(n, i + 1).type === TOK.T_EQUAL) {\n\t                        defaults[j++] = astForExpr(c, CHILD(n, i + 2));\n\t                        i += 2;\n\t                        foundDefault = true;\n\t                    }\n\t                    else if (foundDefault) {\n\t                        /* def f((x)=4): pass should raise an error.\n\t                         def f((x, (y))): pass will just incur the tuple unpacking warning. */\n\t                        if (parenthesized && !complexArgs) {\n\t                            throw new Sk.builtin.SyntaxError(\"parenthesized arg with default\", c.c_filename, n.lineno);\n\t                        }\n\t                        throw new Sk.builtin.SyntaxError(\"non-default argument follows default argument\", c.c_filename, n.lineno);\n\t                    }\n\n\t                    if (NCH(ch) === 3) {\n\t                        ch = CHILD(ch, 1);\n\t                        // def foo((x)): is not complex, special case.\n\t                        if (NCH(ch) !== 1) {\n\t                            throw new Sk.builtin.SyntaxError(\"tuple parameter unpacking has been removed\", c.c_filename, n.lineno);\n\t                        }\n\t                        else {\n\t                            /* def foo((x)): setup for checking NAME below. */\n\t                            /* Loop because there can be many parens and tuple\n\t                             unpacking mixed in. */\n\t                            parenthesized = true;\n\t                            ch = CHILD(ch, 0);\n\t                            goog.asserts.assert(ch.type === SYM.fpdef);\n\t                            continue handle_fpdef;\n\t                        }\n\t                    }\n\t                    if (CHILD(ch, 0).type === TOK.T_NAME) {\n\t                        forbiddenCheck(c, n, CHILD(ch, 0).value, n.lineno);\n\t                        id = strobj(CHILD(ch, 0).value);\n\t                        args[k++] = new Name(id, Param, ch.lineno, ch.col_offset);\n\t                    }\n\t                    i += 2;\n\t                    if (parenthesized) {\n\t                        throw new Sk.builtin.SyntaxError(\"parenthesized argument names are invalid\", c.c_filename, n.lineno);\n\t                    }\n\t                    break;\n\t                }\n\t                break;\n\t            case TOK.T_STAR:\n\t                forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);\n\t                vararg = strobj(CHILD(n, i + 1).value);\n\t                i += 3;\n\t                break;\n\t            case TOK.T_DOUBLESTAR:\n\t                forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);\n\t                kwarg = strobj(CHILD(n, i + 1).value);\n\t                i += 3;\n\t                break;\n\t            default:\n\t                goog.asserts.fail(\"unexpected node in varargslist\");\n\t        }\n\t    }\n\t    return new arguments_(args, vararg, kwarg, defaults);\n\t}\n\n\tfunction astForFuncdef (c, n, decoratorSeq) {\n\t    /* funcdef: 'def' NAME parameters ':' suite */\n\t    var body;\n\t    var args;\n\t    var name;\n\t    REQ(n, SYM.funcdef);\n\t    name = strobj(CHILD(n, 1).value);\n\t    forbiddenCheck(c, CHILD(n, 1), CHILD(n, 1).value, n.lineno);\n\t    args = astForArguments(c, CHILD(n, 2));\n\t    body = astForSuite(c, CHILD(n, 4));\n\t    return new FunctionDef(name, args, body, decoratorSeq, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForClassBases (c, n) {\n\t    /* testlist: test (',' test)* [','] */\n\t    goog.asserts.assert(NCH(n) > 0);\n\t    REQ(n, SYM.testlist);\n\t    if (NCH(n) === 1) {\n\t        return [ astForExpr(c, CHILD(n, 0)) ];\n\t    }\n\t    return seqForTestlist(c, n);\n\t}\n\n\tfunction astForClassdef (c, n, decoratorSeq) {\n\t    /* classdef: 'class' NAME ['(' testlist ')'] ':' suite */\n\t    var s;\n\t    var bases;\n\t    var classname;\n\t    REQ(n, SYM.classdef);\n\t    forbiddenCheck(c, n, CHILD(n, 1).value, n.lineno);\n\t    classname = strobj(CHILD(n, 1).value);\n\t    if (NCH(n) === 4) {\n\t        return new ClassDef(classname, [], astForSuite(c, CHILD(n, 3)), decoratorSeq, n.lineno, n.col_offset);\n\t    }\n\t    if (CHILD(n, 3).type === TOK.T_RPAR) {\n\t        return new ClassDef(classname, [], astForSuite(c, CHILD(n, 5)), decoratorSeq, n.lineno, n.col_offset);\n\t    }\n\n\t    bases = astForClassBases(c, CHILD(n, 3));\n\t    s = astForSuite(c, CHILD(n, 6));\n\t    return new ClassDef(classname, bases, s, decoratorSeq, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForLambdef (c, n) {\n\t    /* lambdef: 'lambda' [varargslist] ':' test */\n\t    var args;\n\t    var expression;\n\t    if (NCH(n) === 3) {\n\t        args = new arguments_([], null, null, []);\n\t        expression = astForExpr(c, CHILD(n, 2));\n\t    }\n\t    else {\n\t        args = astForArguments(c, CHILD(n, 1));\n\t        expression = astForExpr(c, CHILD(n, 3));\n\t    }\n\t    return new Lambda(args, expression, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForComprehension(c, n) {\n\t    /* testlist_comp: test ( comp_for | (',' test)* [','] )\n\t       argument: test [comp_for] | test '=' test       # Really [keyword '='] test */\n\t    \n\t    var j;\n\t    var ifs;\n\t    var nifs;\n\t    var ge;\n\t    var expression;\n\t    var t;\n\t    var forch;\n\t    var i;\n\t    var ch;\n\t    var genexps;\n\t    var nfors;\n\t    var elt;\n\t    var comps;\n\t    var comp;\n\n\t    function countCompFors(c, n) {\n\t        var nfors = 0;\n\t        count_comp_for: while (true) {\n\t            nfors++;\n\t            REQ(n, SYM.comp_for);\n\t            if (NCH(n) === 5) {\n\t                n = CHILD(n, 4);\n\t            } else {\n\t                return nfors;\n\t            }\n\t            count_comp_iter: while (true) {\n\t                REQ(n, SYM.comp_iter);\n\t                n = CHILD(n, 0);\n\t                if (n.type === SYM.comp_for) {\n\t                    continue count_comp_for;\n\t                } else if (n.type === SYM.comp_if) {\n\t                    if (NCH(n) === 3) {\n\t                        n = CHILD(n, 2);\n\t                        continue count_comp_iter;\n\t                    } else {\n\t                        return nfors;\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            break;\n\t        }\n\t        goog.asserts.fail(\"logic error in countCompFors\");\n\t    }\n\n\t    function countCompIfs(c, n) {\n\t        var nifs = 0;\n\t        while (true) {\n\t            REQ(n, SYM.comp_iter);\n\t            if (CHILD(n, 0).type === SYM.comp_for) {\n\t                return nifs;\n\t            }\n\t            n = CHILD(n, 0);\n\t            REQ(n, SYM.comp_if);\n\t            nifs++;\n\t            if (NCH(n) == 2) {\n\t                return nifs;\n\t            }\n\t            n = CHILD(n, 2);\n\t        }\n\t    }\n\n\t    nfors = countCompFors(c, n);\n\t    comps = [];\n\t    for (i = 0; i < nfors; ++i) {\n\t        REQ(n, SYM.comp_for);\n\t        forch = CHILD(n, 1);\n\t        t = astForExprlist(c, forch, Store);\n\t        expression = astForExpr(c, CHILD(n, 3));\n\t        if (NCH(forch) === 1) {\n\t            comp = new comprehension(t[0], expression, []);\n\t        } else {\n\t            comp = new comprehension(new Tuple(t, Store, n.lineno, n.col_offset), expression, []);\n\t        }\n\t        if (NCH(n) === 5) {\n\t            n = CHILD(n, 4);\n\t            nifs = countCompIfs(c, n);\n\t            ifs = [];\n\t            for (j = 0; j < nifs; ++j) {\n\t                REQ(n, SYM.comp_iter);\n\t                n = CHILD(n, 0);\n\t                REQ(n, SYM.comp_if);\n\t                expression = astForExpr(c, CHILD(n, 1));\n\t                ifs[j] = expression;\n\t                if (NCH(n) === 3) {\n\t                    n = CHILD(n, 2);\n\t                }\n\t            }\n\t            if (n.type === SYM.comp_iter) {\n\t                n = CHILD(n, 0);\n\t            }\n\t            comp.ifs = ifs;\n\t        }\n\t        comps[i] = comp;\n\t    }\n\t    return comps;\n\t}\n\n\tfunction astForIterComp(c, n, type) {\n\t    var elt, comps;\n\t    goog.asserts.assert(NCH(n) > 1);\n\t    elt = astForExpr(c, CHILD(n, 0));\n\t    comps = astForComprehension(c, CHILD(n, 1));\n\t    if (type === COMP_GENEXP) {\n\t        return new GeneratorExp(elt, comps, n.lineno, n.col_offset);\n\t    } else if (type === COMP_SETCOMP) {\n\t        return new SetComp(elt, comps, n.lineno, n.col_offset);\n\t    }\n\t}\n\n\tfunction astForDictComp(c, n) {\n\t    var key, value;\n\t    var comps = [];\n\t    goog.asserts.assert(NCH(n) > 3);\n\t    REQ(CHILD(n, 1), TOK.T_COLON);\n\t    key = astForExpr(c, CHILD(n, 0));\n\t    value = astForExpr(c, CHILD(n, 2));\n\t    comps = astForComprehension(c, CHILD(n, 3));\n\t    return new DictComp(key, value, comps, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForGenExpr(c, n) {\n\t    goog.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\n\t    return astForIterComp(c, n, COMP_GENEXP);\n\t}\n\n\tfunction astForSetComp(c, n) {\n\t    goog.asserts.assert(n.type === SYM.dictorsetmaker);\n\t    return astForIterComp(c, n, COMP_SETCOMP);\n\t}\n\n\tfunction astForWhileStmt (c, n) {\n\t    /* while_stmt: 'while' test ':' suite ['else' ':' suite] */\n\t    REQ(n, SYM.while_stmt);\n\t    if (NCH(n) === 4) {\n\t        return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);\n\t    }\n\t    else if (NCH(n) === 7) {\n\t        return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);\n\t    }\n\t    goog.asserts.fail(\"wrong number of tokens for 'while' stmt\");\n\t}\n\n\tfunction astForAugassign (c, n) {\n\t    REQ(n, SYM.augassign);\n\t    n = CHILD(n, 0);\n\t    switch (n.value.charAt(0)) {\n\t        case \"+\":\n\t            return Add;\n\t        case \"-\":\n\t            return Sub;\n\t        case \"/\":\n\t            if (n.value.charAt(1) === \"/\") {\n\t                return FloorDiv;\n\t            }\n\t            return Div;\n\t        case \"%\":\n\t            return Mod;\n\t        case \"<\":\n\t            return LShift;\n\t        case \">\":\n\t            return RShift;\n\t        case \"&\":\n\t            return BitAnd;\n\t        case \"^\":\n\t            return BitXor;\n\t        case \"|\":\n\t            return BitOr;\n\t        case \"*\":\n\t            if (n.value.charAt(1) === \"*\") {\n\t                return Pow;\n\t            }\n\t            return Mult;\n\t        default:\n\t            goog.asserts.fail(\"invalid augassign\");\n\t    }\n\t}\n\n\tfunction astForBinop (c, n) {\n\t    /* Must account for a sequence of expressions.\n\t     How should A op B op C by represented?\n\t     BinOp(BinOp(A, op, B), op, C).\n\t     */\n\t    var tmp;\n\t    var newoperator;\n\t    var nextOper;\n\t    var i;\n\t    var result = new BinOp(\n\t        astForExpr(c, CHILD(n, 0)),\n\t        getOperator(CHILD(n, 1)),\n\t        astForExpr(c, CHILD(n, 2)),\n\t        n.lineno, n.col_offset);\n\t    var nops = (NCH(n) - 1) / 2;\n\t    for (i = 1; i < nops; ++i) {\n\t        nextOper = CHILD(n, i * 2 + 1);\n\t        newoperator = getOperator(nextOper);\n\t        tmp = astForExpr(c, CHILD(n, i * 2 + 2));\n\t        result = new BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset);\n\t    }\n\t    return result;\n\n\t}\n\n\n\tfunction astForTestlist(c, n) {\n\t    /* this doesn't show up in Grammar.txt never did: testlist_gexp: test (',' test)* [','] */\n\t    /* testlist_comp: test (',' test)* [','] */\n\t    /* testlist: test (',' test)* [','] */\n\t    /* testlist_safe: test (',' test)+ [','] */\n\t    /* testlist1: test (',' test)* */\n\t    goog.asserts.assert(NCH(n) > 0);\n\t    if (n.type === SYM.testlist_comp) {\n\t        if (NCH(n) > 1) {\n\t            goog.asserts.assert(CHILD(n, 1).type !== SYM.comp_for);\n\t        }\n\t    }\n\t    else {\n\t        goog.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_safe || n.type === SYM.testlist1);\n\t    }\n\n\t    if (NCH(n) === 1) {\n\t        return astForExpr(c, CHILD(n, 0));\n\t    }\n\t    else {\n\t        return new Tuple(seqForTestlist(c, n), Load, n.lineno, n.col_offset);\n\t    }\n\n\t}\n\n\tfunction astForExprStmt (c, n) {\n\t    var expression;\n\t    var value;\n\t    var e;\n\t    var i;\n\t    var targets;\n\t    var expr2;\n\t    var varName;\n\t    var expr1;\n\t    var ch;\n\t    REQ(n, SYM.expr_stmt);\n\t    /* expr_stmt: testlist (augassign (yield_expr|testlist) \n\t     | ('=' (yield_expr|testlist))*)\n\t     testlist: test (',' test)* [',']\n\t     augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='\n\t     | '<<=' | '>>=' | '**=' | '//='\n\t     test: ... here starts the operator precendence dance\n\t     */\n\t    if (NCH(n) === 1) {\n\t        return new Expr(astForTestlist(c, CHILD(n, 0)), n.lineno, n.col_offset);\n\t    }\n\t    else if (CHILD(n, 1).type === SYM.augassign) {\n\t        ch = CHILD(n, 0);\n\t        expr1 = astForTestlist(c, ch);\n\t        switch (expr1.constructor) {\n\t            case GeneratorExp:\n\t                throw new Sk.builtin.SyntaxError(\"augmented assignment to generator expression not possible\", c.c_filename, n.lineno);\n\t            case Yield:\n\t                throw new Sk.builtin.SyntaxError(\"augmented assignment to yield expression not possible\", c.c_filename, n.lineno);\n\t            case Name:\n\t                varName = expr1.id;\n\t                forbiddenCheck(c, ch, varName, n.lineno);\n\t                break;\n\t            case Attribute:\n\t            case Subscript:\n\t                break;\n\t            default:\n\t                throw new Sk.builtin.SyntaxError(\"illegal expression for augmented assignment\", c.c_filename, n.lineno);\n\t        }\n\t        setContext(c, expr1, Store, ch);\n\n\t        ch = CHILD(n, 2);\n\t        if (ch.type === SYM.testlist) {\n\t            expr2 = astForTestlist(c, ch);\n\t        }\n\t        else {\n\t            expr2 = astForExpr(c, ch);\n\t        }\n\n\t        return new AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset);\n\t    }\n\t    else {\n\t        // normal assignment\n\t        REQ(CHILD(n, 1), TOK.T_EQUAL);\n\t        targets = [];\n\t        for (i = 0; i < NCH(n) - 2; i += 2) {\n\t            ch = CHILD(n, i);\n\t            if (ch.type === SYM.yield_expr) {\n\t                throw new Sk.builtin.SyntaxError(\"assignment to yield expression not possible\", c.c_filename, n.lineno);\n\t            }\n\t            e = astForTestlist(c, ch);\n\t            setContext(c, e, Store, CHILD(n, i));\n\t            targets[i / 2] = e;\n\t        }\n\t        value = CHILD(n, NCH(n) - 1);\n\t        if (value.type === SYM.testlist) {\n\t            expression = astForTestlist(c, value);\n\t        }\n\t        else {\n\t            expression = astForExpr(c, value);\n\t        }\n\t        return new Assign(targets, expression, n.lineno, n.col_offset);\n\t    }\n\t}\n\n\tfunction astForIfexpr (c, n) {\n\t    /* test: or_test 'if' or_test 'else' test */\n\t    goog.asserts.assert(NCH(n) === 5);\n\t    return new IfExp(\n\t        astForExpr(c, CHILD(n, 2)),\n\t        astForExpr(c, CHILD(n, 0)),\n\t        astForExpr(c, CHILD(n, 4)),\n\t        n.lineno, n.col_offset);\n\t}\n\n\t/**\n\t * s is a python-style string literal, including quote characters and u/r/b\n\t * prefixes. Returns decoded string object.\n\t */\n\tfunction parsestr (c, s) {\n\t    var encodeUtf8 = function (s) {\n\t        return unescape(encodeURIComponent(s));\n\t    };\n\t    var decodeUtf8 = function (s) {\n\t        return decodeURIComponent(escape(s));\n\t    };\n\t    var decodeEscape = function (s, quote) {\n\t        var d3;\n\t        var d2;\n\t        var d1;\n\t        var d0;\n\t        var c;\n\t        var i;\n\t        var len = s.length;\n\t        var ret = \"\";\n\t        for (i = 0; i < len; ++i) {\n\t            c = s.charAt(i);\n\t            if (c === \"\\\\\") {\n\t                ++i;\n\t                c = s.charAt(i);\n\t                if (c === \"n\") {\n\t                    ret += \"\\n\";\n\t                }\n\t                else if (c === \"\\\\\") {\n\t                    ret += \"\\\\\";\n\t                }\n\t                else if (c === \"t\") {\n\t                    ret += \"\\t\";\n\t                }\n\t                else if (c === \"r\") {\n\t                    ret += \"\\r\";\n\t                }\n\t                else if (c === \"b\") {\n\t                    ret += \"\\b\";\n\t                }\n\t                else if (c === \"f\") {\n\t                    ret += \"\\f\";\n\t                }\n\t                else if (c === \"v\") {\n\t                    ret += \"\\v\";\n\t                }\n\t                else if (c === \"0\") {\n\t                    ret += \"\\0\";\n\t                }\n\t                else if (c === '\"') {\n\t                    ret += '\"';\n\t                }\n\t                else if (c === '\\'') {\n\t                    ret += '\\'';\n\t                }\n\t                else if (c === \"\\n\") /* escaped newline, join lines */ {\n\t                }\n\t                else if (c === \"x\") {\n\t                    d0 = s.charAt(++i);\n\t                    d1 = s.charAt(++i);\n\t                    ret += String.fromCharCode(parseInt(d0 + d1, 16));\n\t                }\n\t                else if (c === \"u\" || c === \"U\") {\n\t                    d0 = s.charAt(++i);\n\t                    d1 = s.charAt(++i);\n\t                    d2 = s.charAt(++i);\n\t                    d3 = s.charAt(++i);\n\t                    ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));\n\t                }\n\t                else {\n\t                    // Leave it alone\n\t                    ret += \"\\\\\" + c;\n\t                    // goog.asserts.fail(\"unhandled escape: '\" + c.charCodeAt(0) + \"'\");\n\t                }\n\t            }\n\t            else {\n\t                ret += c;\n\t            }\n\t        }\n\t        return ret;\n\t    };\n\n\t    //print(\"parsestr\", s);\n\n\t    var quote = s.charAt(0);\n\t    var rawmode = false;\n\t    var unicode = false;\n\n\t    // treats every sequence as unicodes even if they are not treated with uU prefix\n\t    // kinda hacking though working for most purposes\n\t    if((c.c_flags & Parser.CO_FUTURE_UNICODE_LITERALS || Sk.python3 === true)) {\n\t        unicode = true;\n\t    }\n\n\t    if (quote === \"u\" || quote === \"U\") {\n\t        s = s.substr(1);\n\t        quote = s.charAt(0);\n\t        unicode = true;\n\t    }\n\t    else if (quote === \"r\" || quote === \"R\") {\n\t        s = s.substr(1);\n\t        quote = s.charAt(0);\n\t        rawmode = true;\n\t    }\n\t    goog.asserts.assert(quote !== \"b\" && quote !== \"B\", \"todo; haven't done b'' strings yet\");\n\n\t    goog.asserts.assert(quote === \"'\" || quote === '\"' && s.charAt(s.length - 1) === quote);\n\t    s = s.substr(1, s.length - 2);\n\t    if (unicode) {\n\t        s = encodeUtf8(s);\n\t    }\n\n\t    if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {\n\t        goog.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);\n\t        s = s.substr(2, s.length - 4);\n\t    }\n\n\t    if (rawmode || s.indexOf(\"\\\\\") === -1) {\n\t        return strobj(decodeUtf8(s));\n\t    }\n\t    return strobj(decodeEscape(s, quote));\n\t}\n\n\tfunction parsestrplus (c, n) {\n\t    var i;\n\t    var ret;\n\t    REQ(CHILD(n, 0), TOK.T_STRING);\n\t    ret = new Sk.builtin.str(\"\");\n\t    for (i = 0; i < NCH(n); ++i) {\n\t        try {\n\t            ret = ret.sq$concat(parsestr(c, CHILD(n, i).value));\n\t        } catch (x) {\n\t            throw new Sk.builtin.SyntaxError(\"invalid string (possibly contains a unicode character)\", c.c_filename, CHILD(n, i).lineno);\n\t        }\n\t    }\n\t    return ret;\n\t}\n\n\tfunction parsenumber (c, s, lineno) {\n\t    var neg;\n\t    var val;\n\t    var tmp;\n\t    var end = s.charAt(s.length - 1);\n\n\t    // call internal complex type constructor for complex strings\n\t    if (end === \"j\" || end === \"J\") {\n\t        return Sk.builtin.complex.complex_subtype_from_string(s);\n\t    }\n\n\t    // Handle longs\n\t    if (end === \"l\" || end === \"L\") {\n\t        return Sk.longFromStr(s.substr(0, s.length - 1), 0);\n\t    }\n\n\t    // todo; we don't currently distinguish between int and float so\n\t    // str is wrong for these.\n\t    if (s.indexOf(\".\") !== -1) {\n\t        return new Sk.builtin.float_(parseFloat(s));\n\t    }\n\n\t    // Handle integers of various bases\n\t    tmp = s;\n\t    neg = false;\n\t    if (s.charAt(0) === \"-\") {\n\t        tmp = s.substr(1);\n\t        neg = true;\n\t    }\n\n\t    if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"x\" || tmp.charAt(1) === \"X\")) {\n\t        // Hex\n\t        tmp = tmp.substring(2);\n\t        val = parseInt(tmp, 16);\n\t    } else if ((s.indexOf(\"e\") !== -1) || (s.indexOf(\"E\") !== -1)) {\n\t        // Float with exponent (needed to make sure e/E wasn't hex first)\n\t        return new Sk.builtin.float_(parseFloat(s));\n\t    } else if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"b\" || tmp.charAt(1) === \"B\")) {\n\t        // Binary\n\t        tmp = tmp.substring(2);\n\t        val = parseInt(tmp, 2);\n\t    } else if (tmp.charAt(0) === \"0\") {\n\t        if (tmp === \"0\") {\n\t            // Zero\n\t            val = 0;\n\t        } else {\n\t            // Octal\n\t            tmp = tmp.substring(1);\n\t            if ((tmp.charAt(0) === \"o\") || (tmp.charAt(0) === \"O\")) {\n\t                tmp = tmp.substring(1);\n\t            }\n\t            val = parseInt(tmp, 8);\n\t        }\n\t    }\n\t    else {\n\t        // Decimal\n\t        val = parseInt(tmp, 10);\n\t    }\n\n\t    // Convert to long\n\t    if (val > Sk.builtin.int_.threshold$ &&\n\t        Math.floor(val) === val &&\n\t        (s.indexOf(\"e\") === -1 && s.indexOf(\"E\") === -1)) {\n\t        return Sk.longFromStr(s, 0);\n\t    }\n\n\t    // Small enough, return parsed number\n\t    if (neg) {\n\t        return new Sk.builtin.int_(-val);\n\t    } else {\n\t        return new Sk.builtin.int_(val);\n\t    }\n\t}\n\n\tfunction astForSlice (c, n) {\n\t    var n2;\n\t    var step;\n\t    var upper;\n\t    var lower;\n\t    var ch;\n\t    REQ(n, SYM.subscript);\n\n\t    /*\n\t     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n\t     sliceop: ':' [test]\n\t     */\n\t    ch = CHILD(n, 0);\n\t    lower = null;\n\t    upper = null;\n\t    step = null;\n\t    if (ch.type === TOK.T_DOT) {\n\t        return new Ellipsis();\n\t    }\n\t    if (NCH(n) === 1 && ch.type === SYM.test) {\n\t        return new Index(astForExpr(c, ch));\n\t    }\n\t    if (ch.type === SYM.test) {\n\t        lower = astForExpr(c, ch);\n\t    }\n\t    if (ch.type === TOK.T_COLON) {\n\t        if (NCH(n) > 1) {\n\t            n2 = CHILD(n, 1);\n\t            if (n2.type === SYM.test) {\n\t                upper = astForExpr(c, n2);\n\t            }\n\t        }\n\t    }\n\t    else if (NCH(n) > 2) {\n\t        n2 = CHILD(n, 2);\n\t        if (n2.type === SYM.test) {\n\t            upper = astForExpr(c, n2);\n\t        }\n\t    }\n\n\t    ch = CHILD(n, NCH(n) - 1);\n\t    if (ch.type === SYM.sliceop) {\n\t        if (NCH(ch) === 1) {\n\t            ch = CHILD(ch, 0);\n\t            step = new Name(strobj(\"None\"), Load, ch.lineno, ch.col_offset);\n\t        }\n\t        else {\n\t            ch = CHILD(ch, 1);\n\t            if (ch.type === SYM.test) {\n\t                step = astForExpr(c, ch);\n\t            }\n\t        }\n\t    }\n\t    return new Slice(lower, upper, step);\n\t}\n\n\tfunction astForAtom(c, n) {\n\t    /* atom: ('(' [yield_expr|testlist_comp] ')' |\n\t       '[' [listmaker] ']' |\n\t       '{' [dictorsetmaker] '}' |\n\t       '`' testlist1 '`' |\n\t       NAME | NUMBER | STRING+)\n\t    */\n\t    var i;\n\t    var values;\n\t    var keys;\n\t    var size;\n\t    var ch = CHILD(n, 0);\n\t    var elts;\n\t    switch (ch.type) {\n\t        case TOK.T_NAME:\n\t            // All names start in Load context, but may be changed later\n\t            return new Name(strobj(ch.value), Load, n.lineno, n.col_offset);\n\t        case TOK.T_STRING:\n\t            return new Str(parsestrplus(c, n), n.lineno, n.col_offset);\n\t        case TOK.T_NUMBER:\n\t            return new Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);\n\t        case TOK.T_LPAR: // various uses for parens\n\t            ch = CHILD(n, 1);\n\t            if (ch.type === TOK.T_RPAR) {\n\t                return new Tuple([], Load, n.lineno, n.col_offset);\n\t            }\n\t            if (ch.type === SYM.yield_expr) {\n\t                return astForExpr(c, ch);\n\t            }\n\t            //            if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.comp_for) {\n\t            //                return astForComprehension(c, ch);\n\t            //            }\n\t            return astForTestlistComp(c, ch);\n\t        case TOK.T_LSQB: // list or listcomp\n\t            ch = CHILD(n, 1);\n\t            if (ch.type === TOK.T_RSQB) {\n\t                return new List([], Load, n.lineno, n.col_offset);\n\t            }\n\t            REQ(ch, SYM.listmaker);\n\t            if (NCH(ch) === 1 || CHILD(ch, 1).type === TOK.T_COMMA) {\n\t                return new List(seqForTestlist(c, ch), Load, n.lineno, n.col_offset);\n\t            } \n\t            return astForListcomp(c, ch);\n\t            \n\t        case TOK.T_LBRACE:\n\t            /* dictorsetmaker: \n\t             *     (test ':' test (comp_for : (',' test ':' test)* [','])) |\n\t             *     (test (comp_for | (',' test)* [',']))\n\t             */\n\t            keys = [];\n\t            values = [];\n\t            ch = CHILD(n, 1);\n\t            if (n.type === TOK.T_RBRACE) {\n\t                //it's an empty dict\n\t                return new Dict([], null, n.lineno, n.col_offset);\n\t            } \n\t            else if (NCH(ch) === 1 || (NCH(ch) !== 0 && CHILD(ch, 1).type === TOK.T_COMMA)) {\n\t                //it's a simple set\n\t                elts = [];\n\t                size = Math.floor((NCH(ch) + 1) / 2);\n\t                for (i = 0; i < NCH(ch); i += 2) {\n\t                    var expression = astForExpr(c, CHILD(ch, i));\n\t                    elts[i / 2] = expression;\n\t                }\n\t                return new Set(elts, n.lineno, n.col_offset);\n\t            } \n\t            else if (NCH(ch) !== 0 && CHILD(ch, 1).type == SYM.comp_for) {\n\t                //it's a set comprehension\n\t                return astForSetComp(c, ch);\n\t            } \n\t            else if (NCH(ch) > 3 && CHILD(ch, 3).type === SYM.comp_for) {\n\t                //it's a dict compr. I think.\n\t                return astForDictComp(c, ch);\n\t            } \n\t            else {\n\t                size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case\n\t                for (i = 0; i < NCH(ch); i += 4) {\n\t                    keys[i / 4] = astForExpr(c, CHILD(ch, i));\n\t                    values[i / 4] = astForExpr(c, CHILD(ch, i + 2));\n\t                }\n\t                return new Dict(keys, values, n.lineno, n.col_offset);\n\t            }\n\t        case TOK.T_BACKQUOTE:\n\t            //throw new Sk.builtin.SyntaxError(\"backquote not supported, use repr()\", c.c_filename, n.lineno);\n\t            return new Repr(astForTestlist(c, CHILD(n, 1)), n.lineno, n.col_offset);\n\t        default:\n\t            goog.asserts.fail(\"unhandled atom\", ch.type);\n\n\t    }\n\t}\n\n\tfunction astForPower (c, n) {\n\t    /* power: atom trailer* ('**' factor)*\n\t     */\n\t    var f;\n\t    var tmp;\n\t    var ch;\n\t    var i;\n\t    var e;\n\t    REQ(n, SYM.power);\n\t    e = astForAtom(c, CHILD(n, 0));\n\t    if (NCH(n) === 1) {\n\t        return e;\n\t    }\n\t    for (i = 1; i < NCH(n); ++i) {\n\t        ch = CHILD(n, i);\n\t        if (ch.type !== SYM.trailer) {\n\t            break;\n\t        }\n\t        tmp = astForTrailer(c, ch, e);\n\t        tmp.lineno = e.lineno;\n\t        tmp.col_offset = e.col_offset;\n\t        e = tmp;\n\t    }\n\t    if (CHILD(n, NCH(n) - 1).type === SYM.factor) {\n\t        f = astForExpr(c, CHILD(n, NCH(n) - 1));\n\t        e = new BinOp(e, Pow, f, n.lineno, n.col_offset);\n\t    }\n\t    return e;\n\t}\n\n\tfunction astForExpr (c, n) {\n\t    /* handle the full range of simple expressions\n\t     test: or_test ['if' or_test 'else' test] | lambdef\n\t     or_test: and_test ('or' and_test)*\n\t     and_test: not_test ('and' not_test)*\n\t     not_test: 'not' not_test | comparison\n\t     comparison: expr (comp_op expr)*\n\t     expr: xor_expr ('|' xor_expr)*\n\t     xor_expr: and_expr ('^' and_expr)*\n\t     and_expr: shift_expr ('&' shift_expr)*\n\t     shift_expr: arith_expr (('<<'|'>>') arith_expr)*\n\t     arith_expr: term (('+'|'-') term)*\n\t     term: factor (('*'|'/'|'%'|'//') factor)*\n\t     factor: ('+'|'-'|'~') factor | power\n\t     power: atom trailer* ('**' factor)*\n\n\t     As well as modified versions that exist for backward compatibility,\n\t     to explicitly allow:\n\t     [ x for x in lambda: 0, lambda: 1 ]\n\t     (which would be ambiguous without these extra rules)\n\n\t     old_test: or_test | old_lambdef\n\t     old_lambdef: 'lambda' [vararglist] ':' old_test\n\n\t     */\n\n\t    var exp;\n\t    var cmps;\n\t    var ops;\n\t    var i;\n\t    var seq;\n\t    LOOP: while (true) {\n\t        switch (n.type) {\n\t            case SYM.test:\n\t            case SYM.old_test:\n\t                if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.old_lambdef) {\n\t                    return astForLambdef(c, CHILD(n, 0));\n\t                }\n\t                else if (NCH(n) > 1) {\n\t                    return astForIfexpr(c, n);\n\t                }\n\t            // fallthrough\n\t            case SYM.or_test:\n\t            case SYM.and_test:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                seq = [];\n\t                for (i = 0; i < NCH(n); i += 2) {\n\t                    seq[i / 2] = astForExpr(c, CHILD(n, i));\n\t                }\n\t                if (CHILD(n, 1).value === \"and\") {\n\t                    return new BoolOp(And, seq, n.lineno, n.col_offset);\n\t                }\n\t                goog.asserts.assert(CHILD(n, 1).value === \"or\");\n\t                return new BoolOp(Or, seq, n.lineno, n.col_offset);\n\t            case SYM.not_test:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                else {\n\t                    return new UnaryOp(Not, astForExpr(c, CHILD(n, 1)), n.lineno, n.col_offset);\n\t                }\n\t                break;\n\t            case SYM.comparison:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                else {\n\t                    ops = [];\n\t                    cmps = [];\n\t                    for (i = 1; i < NCH(n); i += 2) {\n\t                        ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));\n\t                        cmps[(i - 1) / 2] = astForExpr(c, CHILD(n, i + 1));\n\t                    }\n\t                    return new Compare(astForExpr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset);\n\t                }\n\t                break;\n\t            case SYM.expr:\n\t            case SYM.xor_expr:\n\t            case SYM.and_expr:\n\t            case SYM.shift_expr:\n\t            case SYM.arith_expr:\n\t            case SYM.term:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                return astForBinop(c, n);\n\t            case SYM.yield_expr:\n\t                exp = null;\n\t                if (NCH(n) === 2) {\n\t                    exp = astForTestlist(c, CHILD(n, 1));\n\t                }\n\t                return new Yield(exp, n.lineno, n.col_offset);\n\t            case SYM.factor:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                return astForFactor(c, n);\n\t            case SYM.power:\n\t                return astForPower(c, n);\n\t            default:\n\t                goog.asserts.fail(\"unhandled expr\", \"n.type: %d\", n.type);\n\t        }\n\t        break;\n\t    }\n\t}\n\n\tfunction astForPrintStmt (c, n) {\n\t    /* print_stmt: 'print' ( [ test (',' test)* [','] ]\n\t     | '>>' test [ (',' test)+ [','] ] )\n\t     */\n\t    var nl;\n\t    var i, j;\n\t    var seq;\n\t    var start = 1;\n\t    var dest = null;\n\t    REQ(n, SYM.print_stmt);\n\t    if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {\n\t        dest = astForExpr(c, CHILD(n, 2));\n\t        start = 4;\n\t    }\n\t    seq = [];\n\t    for (i = start, j = 0; i < NCH(n); i += 2, ++j) {\n\t        seq[j] = astForExpr(c, CHILD(n, i));\n\t    }\n\t    nl = (CHILD(n, NCH(n) - 1)).type === TOK.T_COMMA ? false : true;\n\t    return new Print(dest, seq, nl, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForStmt (c, n) {\n\t    var ch;\n\t    if (n.type === SYM.stmt) {\n\t        goog.asserts.assert(NCH(n) === 1);\n\t        n = CHILD(n, 0);\n\t    }\n\t    if (n.type === SYM.simple_stmt) {\n\t        goog.asserts.assert(numStmts(n) === 1);\n\t        n = CHILD(n, 0);\n\t    }\n\t    if (n.type === SYM.small_stmt) {\n\t        REQ(n, SYM.small_stmt);\n\t        n = CHILD(n, 0);\n\t        /* small_stmt: expr_stmt | print_stmt  | del_stmt | pass_stmt\n\t         | flow_stmt | import_stmt | global_stmt | exec_stmt\n\t         | assert_stmt\n\t         */\n\t        switch (n.type) {\n\t            case SYM.expr_stmt:\n\t                return astForExprStmt(c, n);\n\t            case SYM.print_stmt:\n\t                return astForPrintStmt(c, n);\n\t            case SYM.del_stmt:\n\t                return astForDelStmt(c, n);\n\t            case SYM.pass_stmt:\n\t                return new Pass(n.lineno, n.col_offset);\n\t            case SYM.flow_stmt:\n\t                return astForFlowStmt(c, n);\n\t            case SYM.import_stmt:\n\t                return astForImportStmt(c, n);\n\t            case SYM.global_stmt:\n\t                return astForGlobalStmt(c, n);\n\t            case SYM.exec_stmt:\n\t                return astForExecStmt(c, n);\n\t            case SYM.assert_stmt:\n\t                return astForAssertStmt(c, n);\n\t            case SYM.debugger_stmt:\n\t                return new Debugger_(n.lineno, n.col_offset);\n\t            default:\n\t                goog.asserts.fail(\"unhandled small_stmt\");\n\t        }\n\t    }\n\t    else {\n\t        /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt\n\t         | funcdef | classdef | decorated\n\t         */\n\t        ch = CHILD(n, 0);\n\t        REQ(n, SYM.compound_stmt);\n\t        switch (ch.type) {\n\t            case SYM.if_stmt:\n\t                return astForIfStmt(c, ch);\n\t            case SYM.while_stmt:\n\t                return astForWhileStmt(c, ch);\n\t            case SYM.for_stmt:\n\t                return astForForStmt(c, ch);\n\t            case SYM.try_stmt:\n\t                return astForTryStmt(c, ch);\n\t            case SYM.with_stmt:\n\t                return astForWithStmt(c, ch);\n\t            case SYM.funcdef:\n\t                return astForFuncdef(c, ch, []);\n\t            case SYM.classdef:\n\t                return astForClassdef(c, ch, []);\n\t            case SYM.decorated:\n\t                return astForDecorated(c, ch);\n\t            default:\n\t                goog.asserts.assert(\"unhandled compound_stmt\");\n\t        }\n\t    }\n\t}\n\n\tSk.astFromParse = function (n, filename, c_flags) {\n\t    var j;\n\t    var num;\n\t    var ch;\n\t    var i;\n\t    var c = new Compiling(\"utf-8\", filename, c_flags);\n\t    var stmts = [];\n\t    var k = 0;\n\t    switch (n.type) {\n\t        case SYM.file_input:\n\t            for (i = 0; i < NCH(n) - 1; ++i) {\n\t                ch = CHILD(n, i);\n\t                if (n.type === TOK.T_NEWLINE) {\n\t                    continue;\n\t                }\n\t                REQ(ch, SYM.stmt);\n\t                num = numStmts(ch);\n\t                if (num === 1) {\n\t                    stmts[k++] = astForStmt(c, ch);\n\t                }\n\t                else {\n\t                    ch = CHILD(ch, 0);\n\t                    REQ(ch, SYM.simple_stmt);\n\t                    for (j = 0; j < num; ++j) {\n\t                        stmts[k++] = astForStmt(c, CHILD(ch, j * 2));\n\t                    }\n\t                }\n\t            }\n\t            return new Module(stmts);\n\t        case SYM.eval_input:\n\t            goog.asserts.fail(\"todo;\");\n\t        case SYM.single_input:\n\t            goog.asserts.fail(\"todo;\");\n\t        default:\n\t            goog.asserts.fail(\"todo;\");\n\t    }\n\t};\n\n\tSk.astDump = function (node) {\n\t    var spaces = function (n) // todo; blurgh\n\t    {\n\t        var i;\n\t        var ret = \"\";\n\t        for (i = 0; i < n; ++i) {\n\t            ret += \" \";\n\t        }\n\t        return ret;\n\t    };\n\n\t    var _format = function (node, indent) {\n\t        var ret;\n\t        var elemsstr;\n\t        var x;\n\t        var elems;\n\t        var fieldstr;\n\t        var field;\n\t        var attrs;\n\t        var fieldlen;\n\t        var b;\n\t        var a;\n\t        var i;\n\t        var fields;\n\t        var namelen;\n\t        if (node === null) {\n\t            return indent + \"None\";\n\t        }\n\t        else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {\n\t            return indent + node.prototype._astname + \"()\";\n\t        }\n\t        else if (node._astname !== undefined) {\n\t            namelen = spaces(node._astname.length + 1);\n\t            fields = [];\n\t            for (i = 0; i < node._fields.length; i += 2) // iter_fields\n\t            {\n\t                a = node._fields[i]; // field name\n\t                b = node._fields[i + 1](node); // field getter func\n\t                fieldlen = spaces(a.length + 1);\n\t                fields.push([a, _format(b, indent + namelen + fieldlen)]);\n\t            }\n\t            attrs = [];\n\t            for (i = 0; i < fields.length; ++i) {\n\t                field = fields[i];\n\t                attrs.push(field[0] + \"=\" + field[1].replace(/^\\s+/, \"\"));\n\t            }\n\t            fieldstr = attrs.join(\",\\n\" + indent + namelen);\n\t            return indent + node._astname + \"(\" + fieldstr + \")\";\n\t        }\n\t        else if (goog.isArrayLike(node)) {\n\t            //Sk.debugout(\"arr\", node.length);\n\t            elems = [];\n\t            for (i = 0; i < node.length; ++i) {\n\t                x = node[i];\n\t                elems.push(_format(x, indent + \" \"));\n\t            }\n\t            elemsstr = elems.join(\",\\n\");\n\t            return indent + \"[\" + elemsstr.replace(/^\\s+/, \"\") + \"]\";\n\t        }\n\t        else {\n\t            if (node === true) {\n\t                ret = \"True\";\n\t            }\n\t            else if (node === false) {\n\t                ret = \"False\";\n\t            }\n\t            else if (node instanceof Sk.builtin.lng) {\n\t                ret = node.tp$str().v;\n\t            }\n\t            else if (node instanceof Sk.builtin.str) {\n\t                ret = node[\"$r\"]().v;\n\t            }\n\t            else {\n\t                ret = \"\" + node;\n\t            }\n\t            return indent + ret;\n\t        }\n\t    };\n\n\t    return _format(node, \"\");\n\t};\n\n\tgoog.exportSymbol(\"Sk.astFromParse\", Sk.astFromParse);\n\tgoog.exportSymbol(\"Sk.astDump\", Sk.astDump);\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/afterword.js ---- */ \n\n\tfunction wrapAstThing(fx, argpos, debug) {\n\t\targpos = argpos || 2;\n\t\treturn function(x) {\n\t\t\tvar n = arguments[argpos-1];\n\t\t\tvar result = fx.apply(undefined, arguments);\n\t\t\tresult.range = n.range;\n\t\t\tresult.str = n.str;\n\t\t\tresult.loc = n.loc;\n\t\t\tif ( debug ) {\n\t\t\t\tconsole.log(n);\n\t\t\t\tconsole.log(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}\n\n\tastForAtom = wrapAstThing(astForAtom);\n\tastForCompOp = wrapAstThing(astForCompOp);\n\tastForSuite = wrapAstThing(astForSuite);\n\tastForExceptClause = wrapAstThing(astForExceptClause);\n\tastForDottedName = wrapAstThing(astForDottedName);\n\tastForDecorator = wrapAstThing(astForDecorator);\n\tastForDecorators = wrapAstThing(astForDecorators);\n\tastForDecorated = wrapAstThing(astForDecorated);\n\tastForWithVar = wrapAstThing(astForWithVar);\n\tastForWithStmt = wrapAstThing(astForWithStmt);\n\tastForExecStmt = wrapAstThing(astForExecStmt);\n\tastForIfStmt = wrapAstThing(astForIfStmt);\n\tastForExprlist = wrapAstThing(astForExprlist);\n\tastForDelStmt = wrapAstThing(astForDelStmt);\n\tastForGlobalStmt = wrapAstThing(astForGlobalStmt);\n\tastForAssertStmt = wrapAstThing(astForAssertStmt);\n\tastForImportStmt = wrapAstThing(astForImportStmt);\n\tastForTestlistComp = wrapAstThing(astForTestlistComp);\n\tastForListcomp = wrapAstThing(astForListcomp);\n\tastForFactor = wrapAstThing(astForFactor);\n\tastForForStmt = wrapAstThing(astForForStmt);\n\tastForTrailer = wrapAstThing(astForTrailer);\n\tastForFlowStmt = wrapAstThing(astForFlowStmt);\n\tastForArguments = wrapAstThing(astForArguments);\n\tastForFuncdef = wrapAstThing(astForFuncdef);\n\tastForClassBases = wrapAstThing(astForClassBases);\n\tastForClassdef = wrapAstThing(astForClassdef);\n\tastForLambdef = wrapAstThing(astForLambdef);\n\tastForComprehension = wrapAstThing(astForComprehension);\n\tastForIterComp = wrapAstThing(astForIterComp);\n\tastForDictComp = wrapAstThing(astForDictComp);\n\tastForGenExpr = wrapAstThing(astForGenExpr);\n\tastForSetComp = wrapAstThing(astForSetComp);\n\tastForWhileStmt = wrapAstThing(astForWhileStmt);\n\tastForAugassign = wrapAstThing(astForAugassign);\n\tastForBinop = wrapAstThing(astForBinop);\n\tastForTestlist = wrapAstThing(astForTestlist);\n\tastForExprStmt = wrapAstThing(astForExprStmt);\n\tastForIfexpr = wrapAstThing(astForIfexpr);\n\tastForExpr = wrapAstThing(astForExpr);\n\tSk.astFromParse = wrapAstThing(Sk.astFromParse, 1);\n\n\tSk.nameForToken = function(v) {\n\t\tif ( typeof v === \"string\" ) return v;\n\t\tfor ( var name in Sk.Tokenizer.Tokens ) {\n\t\t\tif ( Sk.Tokenizer.Tokens[name] == v ) return name;\n\t\t}\n\t\tif ( v in Sk.ParseTables.number2symbol ) {\n\t\t\treturn Sk.ParseTables.number2symbol[v];\n\t\t}\n\n\t\treturn '???:' + v;\n\t};\n\n\t//Sk.python3 = true;\n\tSk.Parser = Parser;\n\tSk.builtin.str.prototype.valueOf = function() { return this.v; };\n\tSk.builtin.str.prototype.toString = function() { return this.v; };\n\n\tSk.builtin.SyntaxError = function(str, file, line, ctx, extra) {\n\t\tvar err = new SyntaxError(str, file, line);\n\t\terr.context = ctx;\n\t\terr.extra = extra;\n\t\terr.line = line;\n\t\treturn err;\n\t};\n\n\tSk.builtin.IndentationError = function(str, file, line, row, extra) {\n\t\tvar err = new SyntaxError('Indentation Error: ' + str, file, line);\n\t\terr.context = [[line, row], [line, row]];\n\t\terr.extra = {\n\t\t};\n\t\terr.line = line;\n\t\treturn err;\n\t};\n\n\n\tmodule.exports = Sk;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tvar isArray = Array.isArray;\n\n\t//TODO: Find a way to not have to do this.\n\tfunction getOpName(op) {\n\t\tif (op.prototype._astname) {\n\t\t\treturn op.prototype._astname;\n\t\t}\n\t\tthrow new Error(\"Coudlnt decode operator name for: \" + (op.name || op.toString()));\n\t}\n\n\tfunction abort(why) {\n\t\tconsole.log(new Error(\"ABORT:\" + why).stack);\n\t\tthrow new Error(why);\n\t}\n\n\tfunction isExpression(n) {\n\t\treturn /Expression$/.test(n.type);\n\t}\n\n\tvar idx = 0;\n\tfunction createTempName(hint) {\n\t\treturn '__temp$' + hint + '$' + idx++;\n\t}\n\n\tfunction ensureStatement(s) {\n\t\tvar f = s;\n\t\tif ( !isArray(s) ) f = [f];\n\t\tfor ( var i = 0; i < f.length; ++i ) {\n\t\t\tvar v = f[i];\n\t\t\tif ( isExpression(v) ) {\n\t\t\t\tf[i] = {type: \"ExpressionStatement\", expression: v};\n\t\t\t}\n\t\t}\n\n\t\tif ( isArray(s) ) return s;\n\t\telse return f[0];\n\t}\n\n\tfunction ident(n) {\n\t\treturn {type: \"Identifier\", name: n.valueOf()};\n\t}\n\n\tfunction member(o, p) {\n\t\treturn {\n\t\t\ttype: \"MemberExpression\",\n\t\t\tobject: o,\n\t\t\tproperty: p,\n\t\t\tcomputed: false\n\t\t};\n\t}\n\n\tfunction literal(v) {\n\t\tif ( typeof v === 'object' ) v = v.valueOf();\n\n\t\tif ( typeof v === 'number' && (1 / v !== 1 / Math.abs(v)) ) {\n\t\t\treturn {type: \"UnaryExpression\", argument: literal(-v), operator: '-' };\n\t\t}\n\n\t\treturn {type: \"Literal\", value: v, raw: JSON.stringify(v)};\n\t}\n\n\tfunction binOp(left, op, right) {\n\t\treturn {\n\t\t\ttype: \"BinaryExpression\",\n\t\t\tleft: left,\n\t\t\tright: right,\n\t\t\toperator: op\n\t\t};\n\t}\n\n\tfunction logicOp(left, op, right) {\n\t\treturn {\n\t\t\ttype: \"LogicalExpression\",\n\t\t\tleft: left,\n\t\t\tright: right,\n\t\t\toperator: op\n\t\t};\n\t}\n\n\tfunction ternary(cond, a, b) {\n\t\treturn {\n\t\t\ttype: \"ConditionalExpression\",\n\t\t\ttest: cond,\n\t\t\tconsequent: a,\n\t\t\talternate: b\n\t\t};\n\t}\n\n\tfunction var_(name, init) {\n\t\treturn {\n\t\t\ttype: \"VariableDeclaration\",\n\t\t\tkind: 'var',\n\t\t\tdeclarations: [{\n\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\tid: name,\n\t\t\t\tinit: init ? init : undefined\n\t\t\t}]\n\t\t};\n\t}\n\n\tfunction transform(node, ctx) {\n\t\t//console.log(node.lineno, node.col_offset);\n\t\tvar result = dispatch(node, ctx);\n\t\tif ( node.range ) result.range = [node.range[0], node.range[1]];\n\t\tif ( node.loc ) result.loc = node.loc;\n\t\tresult.str = node.str;\n\t\treturn result;\n\t}\n\n\tfunction dispatch(node, ctx) {\n\t\tif ( !ctx.locals ) ctx.locals = Object.create(null);\n\n\t\tif ( !node ) {\n\t\t\tconsole.log(\"WAT!\", new Error().stack);\n\t\t\tthrow new Error(\"What?\");\n\t\t}\n\t\tif ( isArray(node) ) {\n\t\t\tvar body = [];\n\t\t\tfor ( var i = 0; i < node.length; ++i ) {\n\t\t\t\tvar r = transform(node[i], ctx);\n\t\t\t\tif ( isArray(r) ) body.push.apply(body, r);\n\t\t\t\telse body.push(r);\n\t\t\t}\n\t\t\treturn body;\n\t\t}\n\t\tswitch (node._astname) {\n\t\t\tcase 'Attribute': return transformAttribute(node, ctx);\n\t\t\tcase 'Assign': return transformAssign(node, ctx);\n\t\t\tcase 'AugAssign': return transformAugAssign(node, ctx);\n\t\t\tcase 'BinOp': return transformBinOp(node, ctx);\n\t\t\tcase 'BoolOp': return transformBoolOp(node, ctx);\n\t\t\tcase 'Break': return transformBreak(node, ctx);\n\t\t\tcase 'Call': return transformCall(node, ctx);\n\t\t\tcase 'ClassDef': return transformClassDef(node, ctx);\n\t\t\tcase 'Continue': return tranformContinue(node, ctx);\n\t\t\tcase 'Compare': return transformCompare(node, ctx);\n\t\t\tcase 'Dict': return transformDict(node, ctx);\n\t\t\tcase 'Delete': return transformDel(node, ctx);\n\t\t\tcase 'Expr': return transformExpr(node, ctx);\n\t\t\tcase 'For': return transformFor(node, ctx);\n\t\t\tcase 'FunctionDef': return transformFunctionDef(node, ctx);\n\t\t\tcase 'GeneratorExp': return transformListComp(node, ctx); //TODO: Make this seperate\n\t\t\tcase 'Global': return transformGlobal(node, ctx);\n\t\t\tcase 'If': return transformIf(node, ctx);\n\t\t\tcase 'Import': return NoOp();\n\t\t\tcase 'Lambda': return transformLambda(node, ctx);\n\t\t\tcase 'List': return transformList(node, ctx);\n\t\t\tcase 'ListComp': return transformListComp(node, ctx);\n\t\t\tcase 'Module': return transformModule(node, ctx);\n\t\t\tcase 'Name': return transformName(node, ctx);\n\t\t\tcase 'Print': return transformPrint(node, ctx);\n\t\t\tcase 'Return': return transformReturn(node, ctx);\n\t\t\tcase 'Str': return transformStr(node, ctx);\n\t\t\tcase 'Subscript': return transformSubscript(node, ctx);\n\t\t\tcase 'Tuple': return transformTuple(node, ctx);\n\t\t\tcase 'Num': return transformNum(node, ctx);\n\t\t\tcase 'Pass': return transformPass(node, ctx);\n\t\t\tcase 'UnaryOp': return transformUnaryOp(node, ctx);\n\t\t\tcase 'While': return transformWhile(node, ctx);\n\t\t\tdefault:\n\t\t\t\tconsole.log(\"Dont know how to transform: \" + node._astname);\n\t\t\t\tconsole.log(JSON.stringify(node, null, '  '));\n\t\t\t\tthrow new Error(\"Dont know how to transform: \" + node._astname);\n\t\t}\n\t}\n\n\tfunction NoOp() { return []; }\n\n\n\n\tfunction makeVariableName(name) {\n\t\tvar parts = Array.isArray(name) ? name : name.split(/\\./g);\n\t\tif ( parts.length === 1 ) return ident(name);\n\t\tvar prop = parts.pop();\n\t\treturn member(makeVariableName(parts), ident(prop));\n\t}\n\n\tfunction transformAttribute(node, ctx) {\n\t\tvar n = node.attr;\n\t\tif ( n._astname ) n = transform(n, ctx);\n\t\telse n = {type: 'Identifier', name: n.valueOf()};\n\t\treturn member(transform(node.value, ctx), n);\n\t}\n\n\tfunction transformAugAssign(node, ctx) {\n\t\t//TODO: We need to not inject left into the code twice\n\t\t//as it could have side effects.\n\t\tvar right = transform(node.value, ctx);\n\t\tvar left = transform(node.target, ctx);\n\t\tvar tn = createTempName(\"left\");\n\t\tvar opName = getOpName(node.op);\n\t\treturn [\n\t\t\tvar_(ident(tn), left),\n\t\t\tensureStatement({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\toperator: '=',\n\t\t\t\tleft: left,\n\t\t\t\tright: createBinOp(left, opName, right)\n\t\t\t})\n\t\t];\n\t}\n\n\tfunction transformAssign(node, ctx) {\n\n\t\tvar results = [];\n\t\tfor ( var i = 0; i < node.targets.length; ++i ) {\n\t\t\tvar left = node.targets[i];\n\t\t\tif ( ctx.writeTarget ) {\n\t\t\t\tleft = member(ctx.writeTarget, transform(left,ctx));\n\t\t\t}\n\t\t\tresults.push.apply(results,createTupleUnpackingAssign(left, transform(node.value, ctx), ctx));\n\t\t\n\t\t}\n\t\tif ( results.length == 1 ) return results[0];\n\t\treturn {type: \"BlockStatement\", body: results}; \n\t}\n\n\tfunction createBinOp(left, op, right) {\n\n\t\tif ( op === 'FloorDiv' ) {\n\t\t\treturn {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName('Math.floor'),\n\t\t\t\targuments: [{\n\t\t\t\t\ttype: \"BinaryExpression\",\n\t\t\t\t\tleft: left,\n\t\t\t\t\tright: right,\n\t\t\t\t\toperator: '/'\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tvar fxOps = {\n\t\t\t\"Add\": \"__pythonRuntime.ops.add\",\n\t\t\t\"Mult\": \"__pythonRuntime.ops.multiply\",\n\t\t\t\"Pow\": \"Math.pow\"\n\t\t};\n\n\t\tif ( op in fxOps  ) {\n\t\t\tvar call = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName(fxOps[op]),\n\t\t\t\targuments: [left, right]\n\t\t\t};\n\t\t\treturn call;\n\t\t}\n\n\t\tvar operators = {\n\t\t\t\"Add\": \"+\",\n\t\t\t\"Sub\": \"-\",\n\t\t\t\"Mod\": \"%\",\n\t\t\t\"Div\": \"/\",\n\t\t\t\"BitAnd\": \"&\",\n\t\t\t\"BitOr\": \"|\",\n\t\t\t'BitXor': '^',\n\t\t\t\"LShift\": \"<<\",\n\t\t\t\"RShift\": \">>\"\n\n\t\t};\n\n\t\tif ( !(op in operators) ) abort(\"Unknown binary operator: \" + op);\n\n\t\treturn binOp(left, operators[op], right);\n\t}\n\n\tfunction transformBinOp(node, ctx) {\n\t\tvar left = transform(node.left, ctx);\n\t\tvar right = transform(node.right, ctx);\n\t\treturn createBinOp(left, getOpName(node.op), right);\n\t}\n\n\tfunction transformBoolOp(node, ctx) {\n\t\tvar fvals = new Array(node.values.length);\n\t\tfor ( var i = 0; i < node.values.length; ++i ) {\n\t\t\tfvals[i] = transform(node.values[i], ctx);\n\t\t}\n\t\tvar opName = getOpName(node.op);\n\t\tvar operators = {\n\t\t\t'And': '&&',\n\t\t\t'Or': '||'\n\t\t};\n\n\t\tif ( !(opName in operators ) ) abort(\"Unknown bool opeartor: \" + opName);\n\t\tvar opstr = operators[opName];\n\n\t\tvar result = fvals.pop();\n\t\twhile ( fvals.length > 0 ) {\n\t\t\tresult = logicOp(fvals.pop(), opstr, result);\n\t\t}\n\n\n\t\t//TODO: Support || as well?\n\t\treturn result;\n\t}\n\n\tfunction transformBreak(node, ctx) {\n\t\treturn {type: \"BreakStatement\"};\n\t}\n\n\tfunction transformCall(node, ctx) {\n\t\tvar builtins = ['len'];\n\t\tif ( node.func._astname == 'Name' ) {\n\t\t\tswitch ( node.func.id.v ) {\n\t\t\t\tcase 'len':\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\t\t\tobject: transform(node.args[0], ctx),\n\t\t\t\t\t\tproperty: {type: \"Identifier\", name: \"length\"}\n\t\t\t\t\t};\n\t\t\t\tcase 'all': case 'ord':\n\t\t\t\tcase 'sum': case 'any':\n\t\t\t\tcase 'str': case 'chr':\n\t\t\t\tcase 'ascii': case 'divmod':\n\t\t\t\tcase 'range': case 'enumerate':\n\t\t\t\tcase 'round': case 'filter':\n\t\t\t\tcase 'abs': case 'float':\n\t\t\t\tcase 'int': case 'hex':\n\t\t\t\tcase 'tuple': case  'map':\n\t\t\t\tcase 'bool': case 'max':\n\t\t\t\tcase 'sorted': case 'min':\n\t\t\t\tcase 'list': case 'oct':\n\t\t\t\tcase 'pow': case  'reversed':\n\t\t\t\tcase 'repr':\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'CallExpression',\n\t\t\t\t\t\tcallee: makeVariableName('__pythonRuntime.functions.' + node.func.id.v),\n\t\t\t\t\t\targuments: transform(node.args, ctx)\n\t\t\t\t\t};\n\t\t\t\tcase 'dict':\n\t\t\t\t\tvar args = [];\n\t\t\t\t\tfor ( var i = 0; i < node.keywords.length; ++i ) {\n\t\t\t\t\t\targs.push({\n\t\t\t\t\t\t\ttype: \"ArrayExpression\",\n\t\t\t\t\t\t\telements: [\n\t\t\t\t\t\t\t\tliteral(node.keywords[i].arg.v),\n\t\t\t\t\t\t\t\ttransform(node.keywords[i].value, ctx)\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"NewExpression\",\n\t\t\t\t\t\tcallee: makeVariableName('__pythonRuntime.objects.dict'),\n\t\t\t\t\t\targuments: args\n\t\t\t\t\t};\n\n\t\t\t}\n\t\t}\n\n\t\tvar args = transform(node.args, ctx);\n\n\t\tif ( node.keywords.length > 0 ) {\n\t\t\tvar paramsDict = {\n\t\t\t\ttype: \"ObjectExpression\",\n\t\t\t\tproperties: [{\n\t\t\t\t\ttype: \"Property\",\n\t\t\t\t\tkey: ident(\"__kwp\"),\n\t\t\t\t\tvalue: literal(true)\n\t\t\t\t}]\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < node.keywords.length; ++i ) {\n\t\t\t\tvar k = node.keywords[i];\n\t\t\t\tparamsDict.properties.push({\n\t\t\t\t\ttype: \"Property\",\n\t\t\t\t\tkey: ident(k.arg.v),\n\t\t\t\t\tvalue: transform(k.value, ctx)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar extraArg = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName('__pythonRuntime.utils.createParamsObj'),\n\t\t\t\targuments: [paramsDict]\n\t\t\t};\n\n\t\t\targs.push(extraArg);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: transform(node.func, ctx),\n\t\t\targuments: args\n\t\t};\n\t}\n\n\tfunction transformClassDef(node, ctx) {\n\t\tvar body = [];\n\t\tvar proto = member(ident(node.name), ident('prototype'));\n\t\tvar nctx = {\n\t\t\twriteTarget: proto,\n\t\t\tinClass: true,\n\t\t\tlocals: Object.create(null)\n\t\t};\n\n\t\tif ( node.bases.length > 1 ) alert(\"Multiple base classes not supported.\");\n\n\t\tvar base = (node.bases.length > 0) ? transform(node.bases[0], ctx) : undefined;\n\n\t\tvar ctorBody = [];\n\t\tctorBody.push({\n\t\t\ttype: \"VariableDeclaration\",\n\t\t\tkind: 'var',\n\t\t\tdeclarations: [{\n\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\tid: ident('that'),\n\t\t\t\tinit: {type: \"ThisExpression\"}\n\t\t\t}]\n\t\t});\n\n\t\tctorBody.push({\n\t\t\ttype: \"IfStatement\",\n\t\t\ttest: {\n\t\t\t\ttype:\"UnaryExpression\",\n\t\t\t\targument: binOp(ident('that'), \"instanceof\", ident(node.name)),\n\t\t\t\toperator: \"!\"\n\t\t\t},\n\t\t\tconsequent: ensureStatement({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\tleft: ident('that'),\n\t\t\t\tright: {\n\t\t\t\t\ttype:  \"CallExpression\",\n\t\t\t\t\tcallee: makeVariableName('Object.create'),\n\t\t\t\t\targuments: [ proto ]\n\t\t\t\t},\n\t\t\t\toperator: '='\n\t\t\t})\n\t\t});\n\n\t\tctorBody.push({\n\t\t\ttype: \"IfStatement\",\n\t\t\ttest: {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: member(proto, ident('hasOwnProperty')),\n\t\t\t\targuments: [literal('__init__')]\n\t\t\t},\n\t\t\tconsequent: ensureStatement({\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: member(member(proto, ident('__init__')), ident('apply')),\n\t\t\t\targuments: [ident('that'), ident('arguments')]\n\t\t\t})\n\t\t});\n\n\t\tif ( base ) {\n\t\t\tctorBody.push(ensureStatement({\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: {\n\t\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\t\tobject: base,\n\t\t\t\t\tproperty: ident('apply'),\n\t\t\t\t\tcomputed: false\n\t\t\t\t},\n\t\t\t\targuments: [ident('that'), ident('arguments')]\n\t\t\t}));\n\t\t}\n\n\t\tctorBody.push({\n\t\t\ttype: \"ReturnStatement\",\n\t\t\targument: ident('that')\n\t\t});\n\n\n\t\tbody.push({\n\t\t\ttype: \"FunctionDeclaration\",\n\t\t\tid: ident(node.name),\n\t\t\tparams: [],\n\t\t\tbody: {type: \"BlockStatement\", body:ctorBody}\n\t\t});\n\n\t\tif ( base ) {\n\t\t\tbody.push({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\tleft: proto,\n\t\t\t\tright: {\n\t\t\t\t\ttype:  \"CallExpression\",\n\t\t\t\t\tcallee: makeVariableName('Object.create'),\n\t\t\t\t\targuments: [ member(base, ident('prototype')) ]\n\t\t\t\t},\n\t\t\t\toperator: \"=\"\n\t\t\t});\n\t\t}\n\n\t\tbody = body.concat(transform(node.body, nctx));\n\n\t\tbody.push({\n\t\t\ttype: \"ReturnStatement\",\n\t\t\targument: ident(node.name)\n\t\t});\n\n\t\treturn {\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"declarations\": [\n\t\t\t{\n\t\t\t  \"type\": \"VariableDeclarator\",\n\t\t\t  \"id\": ident(node.name),\n\t\t\t  \"init\": {\n\t\t\t  \ttype: \"CallExpression\",\n\t\t\t  \tcallee: {\n\t\t\t  \t\ttype: \"FunctionExpression\",\n\t\t\t  \t\tparams: [],\n\t\t\t  \t\tbody: {type: \"BlockStatement\", body: ensureStatement(body)}\n\t\t\t  \t},\n\t\t\t  \targuments: []\n\t\t\t  }\n\t\t\t}],\n\t\t\t\"kind\": ctx.varType || 'var'\n\t\t};\n\t}\n\n\n\tfunction tranformContinue(node, ctx) {\n\t\treturn {type: \"ContinueStatement\"};\n\t}\n\n\tfunction makeCop(left, op, right) {\n\n\t\tvar fxOps = {\n\t\t\t\"In_\": \"in\",\n\t\t\t\"In\": \"in\",\n\t\t\t\"NotIn\": \"in\"\n\t\t};\n\t\tvar opName = getOpName(op);\n\t\tif ( opName in fxOps  ) {\n\t\t\tvar call = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName(\"__pythonRuntime.ops.\" + fxOps[opName]),\n\t\t\t\targuments: [left, right]\n\t\t\t};\n\n\t\t\tif ( opName == \"NotIn\" ) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"UnaryExpression\",\n\t\t\t\t\targument: call,\n\t\t\t\t\toperator: \"!\"\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn call;\t\n\t\t\t} \n\t\t}\n\n\t\t\n\t\tvar operators = {\n\t\t\t\"Eq\": \"===\",\n\t\t\t\"NotEq\": \"!==\",\n\t\t\t\"LtE\": \"<=\",\n\t\t\t\"Lt\": \"<\",\n\t\t\t\"GtE\": \">=\",\n\t\t\t\"Gt\": \">\",\n\t\t\t\"Is\": \"===\",\n\t\t\t\"IsNot\": \"!==\"\n\t\t};\n\t\t\n\t\tif ( !(opName in operators) ) abort(\"Unsuported Compare operator: \" + opName);\n\t\treturn binOp(left, operators[opName], right);\n\t}\n\n\tfunction transformCompare(node, ctx) {\n\t\tvar left = transform(node.left, ctx);\n\t\tvar result;\n\n\t\tfor ( var i = 0; i < node.comparators.length; ++i ) {\n\t\t\tvar right = transform(node.comparators[i], ctx);\n\t\t\tvar cop = makeCop(left, node.ops[i], right);\n\t\t\tif ( result ) {\n\t\t\t\tresult = binOp(result, '&&', cop);\n\t\t\t} else {\n\t\t\t\tresult = cop;\n\t\t\t}\n\t\t\tleft = right;\n\t\t}\n\n\t\t\n\n\t\treturn result;\n\t\t\n\t}\n\n\tfunction transformDel(node, ctx) {\n\t\tvar result = [];\n\t\tfor ( var i = 0; i < node.targets.length; ++i ) {\n\t\t\tvar st = node.targets[i];\n\t\t\tvar partial = transform(st, ctx);\n\t\t\tresult.push({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\toperator: \"=\",\n\t\t\t\tleft: partial,\n\t\t\t\tright: {\n\t\t\t\t\ttype: \"UnaryExpression\",\n\t\t\t\t\targument: literal(0),\n\t\t\t\t\toperator: 'void',\n\t\t\t\t\tprefix: true\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn ensureStatement({\n\t\t\ttype: \"SequenceExpression\",\n\t\t\texpressions: result\n\t\t});\n\t}\n\n\tfunction transformDict(node, ctx) {\n\t\tvar args = [];\n\t\tfor ( var i = 0; i < node.keys.length; ++i ) {\n\t\t\targs.push({\n\t\t\t\ttype: \"ArrayExpression\",\n\t\t\t\telements: [\n\t\t\t\t\ttransform(node.keys[i], ctx),\n\t\t\t\t\ttransform(node.values[i], ctx)\n\t\t\t\t]\n\t\t\t});\n\t\t}\n\t\treturn {\n\t\t\ttype: \"NewExpression\",\n\t\t\tcallee: makeVariableName(\"__pythonRuntime.objects.dict\"),\n\t\t\targuments: args\n\t\t};\n\t}\n\n\tfunction transformExpr(node, ctx) {\n\t\treturn {\n\t\t\ttype: \"ExpressionStatement\",\n\t\t\texpression: transform(node.value, ctx)\n\t\t};\n\t}\n\n\tfunction assignPossiblyWithDeclaration(target, value, ctx) {\n\t\tvar left = target._astname ? transform(target, ctx) : target;\n\t\tvar varible;\n\n\t\tif ( left.type === \"Identifier\" ) varible = left.name;\n\n\t\tif ( !varible || !ctx || !ctx.locals || ctx.locals[varible] ) {\n\t\t\treturn {type: \"ExpressionStatement\", expression: {\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\toperator: \"=\",\n\t\t\t\tleft: left,\n\t\t\t\tright: value\n\t\t\t}};\n\t\t}\n\n\t\tctx.locals[varible] = true;\n\n\t\treturn {\n\t\t\ttype: \"VariableDeclaration\",\n\t\t\tdeclarations: [{\n\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\tid: left,\n\t\t\t\tinit: value\n\t\t\t}],\n\t\t\tkind: ctx.varType || 'var'\n\t\t};\n\t}\n\n\tfunction createTupleUnpackingAssign(target, value, ctx) {\n\n\t\tif ( target._astname === 'Tuple' ) {\n\t\t\tvar result = [];\n\t\t\tvar tn = createTempName(\"right\");\n\t\t\tresult.push({\n\t\t\t\ttype: \"VariableDeclaration\",\n\t\t\t\tkind: \"var\",\n\t\t\t\tdeclarations: [{\n\t\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\t\tid: ident(tn),\n\t\t\t\t\tinit: value\n\t\t\t\t}]\n\t\t\t});\n\t\t\tfor ( var i = 0; i < target.elts.length; ++i ) {\n\t\t\t\tresult.push.apply(result,createTupleUnpackingAssign(\n\t\t\t\t\ttarget.elts[i],\n\t\t\t\t\t{type: \"MemberExpression\", object: ident(tn), property: literal(i),  computed: true}\n\t\t\t\t,ctx));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\treturn [assignPossiblyWithDeclaration(target, value, ctx)];\n\t}\n\n\tfunction createForLoop(iident, tident, iter, target, body, ctx) {\n\n\t\tbody = createTupleUnpackingAssign(\n\t\t\ttarget, \n\t\t\t{type: \"MemberExpression\", object: tident, property: iident, computed: true},\n\t\t\tctx\n\t\t).concat(body);\n\n\t\tvar riter = ternary(\n\t\t\t{type: \"CallExpression\", callee: makeVariableName(\"Array.isArray\"), arguments:[iter]},\n\t\t\titer,\n\t\t\t{type: \"CallExpression\", callee: makeVariableName(\"Object.keys\"), arguments:[iter]}\n\t\t);\n\n\t\treturn {\n\t\t\ttype: \"ForStatement\",\n\t\t\tinit: {\n\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\"declarations\": [\n\t\t\t\t{\n\t\t\t\t  \"type\": \"VariableDeclarator\",\n\t\t\t\t  \"id\": iident,\n\t\t\t\t  \"init\": literal(0)\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t  \"type\": \"VariableDeclarator\",\n\t\t\t\t  \"id\": tident,\n\t\t\t\t  \"init\": riter\n\t\t\t\t}],\n\t\t\t\t\"kind\": ctx.varType\n\t\t\t},\n\t\t\ttest: binOp(iident, '<', {\n\t\t\t\ttype: \"MemberExpression\", object: tident, property: {type: \"Identifier\", name: \"length\"}\n\t\t\t}),\n\t\t\tupdate: {\n\t\t\t\t\"type\": \"UpdateExpression\",\n\t\t\t\t\"operator\": \"++\",\n\t\t\t\t\"prefix\": true,\n\t\t\t\t\"argument\": iident\n\t\t\t},\n\t\t\tbody: {type: \"BlockStatement\", body: body}\n\t\t};\n\t}\n\n\tfunction transformFor(node, ctx) {\n\t\tvar name = createTempName('idx');\n\t\tvar iident = ident(name);\n\t\tvar tname = createTempName('target');\n\t\tvar tident = {type: \"Identifier\", name: tname};\n\t\tvar iter = transform(node.iter, ctx);\n\t\tvar body = ensureStatement(transform(node.body, ctx));\n\n\t\tif ( node.orelse && node.orelse.length > 0 ) abort(\"else: for-else statement unsupported.\");\n\t\treturn createForLoop(iident, tident, iter, node.target, body, ctx);\n\t}\n\n\tfunction prepareFunctionBody(node, ctx) {\n\t\tvar args = node.args.args.slice(0);\n\t\tif  ( ctx.inClass ) {\n\t\t\t//TODO: Make sure it's named self, maybe?\n\t\t\targs.shift();\n\t\t}\n\t\tvar hasAnyArguments = args.length > 0 || node.args.vararg || node.args.kwarg;\n\t\tvar nctx = {\n\t\t\tlocals: Object.create(null),\n\t\t\tvarType: ctx.varType\n\t\t};\n\t\tvar body = ensureStatement(transform(node.body, nctx));\n\t\tvar premble = [];\n\n\t\tif ( ctx.inClass ) {\n\t\t\tpremble.push({\n\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\"declarations\": [{\n\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\"id\": ident('self'),\n\t\t\t\t\t\"init\": {type: \"ThisExpression\"}\n\t\t\t\t}],\n\t\t\t\t\"kind\": \"var\"\n\t\t\t});\n\t\t}\n\n\t\tif ( hasAnyArguments ) {\n\t\t\t\n\t\t\tvar hasParams = createTempName('hasParams');\n\t\t\tvar param0 = createTempName('param0');\n\t\t\tvar realArgCount = createTempName('realArgCount');\n\t\t\tvar argLen = makeVariableName('arguments.length');\n\t\t\tvar argN = {type: \"MemberExpression\", object: ident('arguments'), property: binOp(argLen, '-', literal(1)), computed: true};\n\t\t\tvar argNKeywords = {type: \"MemberExpression\", object: argN, property: ident('keywords'), computed: false};\n\n\t\t\tpremble.push({\n\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\"declarations\": [\n\t\t\t\t{\n\t\t\t\t  \"type\": \"VariableDeclarator\",\n\t\t\t\t  \"id\": ident(hasParams),\n\t\t\t\t  \"init\": logicOp(binOp(argLen, '>', literal(0)), '&&', logicOp(argN, '&&', argNKeywords))\n\t\t\t\t}],\n\t\t\t\t\"kind\":  \"var\"\n\t\t\t});\n\n\t\t\tvar main = [];\n\t\t\tmain.push({\n\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\"declarations\": [{\n\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\"id\": ident(param0),\n\t\t\t\t\t\"init\": ternary(ident(hasParams), argNKeywords, {type: \"ObjectExpression\", properties: []})\n\t\t\t\t},{\n\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\"id\": ident(realArgCount),\n\t\t\t\t\t\"init\": binOp(argLen, '-', ternary(ident(hasParams), literal(1), literal(0)))\n\t\t\t\t}],\n\t\t\t\t\"kind\": \"var\"\n\t\t\t});\n\n\t\t\tfor ( var i = 0; i < args.length; ++i ) {\n\t\t\t\tvar a = node.args.args[i];\n\t\t\t\tvar didx = i - (node.args.args.length - node.args.defaults.length);\n\t\t\t\tvar def = didx >= 0 ? transform(node.args.defaults[didx], ctx) : ident('undefined');\n\n\t\t\t\tmain.push({\n\t\t\t\t\ttype: \"IfStatement\",\n\t\t\t\t\ttest: binOp(ident(realArgCount), '<', literal(i+1)),\n\t\t\t\t\tconsequent: ensureStatement({\n\t\t\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\t\t\toperator: \"=\",\n\t\t\t\t\t\tleft: ident(a.id),\n\t\t\t\t\t\tright: ternary(\n\t\t\t\t\t\t\tbinOp(literal(a.id), 'in', ident(param0)),\n\t\t\t\t\t\t\t{type: \"MemberExpression\", object: ident(param0), property: ident(a.id), computed: false},\n\t\t\t\t\t\t\tdef\n\t\t\t\t\t\t)\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( node.args.vararg ) {\n\t\t\t\tmain.push({\n\t\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\t\"declarations\": [{\n\t\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\t\"id\": ident(node.args.vararg),\n\t\t\t\t\t\t\"init\": {\n\t\t\t\t\t\t\ttype: \"CallExpression\",\n\t\t\t\t\t\t\tcallee: makeVariableName(\"Array.prototype.slice.call\"),\n\t\t\t\t\t\t\targuments: [ident('arguments'), literal(node.args.args.length), hasAnyArguments ? ident(realArgCount) : undefined]\n\t\t\t\t\t\t}\n\t\t\t\t\t}],\n\t\t\t\t\t\"kind\": \"var\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( node.args.kwarg ) {\n\t\t\t\tfor ( var i = 0; i < node.args.args.length; ++i ) {\n\t\t\t\t\tmain.push(ensureStatement({\n\t\t\t\t\t\ttype: \"UnaryExpression\",\n\t\t\t\t\t\toperator: \"delete\",\n\t\t\t\t\t\targument: {\n\t\t\t\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\t\t\t\tobject: ident(param0),\n\t\t\t\t\t\t\tproperty: ident(node.args.args[i].id),\n\t\t\t\t\t\t\tcomputed: false\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t\tmain.push({\n\t\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\t\"declarations\": [{\n\t\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\t\"id\": ident(node.args.kwarg),\n\t\t\t\t\t\t\"init\": ident(param0)\n\t\t\t\t\t}],\n\t\t\t\t\t\"kind\": \"var\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tpremble = premble.concat(main); //TODO: If we dont have defauts, we can guard this with __hasParams\t\n\t\t}\n\n\n\t\tbody = premble.concat(body);\n\t\tvar params = transform(args, ctx);\n\t\treturn {\n\t\t\tpremble: premble,\n\t\t\tbody: body,\n\t\t\tparams: params\n\t\t};\n\n\t}\n\n\tfunction transformFunctionDef(node, ctx) {\n\t\tvar data = prepareFunctionBody(node, ctx);\n\n\n\n\t\tif ( ctx.writeTarget ) {\n\t\t\treturn ensureStatement({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\tleft: {type: \"MemberExpression\", object: ctx.writeTarget, property: ident(node.name)},\n\t\t\t\tright: {\n\t\t\t\t\ttype: \"FunctionExpression\",\n\t\t\t\t\tname: ident(node.name),\n\t\t\t\t\tparams: data.params,\n\t\t\t\t\tbody: {type: \"BlockStatement\", body: data.body}\n\t\t\t\t},\n\t\t\t\toperator: '='\n\t\t\t});\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"FunctionDeclaration\",\n\t\t\t\tid: {type: \"Identifier\", name: node.name.v},\n\t\t\t\tparams: data.params,\n\t\t\t\tbody: {type: \"BlockStatement\", body: data.body}\n\t\t\t};\n\t\t}\n\t}\n\n\tfunction transformGlobal(node, ctx) {\n\t\tfor ( var i = 0; i < node.names.length; ++i ) {\n\t\t\tctx.locals[node.names[i].v] = true;\n\t\t}\n\t\treturn [];\n\t}\n\n\tfunction transformIf(node, ctx) {\n\t\tvar body = ensureStatement(transform(node.body, ctx));\n\t\treturn {\n\t\t\ttype: \"IfStatement\",\n\t\t\ttest: transform(node.test, ctx),\n\t\t\tconsequent: {type: \"BlockStatement\", body: body},\n\t\t\talternate: (node.orelse && node.orelse.length > 0) ? {type: \"BlockStatement\", body: ensureStatement(transform(node.orelse, ctx))} : undefined\n\t\t};\n\t}\n\n\tfunction transformLambda(node, ctx) {\n\t\tvar data = prepareFunctionBody(node, ctx);\n\t\t\n\t\t//TODO: This is pretty sketchy.\n\t\tvar last = data.body[data.body.length - 1];\n\t\tdata.body[data.body.length - 1] = {type: \"ReturnStatement\", argument: last.expression};\n\n\t\treturn {\n\t\t\ttype: \"FunctionExpression\",\n\t\t\tparams: data.params,\n\t\t\tbody: {type: \"BlockStatement\", body: data.body}\n\t\t};\n\t}\n\n\tfunction transformList(node, ctx) {\n\t\tvar call = {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: makeVariableName(\"__pythonRuntime.objects.list\"),\n\t\t\targuments: transform(node.elts, ctx)\n\t\t};\n\t\treturn call;\n\t}\n\n\tfunction transformListComp(node, ctx) {\t\n\t\tvar body = [];\n\t\tvar aggrigator = createTempName('result');\n\n\t\tbody.push({\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"declarations\": [{\n\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\"id\": ident(aggrigator),\n\t\t\t\t\"init\": {\n\t\t\t\t\ttype: \"NewExpression\",\n\t\t\t\t\tcallee: makeVariableName('__pythonRuntime.objects.list'),\n\t\t\t\t\targuments: []\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"kind\": \"var\"\n\t\t});\n\n\t\tvar insideBody = [];\n\n\t\tinsideBody.push(ensureStatement({\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: {type: \"MemberExpression\", object: ident(aggrigator), property: ident('push'), computed: false},\n\t\t\targuments: [transform(node.elt, ctx)]\n\t\t}));\n\n\t\t//if ( node.generators.length !== 1 ) abort(\"Unsuported number of generators\");\n\t\tvar gen = node.generators[0];\n\n\t\tfor ( var g = node.generators.length - 1; g >= 0; --g ) {\n\t\t\tvar idxName = createTempName('idx');\n\t\t\tvar listName = createTempName(\"list\" + g);\n\t\t\tvar iterName = createTempName('iter');\n\t\t\tvar gen = node.generators[g];\n\t\t\tfor ( var i = 0; i < gen.ifs.length; ++i ) {\n\t\t\t\tinsideBody.unshift({\n\t\t\t\t\ttype: \"IfStatement\",\n\t\t\t\t\ttest: {type: \"UnaryExpression\", argument: transform(gen.ifs[i], ctx), operator: \"!\"},\n\t\t\t\t\tconsequent: {type: \"ContinueStatement\"}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tinsideBody = [\n\t\t\t\t{\n\t\t\t\t\ttype: \"VariableDeclaration\",\n\t\t\t\t\tkind: \"var\",\n\t\t\t\t\tdeclarations: [{\n\t\t\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\t\t\tid: ident(listName),\n\t\t\t\t\t\tinit: transform(gen.iter, ctx)\n\t\t\t\t\t}]\n\t\t\t\t},\n\t\t\t\tcreateForLoop(ident(idxName), ident(iterName), ident(listName), gen.target, insideBody, ctx)\n\t\t\t];\n\t\t}\n\n\t\tbody.push.apply(body, insideBody);\n\t\tbody.push({\n\t\t\ttype: \"ReturnStatement\",\n\t\t\targument: ident(aggrigator)\n\t\t});\n\n\t\tvar expr = {\n\t\t\ttype: \"FunctionExpression\",\n\t\t\tparams: [],\n\t\t\tbody: {type: \"BlockStatement\", body: body}\n\t\t};\n\n\t\treturn {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: expr,\n\t\t\targuments: []\n\t\t};\n\t}\n\n\tfunction transformModule(node, ctx) {\n\t\treturn {\n\t\t\ttype: \"Program\",\n\t\t\tbody: ensureStatement(transform(node.body, ctx))\n\t\t};\n\t}\n\n\tfunction transformName(node, ctx) {\n\t\tif ( node.id.v === 'True' ) return {type: \"Literal\", value: true, raw: \"true\"};\n\t\tif ( node.id.v === 'False' ) return {type: \"Literal\", value: false, raw: \"false\"};\n\t\tif ( node.id.v === 'None' ) return {type: \"Literal\", value: null, raw: \"null\"};\n\n\t\tif ( node.id.v === 'random' ) return makeVariableName('__pythonRuntime.imports.random');\n\t\treturn ident(node.id);\n\t}\n\n\tfunction transformNum(node, ctx) {\n\t\treturn literal(node.n);\n\t}\n\n\tfunction transformPrint(node, ctx) {\n\t\treturn {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: makeVariableName(\"console.log\"),\n\t\t\targuments: transform(node.values, ctx)\n\t\t};\n\t}\n\n\tfunction transformReturn(node, ctx) {\n\t\treturn {\n\t\t\ttype: \"ReturnStatement\",\n\t\t\targument: node.value ? transform(node.value, ctx) : undefined\n\t\t};\n\t}\n\n\tfunction transformStr(node, ctx) {\n\t\treturn literal(node.s.valueOf());\n\t}\n\n\tfunction transformTuple(node, ctx) {\n\t\tvar call = {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: makeVariableName(\"__pythonRuntime.objects.tuple\"),\n\t\t\targuments: transform(node.elts, ctx)\n\t\t};\n\t\treturn call;\n\t}\n\n\tfunction transformSubscript(node, ctx) {\n\t\t//TODO: Do silly pythonic list offset logic\n\t\tvar val = transform(node.value, ctx);\n\t\tif ( node.slice.value ) {\n\t\t\tvar lu = transform(node.slice.value, ctx);\n\t\t\tlu = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName(\"__pythonRuntime.ops.subscriptIndex\"),\n\t\t\t\targuments: [val, lu]\n\t\t\t};\n\t\t\treturn {\n\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\tcomputed: true,\n\t\t\t\tobject: val,\n\t\t\t\tproperty: lu\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: makeVariableName('__pythonRuntime.internal.slice'),\n\t\t\targuments:[\n\t\t\t\tval,\n\t\t\t\tnode.slice.lower ? transform(node.slice.lower, ctx) : ident('undefined'),\n\t\t\t\tnode.slice.upper ? transform(node.slice.upper, ctx) : ident('undefined'),\n\t\t\t\tnode.slice.step ? transform(node.slice.step, ctx) : ident('undefined'),\n\t\t\t]\n\t\t};\n\t}\n\n\tfunction transformPass(node, ctx) {\n\t\treturn {type: \"EmptyStatement\"};\n\t}\n\n\tfunction transformUnaryOp(node, ctx) {\n\t\tvar argument = transform(node.operand, ctx);\n\n\t\tvar fxOps = {\n\t\t\t\"Add\": \"add\",\n\t\t\t\"Mult\": \"multiply\",\n\t\t};\n\t\tvar opName = getOpName(node.op);\n\n\t\tif ( opName in fxOps  ) {\n\t\t\tvar call = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName(\"__pythonRuntime.ops.\" + fxOps[opName]),\n\t\t\t\targuments: [argument]\n\t\t\t};\n\t\t\treturn call;\n\t\t}\n\n\t\tvar operators = {\n\t\t\t\"Not\": \"!\",\n\t\t\t\"USub\": \"-\",\n\t\t\t\"Invert\": \"~\"\n\t\t};\n\n\t\tif ( !(opName in operators) ) abort(\"Unknown unary operator: \" + opName);\n\n\t\treturn {\n\t\t\ttype: \"UnaryExpression\",\n\t\t\targument: argument,\n\t\t\toperator: operators[opName]\n\t\t};\n\t\t\n\t}\n\n\tfunction transformWhile(node, ctx) {\n\t\tif ( node.orelse && node.orelse.length > 0 ) abort(\"else: statement for while unsupported.\");\n\t\treturn {\n\t\t\ttype: \"WhileStatement\",\n\t\t\ttest: transform(node.test, ctx),\n\t\t\tbody: {type: \"BlockStatement\", body: ensureStatement(transform(node.body, ctx))}\n\t\t};\t\n\t}\n\n\tmodule.exports = transform;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Sk = __webpack_require__(1);\n\n\tfunction splat(e) {\n\t\tconsole.log(\"GOT ERROR!\");\n\t\tconsole.log(e, e.extra);\n\t\tconsole.log(JSON.stringify(e.extra.node, function(k,  o) {\n\t\t\tif ( k == 'type' ) return Sk.nameForToken(o);\n\t\t\telse if ( k == 'children' ) return o;\n\t\t\telse if ( k ===  '' ) return o;\n\t\t\telse if ( !isNaN(parseInt(k)) ) return o;\n\t\t\telse return undefined;\n\t\t}, '  '));\n\t}\n\n\tfunction improveError(e, options, code) {\n\t\tvar r;\n\t\tif ( e.context && e.context.length >0 ) {\n\t\t\tr = e.context[0];\t\n\t\t}\n\n\t\tif ( e.extra && e.extra.node ) {\n\t\t\tif ( !r ) {\n\t\t\t\tr = [e.extra.node.loc.start.line,e.extra.node.loc.start.column];\n\t\t\t}\n\t\t}\n\n\t\tif ( r ) {\n\t\t\tsetErrorPos(e, r[0], r[1]);\n\t\t}\n\n\t\tif ( options.friendlyErrors && e.extra ) {\n\t\t\te.message = makeErrorFriendly(e, code);\n\t\t}\n\t}\n\n\tfunction setErrorPos(e, line, col) {\n\t\te.loc = {line: line, column: col};\n\t\te.line = line;\n\t\te.column = col;\n\t}\n\n\tfunction friendlyString(s) {\n\t\tswitch (s) {\n\t\tcase 'if_stmt': return 'if statement';\n\t\tcase 'while_stmt': return 'while statement';\n\t\tcase 'funcdef': return 'function';\n\t\tdefault: return '?' + s + '?';\n\t\t} \n\t}\n\n\tfunction nodeToType(n) {\n\t\tvar type = Sk.nameForToken(n.type);\n\t\tif ( type === 'suite' ) return nodeToType(n.children[0]);\n\t\treturn friendlyString(type);\n\t}\n\n\tfunction makeErrorFriendly(e, code) {\n\t\t//console.log(\"EX\", e.message, e.extra);\n\t\tif ( e.extra.kind == \"DAG_MISS\" ) {\n\t\t\tif ( e.extra.expected.indexOf('T_COLON') !== -1 ) {\n\t\t\t\t//We might be missing a colon.\n\t\t\t\tvar after = (e.context && e.context[2] ? e.context[2] : e.extra.found_val).replace(/\\s+$/,'');\n\t\t\t\tvar lc = e.extra.node.children[e.extra.node.children.length-1];\n\t\t\t\tif ( lc.value === 'else' ) after = 'else';\n\n\t\t\t\tif ( e.extra.found == 'T_SEMI' ) {\n\t\t\t\t\treturn \"Replace the `;` at the end of `\" + after + \"` with a `:`\";\n\t\t\t\t} else if ( e.extra.found == 'T_NEWLINE' ) {\n\t\t\t\t\treturn \"Need a `:` on the end of the line following `\" + after + \"`.\";\n\t\t\t\t} else if ( e.extra.found == 'T_NAME' ) {\n\t\t\t\t\treturn \"Need a `:` after `\" + after + \"`.\";\n\t\t\t\t} else if ( e.extra.found == 'T_EQUAL' ) {\n\t\t\t\t\treturn \"Can't assign to a variable within the condition of an \" + friendlyString(e.extra.inside) + \".  Did you mean to use `==` instead of `=`?\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( e.extra.expected.indexOf('T_DEDENT') !== -1 ) {\n\t\t\t\tif ( e.extra.found_val.toLowerCase() === 'else' ) {\n\t\t\t\t\treturn \"`else` needs to line up with its `if`.\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"Indentation error.\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( e.extra.expected.indexOf('T_INDENT') !== -1 ) {\n\t\t\t\tvar lc = e.extra.parent || e.extra.node;\n\t\t\t\tvar name  = nodeToType(lc);\n\t\t\t\tif ( name === 'if statement' ) {\n\t\t\t\t\t//Scan for the most recent part of the ifstatement.\n\t\t\t\t\tfor ( var i = 0; i < lc.children.length; ++i ) {\n\t\t\t\t\t\tif ( [\"if\", \"elif\", \"else\"].indexOf(lc.children[i].value) !== -1 ) {\n\t\t\t\t\t\t\tname = lc.children[i].value + ' statement';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( lc.value === 'else' ) name = 'else statement';\n\t\t\t\treturn 'Empty ' + name + '. Put 4 spaces in front of statements inside the ' + name + '.';\n\t\t\t}\n\n\t\t\tif ( e.extra.found === 'T_NAME' ) {\n\t\t\t\tswitch ( e.extra.found_val ) {\n\t\t\t\t\tcase 'else':\n\t\t\t\t\tcase 'elif':\n\t\t\t\t\t\treturn '`' + e.extra.found_val + '` must be paired with an `if`';\n\t\t\t\t\tcase 'elseif':\n\t\t\t\t\t\treturn '`elseif` should be shortened to `elif`';\n\t\t\t\t} \n\t\t\t}\n\n\t\t\tif ( e.extra.found === 'T_AMPER' && e.extra.inside == 'and_expr' ) {\n\t\t\t\treturn 'Python uses the word `and` instead of `&&` for boolean AND expressions.';\n\t\t\t}\n\n\n\t\t\tif ( e.extra.inside === 'trailer' ) {\n\t\t\t\t//We are parsing either an arglist or a subscript.\n\t\t\t\tif ( e.extra.expected.indexOf('T_RPAR') === 0 ) {\n\t\t\t\t\t//Expected ), must be a arglsit;\n\t\t\t\t\tif ( e.line > e.extra.node.lineno ) {\n\t\t\t\t\t\t//Our arglist is incomplete, and we have made it to the next line,.\n\t\t\t\t\t\t//Likely they just forgot to close their ()'s\n\t\t\t\t\t\tsetErrorPos(e, e.extra.node.lineno, e.extra.node.col_offset);\n\t\t\t\t\t\tvar t = e.extra.node.loc;\n\t\t\t\t\t\te.context = [\n\t\t\t\t\t\t\t[t.start.line,t.start.column],\n\t\t\t\t\t\t\t[t.end.line,t.end.column]\n\t\t\t\t\t\t];\n\t\t\t\t\t\treturn 'Unclosed `(` in function arguments.' + e.extra.node.lineno;\n\n\t\t\t\t\t}\n\t\t\t\t\treturn 'Function calls paramaters must be seperated by `,`s';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( e.extra.found === 'T_INDENT' ) {\n\t\t\t\tif ( e.extra.expected.indexOf('stmt') !== -1 ) {\n\t\t\t\t\treturn 'Too much indentation at the beginning of this line.';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( e.extra.expected.indexOf('subscriptlist') === 0 ) {\n\t\t\t\treturn \"Malformed subscript\";\n\t\t\t}\n\n\t\t\tif ( e.extra.expected.indexOf('T_NEWLINE') !== -1 ) {\n\t\t\t\tvar n = e.extra.node;\n\t\t\t\t\n\t\t\t\tif ( e.extra.node.children[0] ) {\n\t\t\t\t\tvar n = e.extra.node.children[0];\n\t\t\t\t\tvar previousType = Sk.nameForToken(n.type);\n\t\t\t\t\n\t\t\t\t\tif ( previousType == 'small_stmt' ) {\n\t\t\t\t\t\twhile ( n.children && n.children.length == 1 ) n = n.children[0];\n\t\t\t\t\t\tvar what = code.substring(n.range[0], n.range[1]);\n\t\t\t\t\t\treturn 'If you want to call `' + what +'` as function, you need `()`\\'s';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'Unexpected token: ' + e.message;\n\t\t} else if ( e.extra.kind == \"CLASSIFY\" ) {\n\t\t\tif ( e.extra.value === '\"' ) return 'Unterminated string. Add a matching `\"` at the end of your string.';\n\t\t\treturn 'Unterminated `' + e.extra.value + '`';\n\t\t} else if ( e.extra.kind == \"STRING_EOF\" ) {\n\t\t\treturn 'Unterminated muti-line string. Add a matching `\"\"\"` at the end of your string.';\n\t\t} else if ( e.extra.kind == \"STATEMENT_EOF\" ) {\n\t\t\tif ( e.extra.parenlev > 0 ) {\n\t\t\t\tvar top = e.extra.parenstack[e.extra.parenstack.length-1];\n\t\t\t\tvar kind = top[0];\n\t\t\t\tvar types = '([{';\n\t\t\t\tvar pair = ')]}';\n\t\t\t\tvar close = pair[types.indexOf(kind)];\n\t\t\t\tsetErrorPos(e, top[1], top[2]-1);\n\t\t\t\treturn 'Unmatched `' + kind + '`.  Every opening `' + kind + '` needs a closing `' + close + '` to match it.';\n\t\t\t}\n\t\t\treturn e.message;\n\t\t}\n\n\t\treturn e.message;\n\t\t\n\t\t\n\t}\n\n\tmodule.exports = improveError;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (root, factory) {\n\t  'use strict';\n\t  if(true)\n\t    module.exports = factory();\n\t  else if(typeof define === 'function' && define.amd)\n\t    define([], factory);\n\t  else if(typeof exports === 'object')\n\t    exports[\"__pythonRuntime\"] = factory();\n\t  else\n\t    root[\"__pythonRuntime\"] = factory();\n\t}(this, function() {\n\t  'use strict';\n\t  var pythonRuntime = {\n\t    internal: {\n\t      // Only used within runtime\n\t      isSeq: function (a) { return a && (a._type === \"list\" || a._type === \"tuple\"); },\n\t      slice: function (obj, start, end, step) {\n\t        var slice;\n\t        if ( typeof obj === 'string' ) slice = function(x,y) { return obj.substring(x,y); }\n\t        else slice = obj.slice.bind(obj);\n\n\t        if (step == null || step === 0) step = 1; // TODO: step === 0 is a runtime error\n\t        if (start == null) {\n\t          if (step < 0) start = obj.length - 1;\n\t          else start = 0;\n\t        } else if (start < 0) start += obj.length;\n\t        if (end == null) {\n\t          if (step < 0) end = -1;\n\t          else end = obj.length;\n\t        } else if (end < 0) end += obj.length;\n\n\t        var ret = new pythonRuntime.objects.list(), tmp, i;\n\t        if (step < 0) {\n\t          tmp = slice(end + 1, start + 1);\n\t          for (i = tmp.length - 1; i >= 0; i += step) ret.append(tmp[i]);\n\t        } else {\n\t          tmp = slice(start, end);\n\t          if (step === 1 && typeof tmp !== 'string') ret = pythonRuntime.utils.createList(tmp);\n\t          else for (i = 0; i < tmp.length; i += step) ret.append(tmp[i]);\n\t        }\n\t        if ( typeof obj === 'string' ) return ret.join('');\n\t        return ret;\n\t      },\n\t      isJSArray: Array.isArray || function(obj) {\n\t        return toString.call(obj) === '[object Array]';\n\t      }\n\t    },\n\n\t    utils: {\n\t      createDict: function () {\n\t        var ret = new pythonRuntime.objects.dict();\n\t        if (arguments.length === 1 && arguments[0] instanceof Object)\n\t          for (var k in arguments[0]) ret[k] = arguments[0][k];\n\t        else\n\t          throw TypeError(\"createDict expects a single JavaScript object\");\n\t        return ret;\n\t      },\n\t      createParamsObj: function () {\n\t        // In: expr, expr, ..., {id:expr, __kwp:true}, {id:expr, __kwp:true}, ...\n\t        // Out: {formals:[expr, expr, ...], keywords:{id:expr, id:expr, ...}}\n\t        var params = { formals: new pythonRuntime.objects.list(), keywords: new PythonDict() };\n\t        for (var i = 0; i < arguments.length; i++) {\n\t          if (arguments[i] && arguments[i].__kwp === true) {\n\t            for (var k in arguments[i])\n\t              if (k !== '__kwp') params.keywords[k] = arguments[i][k];\n\t          }\n\t          else params.formals.push(arguments[i]);\n\t        }\n\t        return params;\n\t      },\n\t      convertToList: function (list) {\n\t        Object.defineProperties(list, pythonRuntime.utils.listPropertyDescriptor);\n\t        return list;\n\t      },\n\t      convertToDict: function (dict) {\n\t        Object.defineProperties(dict, pythonRuntime.utils.dictPropertyDescriptor);\n\t        return dict;\n\t      }, \n\t      listPropertyDescriptor: {\n\t          \"_type\": {\n\t            get: function () { return 'list'; },\n\t            enumerable: false\n\t          },\n\t          \"_isPython\": {\n\t            get: function () { return true; },\n\t            enumerable: false\n\t          },\n\t          \"append\": {\n\t            value: function (x) {\n\t              this.push(x);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"clear\": {\n\t            value: function () {\n\t              this.splice(0, this.length);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"copy\": {\n\t            value: function () {\n\t              return this.slice(0);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"count\": {\n\t            value: function (x) {\n\t              var c = 0;\n\t              for (var i = 0; i < this.length; i++)\n\t                if (this[i] === x) c++;\n\t              return c;\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"equals\": {\n\t            value: function (x) {\n\t              try {\n\t                if (this.length !== x.length) return false;\n\t                for (var i = 0; i < this.length; i++) {\n\t                  if (this[i].hasOwnProperty(\"equals\")) {\n\t                    if (!this[i].equals(x[i])) return false;\n\t                  } else if (this[i] !== x[i]) return false;\n\t                }\n\t                return true;\n\t              }\n\t              catch (e) { }\n\t              return false;\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"extend\": {\n\t            value: function (L) {\n\t              for (var i = 0; i < L.length; i++) this.push(L[i]);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"index\": {\n\t            value: function (x) {\n\t              return this.indexOf(x);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"indexOf\": {\n\t            value: function (x, fromIndex) {\n\t              try {\n\t                for (var i = fromIndex ? fromIndex : 0; i < this.length; i++) {\n\t                  if (this[i].hasOwnProperty(\"equals\")) {\n\t                    if (this[i].equals(x)) return i;\n\t                  } else if (this[i] === x) return i;\n\t                }\n\t              }\n\t              catch (e) { }\n\t              return -1;\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"insert\": {\n\t            value: function (i, x) {\n\t              this.splice(i, 0, x);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"pop\": {\n\t            value: function (i) {\n\t              if (arguments.length<1) i = this.length - 1;\n\t              var item = this[i];\n\t              this.splice(i, 1);\n\t              return item;\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"_pySlice\": {\n\t            value: function (start, end, step) {\n\t              return pythonRuntime.internal.slice(this, start, end, step);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"remove\": {\n\t            value: function (x) {\n\t              this.splice(this.indexOf(x), 1);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"sort\": {\n\t            value: function(x, reverse) {\n\t              var list2 = this.slice(0);\n\t              var apply_key = function(a, numerical) {\n\t                var list3 = list2.map(x);\n\t                // construct a dict that maps the listay before and after the map\n\t                var mapping = {}\n\t                for(var i in list3) mapping[list3[i]] = list2[i];\n\t                if(numerical)\n\t                  list3.sort(function(a, b) { return a - b; });\n\t                else\n\t                  list3.sort()\n\t                for(var i in a) a[i] = mapping[list3[i]];\n\t              }\n\t              for(var i in this) {\n\t                if(typeof this[i] !== 'number' || !isFinite(this[i])) {\n\t                  if(typeof x != 'undefined') {\n\t                    apply_key(this, false);\n\t                  }\n\t                  else {\n\t                    list2.sort();\n\t                    for (var j in this) this[j] = list2[j];\n\t                  }\n\t                  if(reverse)\n\t                    this.reverse();\n\t                  return;\n\t                }\n\t              }\n\t              if(typeof x != 'undefined') {\n\t                apply_key(this, true);\n\t              }\n\t              else {\n\t                list2.sort(function(a, b) { return a - b; });\n\t                for(var i in this) this[i] = list2[i];\n\t              }\n\t              if(reverse)\n\t                this.reverse();\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"toString\": {\n\t            value: function () {\n\t              return '[' + this.join(', ') + ']';\n\t            },\n\t            enumerable: false\n\t          }\n\t      },\n\t      createList: function () {\n\t        var ret = new pythonRuntime.objects.list();\n\t        if (arguments.length === 1 && arguments[0] instanceof Array)\n\t          for (var i in arguments[0]) ret.push(arguments[0][i]);\n\t        else\n\t          for (var i in arguments) ret.push(arguments[i]);\n\t        return ret;\n\t      },\n\t      dictPropertyDescriptor: {\n\t        \"_type\": {\n\t          get: function () { return 'dict';},\n\t          enumerable: false\n\t        },\n\t        \"_isPython\": {\n\t          get: function () { return true; },\n\t          enumerable: false\n\t        },\n\t        \"items\": {\n\t          value: function () {\n\t            var items = new pythonRuntime.objects.list();\n\t            for (var k in this) items.append(new pythonRuntime.objects.tuple(k, this[k]));\n\t            return items;\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"length\": {\n\t          get: function () {\n\t            return Object.keys(this).length;\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"clear\": {\n\t          value: function () {\n\t            for (var i in this) delete this[i];\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"get\": {\n\t          value: function (key, def) {\n\t            if (key in this) return this[key];\n\t            else if (def !== undefined) return def;\n\t            return null;\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"keys\": {\n\t          value: function () {\n\t            return Object.keys(this);\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"pop\": {\n\t          value: function (key, def) {\n\t            var value;\n\t            if (key in this) {\n\t              value = this[key];\n\t              delete this[key];\n\t            } else if (def !== undefined) value = def;\n\t            else return new Error(\"KeyError\");\n\t            return value;\n\t          },\n\t          enumerable: false\n\t        }, \"values\": {\n\t          value: function () {\n\t            var values = new pythonRuntime.objects.list();\n\t            for (var key in this) values.append(this[key]);\n\t            return values;\n\t          },\n\t          enumerable: false\n\t        }\n\t      }\n\t    },\n\t    ops: {\n\t      add: function (a, b) {\n\t        if (typeof a === 'object' && pythonRuntime.internal.isSeq(a) && pythonRuntime.internal.isSeq(b)) {\n\t          if (a._type !== b._type)\n\t            throw TypeError(\"can only concatenate \" + a._type + \" (not '\" + b._type + \"') to \" + a._type);\n\t          var ret;\n\t          if (a._type === 'list') ret = new pythonRuntime.objects.list();\n\t          else if (a._type === 'tuple') ret = new pythonRuntime.objects.tuple();\n\t          if (ret) {\n\t            for (var i = 0; i < a.length; i++) ret.push(a[i]);\n\t            for (var i = 0; i < b.length; i++) ret.push(b[i]);\n\t            return ret;\n\t          }\n\t        }\n\t        return a + b;\n\t      },\n\t      in: function (a, b, n) {\n\t        var r = b.hasOwnProperty('indexOf') ? b.indexOf(a) >= 0 : a in b;\n\t        return n ? !r : r;\n\t      },\n\t      multiply: function (a, b) {\n\t        // TODO: non-sequence operand must be an integer\n\t        if ( typeof a === 'object' ) {\n\t          if (pythonRuntime.internal.isSeq(a) && !isNaN(parseInt(b))) {\n\t            var ret;\n\t            if (a._type === 'list') ret = new pythonRuntime.objects.list();\n\t            else if (a._type === 'tuple') ret = new pythonRuntime.objects.tuple();\n\t            if (ret) {\n\t              for (var i = 0; i < b; i++)\n\t                for (var j = 0; j < a.length; j++) ret.push(a[j]);\n\t              return ret;\n\t            }\n\t          } else if (pythonRuntime.internal.isSeq(b) && !isNaN(parseInt(a))) {\n\t            var ret;\n\t            if (b._type === 'list') ret = new pythonRuntime.objects.list();\n\t            else if (b._type === 'tuple') ret = new pythonRuntime.objects.tuple();\n\t            if (ret) {\n\t              for (var i = 0; i < a; i++)\n\t                for (var j = 0; j < b.length; j++) ret.push(b[j]);\n\t              return ret;\n\t            }\n\t          }\n\t        }\n\t        return a * b;\n\t      },\n\t      subscriptIndex: function (o, i) {\n\t        if ( i >= 0 ) return i;\n\t        if ( pythonRuntime.internal.isSeq(o) ) return o.length + i;\n\t        if ( pythonRuntime.internal.isJSArray(o) ) return o.length + i;\n\t        if ( typeof o === \"string\" ) return o.length + i;\n\t        return i;\n\t      }\n\t    },\n\n\t    objects: {\n\t      dict: function () {\n\t        var obj = new PythonDict();\n\t        for (var i = 0; i < arguments.length; ++i ) obj[arguments[i][0]] = arguments[i][1];\n\t        return obj;\n\t      },\n\t      list: function () {\n\t        var arr = [];\n\t        arr.push.apply(arr, arguments);\n\t        pythonRuntime.utils.convertToList(arr);\n\t        return arr;\n\t      },\n\t      tuple: function () {\n\t        var arr = [];\n\t        arr.push.apply(arr, arguments);\n\t        Object.defineProperty(arr, \"_type\",\n\t        {\n\t          get: function () { return 'tuple'; },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"_isPython\",\n\t        {\n\t          get: function () { return true; },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"count\",\n\t        {\n\t          value: function (x) {\n\t            var c = 0;\n\t            for (var i = 0; i < this.length; i++)\n\t              if (this[i] === x) c++;\n\t            return c;\n\t          },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"equals\",\n\t        {\n\t          value: function (x) {\n\t            try {\n\t              if (this.length !== x.length) return false;\n\t              for (var i = 0; i < this.length; i++) {\n\t                if (this[i].hasOwnProperty(\"equals\")) {\n\t                  if (!this[i].equals(x[i])) return false;\n\t                } else if (this[i] !== x[i]) return false;\n\t              }\n\t              return true;\n\t            }\n\t            catch (e) { }\n\t            return false;\n\t          },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"index\",\n\t        {\n\t          value: function (x) {\n\t            return this.indexOf(x);\n\t          },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"indexOf\",\n\t        {\n\t          value: function (x, fromIndex) {\n\t            try {\n\t              for (var i = fromIndex ? fromIndex : 0; i < this.length; i++) {\n\t                if (this[i].hasOwnProperty(\"equals\")) {\n\t                  if (this[i].equals(x)) return i;\n\t                } else if (this[i] === x) return i;\n\t              }\n\t            }\n\t            catch (e) { }\n\t            return -1;\n\t          },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"_pySlice\",\n\t        {\n\t          value: function (start, end, step) { \n\t            return pythonRuntime.internal.slice(this, start, end, step);\n\t          },\n\t            enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"toString\",\n\t        {\n\t          value: function () {\n\t            var s = '(' + this.join(', ');\n\t            if (this.length === 1) s += ',';\n\t            s += ')';\n\t            return s;\n\t          },\n\t          enumerable: false\n\t        });\n\t        return arr;\n\t      }\n\t    },\n\n\t    // Python built-in functions\n\n\t    functions: {\n\t      abs: function(x) {\n\t        return Math.abs(x);\n\t      },\n\t      all: function(iterable) {\n\t        for (var i in iterable) if (pythonRuntime.functions.bool(iterable[i]) !== true) return false;\n\t        return true;\n\t      },\n\t      any: function(iterable) {\n\t        for (var i in iterable) if (pythonRuntime.functions.bool(iterable[i]) === true) return true;\n\t        return false;\n\t      },\n\t      ascii: function(obj) {\n\t        var s = pythonRuntime.functions.repr(obj),\n\t            asc = \"\",\n\t            code;\n\t        for (var i = 0; i < s.length; i++) {\n\t          code = s.charCodeAt(i);\n\t          if (code <= 127) asc += s[i];\n\t          else if (code <= 0xFF) asc += \"\\\\x\" + code.toString(16);\n\t          else if (0xD800 <= code && code <= 0xDBFF) { // UCS-2 for the astral chars\n\t            // if (i+1 >= s.length) throw \"High surrogate not followed by low surrogate\"; // Is this needed?\n\t            code = ((code-0xD800)*0x400)+(s.charCodeAt(++i)-0xDC00)+0x10000;\n\t            asc += \"\\\\U\" + (\"000\"+code.toString(16)).slice(-8);\n\t          } else if (code <= 0xFFFF) asc += \"\\\\u\" + (\"0\"+code.toString(16)).slice(-4);\n\t          else if (code <= 0x10FFFF) asc += \"\\\\U\" + (\"000\"+code.toString(16)).slice(-8);\n\t          else; // Invalid value, should probably throw something. It should never get here though as strings shouldn't contain them in the first place\n\t        }\n\t        return asc;\n\t      },\n\t      bool: function(x) {\n\t        return !(x === undefined || // No argument\n\t                 x === null || // None\n\t                 x === false || // False\n\t                 x === 0 || // Zero\n\t                 x.length === 0 || // Empty Sequence\n\t                 // TODO: Empty Mapping, needs more support for python mappings first\n\t                 (x.__bool__ !== undefined && x.__bool__() === false) || // If it has bool conversion defined\n\t                 (x.__len__ !== undefined && (x.__len__() === false || x.__len__() === 0))); // If it has length conversion defined\n\t      },\n\t      chr: function(i) {\n\t        return String.fromCharCode(i); // TODO: Error code for not 0 <= i <= 1114111\n\t      },\n\t      divmod: function(a, b) {\n\t        return pythonRuntime.objects.tuple(Math.floor(a/b), a%b);\n\t      },\n\t      enumerate: function(iterable, start) {\n\t        start = start || 0;\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in iterable) ret.push(new pythonRuntime.objects.tuple(start++, iterable[i]));\n\t        return ret;\n\t      },\n\t      filter: function(fn, iterable) {\n\t        fn = fn || function () { return true; };\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in iterable) if (fn(iterable[i])) ret.push(iterable[i]);\n\t        return ret;\n\t      },\n\t      float: function(x) {\n\t        if (x === undefined) return 0.0;\n\t        else if (typeof x == \"string\") { // TODO: Fix type check\n\t          x = x.trim().toLowerCase();\n\t          if ((/^[+-]?inf(inity)?$/i).exec(x) !== null) return Infinity*(x[0]===\"-\"?-1:1);\n\t          else if ((/^nan$/i).exec(x) !== null) return NaN;\n\t          else return parseFloat(x);\n\t        } else if (typeof x == \"number\") { // TODO: Fix type check\n\t          return x; // TODO: Get python types working right so we can return an actual float\n\t        } else {\n\t          if (x.__float__ !== undefined) return x.__float__();\n\t          else return null; // TODO: Throw TypeError: float() argument must be a string or a number, not '<type of x>'\n\t        }\n\t      },\n\t      hex: function(x) {\n\t        return x.toString(16);\n\t      },\n\t      int: function (s) {\n\t        return parseInt(s);\n\t      },\n\t      len: function (o) {\n\t        return o.length;\n\t      },\n\t      list: function (iterable) {\n\t        var ret = new pythonRuntime.objects.list();\n\t        if ( arguments.length == 0 ) return ret;\n\t        if ( arguments.length > 1 ) throw new TypeError('list() takes at most 1 argument (' + arguments.length + ' given)');\n\t        if (iterable instanceof Array) for (var i in iterable) ret.push(iterable[i]);\n\t        else for (var i in iterable) ret.push(i);\n\t        return ret;\n\t      },\n\t      map: function(fn, iterable) {\n\t        // TODO: support additional iterables passed\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in iterable) ret.push(fn(iterable[i]));\n\t        return ret;\n\t      },\n\t      max: function(arg1, arg2) {\n\t        // TODO: support optional keyword-only arguments\n\t        // TODO: empty iterable raises Python ValueError\n\t        if (!arg2) { // iterable\n\t          var max = null;\n\t          for (var i in arg1) if (max === null || arg1[i] > max) max = arg1[i];\n\t          return max;\n\t        } else return arg1 >= arg2 ? arg1 : arg2;\n\t      },\n\t      min: function(arg1, arg2) {\n\t        // TODO: support optional keyword-only arguments\n\t        // TODO: empty iterable raises Python ValueError\n\t        if (!arg2) { // iterable\n\t          var max = null;\n\t          for (var i in arg1) if (max === null || arg1[i] < max) max = arg1[i];\n\t          return max;\n\t        } else return arg1 <= arg2 ? arg1 : arg2;\n\t      },\n\t      oct: function(x) {\n\t        return x.toString(8);\n\t      },\n\t      ord: function(c) {\n\t        return c.charCodeAt(0);\n\t      },\n\t      pow: function(x, y, z) {\n\t        return z ? Math.pow(x, y) % z : Math.pow(x, y);\n\t      },\n\t      print: function () {\n\t        var s = \"\";\n\t        for (var i = 0; i < arguments.length; i++)\n\t          s += i === 0 ? arguments[i] : \" \" + arguments[i];\n\t        console.log(s);\n\t      },\n\t      range: function (start, stop, step) {\n\t        if (stop === undefined) {\n\t          stop = start;\n\t          start = 0;\n\t          step = 1;\n\t        }\n\t        else if (step === undefined) step = 1;\n\t        var len = ~~((stop - start) / step); //~~ is a fast floor\n\t        if ( len < 0 ) return pythonRuntime.utils.convertToList([]);\n\t        var r = new Array(len);\n\t        var element = 0;\n\n\t        var i = start;\n\t        while (i < stop && step > 0 || i > stop && step < 0) {\n\t          r[element++] = i;\n\t          i += step;\n\t        }\n\n\t        pythonRuntime.utils.convertToList(r);\n\t        return r;\n\t      },\n\t      repr: function (obj) {\n\t        if (typeof obj === 'string') return \"'\" + obj + \"'\"; // TODO: Patch until typesystem comes up.\n\t        if (obj.__repr__ !== undefined) return obj.__repr__();\n\t        else if (obj.__class__ !== undefined && obj.__class__.module !== undefined && obj.__class__.__name__) {\n\t          return '<'+obj.__class__.__module__+'.'+obj.__class__.__name__+' object>';\n\t        } else return obj.toString(); // Raise a please report warning here, we should never reach this piece of code\n\t      },\n\t      reversed: function (seq) {\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in seq) ret.push(seq[i]);\n\t        return ret.reverse();\n\t      },\n\t      round: function (num, ndigits) {\n\t        if (ndigits) {\n\t          var scale = Math.pow(10, ndigits);\n\t          return Math.round(num * scale) / scale;\n\t        }\n\t        return Math.round(num);\n\t      },\n\t      sorted: function (iterable, key, reverse) {\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in iterable) ret.push(iterable[i]);\n\t        if(key) ret.sort(key); else ret.sort();\n\t        if (reverse) ret.reverse();\n\t        return ret;\n\t      },\n\t      str: function (obj) {\n\t        return obj.toString();\n\t      },\n\t      sum: function (iterable, start) {\n\t        // TODO: start can't be a string\n\t        var ret = start || 0;\n\t        for (var i in iterable) ret += iterable[i];\n\t        return ret;\n\t      },\n\t      tuple: function (iterable) {\n\t        var ret = new pythonRuntime.objects.tuple();\n\t        for (var i in iterable) ret.push(iterable[i]);\n\t        return ret;\n\t      }\n\t    },\n\n\t    // Python imports\n\t    // TODO: from x import y, z\n\n\t    imports: {\n\t      random: {\n\t        random: function () { return Math.random(); }\n\t      }\n\t    }\n\t  };\n\n\t  function PythonDict() {\n\n\t  }\n\n\t  Object.defineProperties(PythonDict.prototype, pythonRuntime.utils.dictPropertyDescriptor);\n\t  return pythonRuntime;\n\t}));\n\n\n\n/***/ }\n/******/ ])\n});\n;\n},{}],2:[function(require,module,exports){\nwindow.aetherFilbert = require('skulpty');\nwindow.aetherFilbertLoose = require('skulpty');\n\n},{\"skulpty\":1}]},{},[2]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FldGhlci9idWlsZC9weXRob24uanM/ZmQ0MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsZ0JBQWdCLFVBQVUsVUFBVSwwQ0FBMEMsd0JBQXdCLG9CQUFvQiw4Q0FBOEMsWUFBWSxZQUFZLG1DQUFtQyxpQkFBaUIsZ0JBQWdCLHNCQUFzQixvQkFBb0IsMENBQTBDLFlBQVksV0FBVyxZQUFZLFNBQVMsR0FBRztBQUMxWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsR0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLFNBQVM7QUFDbkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxFQUFFO0FBQ2QsWUFBWSxFQUFFO0FBQ2QsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaUNBQWlDO0FBQ3RDO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxpQkFBaUI7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLE9BQU87QUFDcEIsYUFBYSxLQUFLO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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RUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEI7O0FBRUEsRUFBRTs7OztBQUlGOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2Q0FBNkMsNENBQTRDO0FBQ3pGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2Q0FBNkMsNENBQTRDO0FBQ3pGO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4Q0FBOEMsa0RBQWtEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7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QUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsRUFBRTtBQUNGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxTQUFTLGtFQUFrRTtBQUMzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxTQUFTLGtFQUFrRTtBQUMzRTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixnRUFBZ0UsTUFBTTtBQUN0RSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBLFNBQVMsOENBQThDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2QsbURBQW1ELE1BQU07QUFDekQ7QUFDQSxTQUFTLGtFQUFrRTtBQUMzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsbURBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxTQUFTLGtFQUFrRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsU0FBUyxrRUFBa0U7QUFDM0UsbURBQW1ELE1BQU07QUFDekQsZ0NBQWdDLE1BQU0sRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixXQUFXLGNBQWMsY0FBYztBQUNqRSw0QkFBNEIsV0FBVyxjQUFjLFdBQVc7QUFDaEUsK0NBQStDLElBQUksZ0JBQWdCLElBQUk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFdBQVcsY0FBYyxXQUFXO0FBQzNELHlCQUF5QixXQUFXLGNBQWMsV0FBVztBQUM3RCw0QkFBNEIsSUFBSSxnQkFBZ0IsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixRQUFRLGVBQWUsSUFBSSxnQkFBZ0IsSUFBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixXQUFXLGlCQUFpQixJQUFJLGdCQUFnQixJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFdBQVcsaUJBQWlCLFFBQVEsZUFBZSxJQUFJO0FBQzVFLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsUUFBUSxnQkFBZ0IsWUFBWSxZQUFZO0FBQ3hFLHVDQUF1QyxJQUFJLGdCQUFnQixJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUSxjQUFjLFdBQVcsZ0JBQWdCLEtBQUs7QUFDMUUsNkJBQTZCLElBQUksZ0JBQWdCLElBQUk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRLGdCQUFnQixRQUFRLGNBQWMsV0FBVztBQUM1RSw4QkFBOEIsV0FBVyxnQkFBZ0IsSUFBSTtBQUM3RCxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFFBQVEsY0FBYyxXQUFXLGNBQWM7QUFDcEUscUNBQXFDLElBQUksZ0JBQWdCLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVEsY0FBYyxXQUFXLGNBQWMsV0FBVztBQUM1RSwrQkFBK0IsSUFBSSxnQkFBZ0IsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUSxzQkFBc0IsUUFBUTtBQUMxRCxzQkFBc0IsV0FBVyxjQUFjLElBQUksZ0JBQWdCLElBQUk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUSxjQUFjLFFBQVEsY0FBYyxRQUFRO0FBQ3hFLGdDQUFnQyxJQUFJLGdCQUFnQixJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsV0FBVyxjQUFjLFdBQVc7QUFDNUQsMEJBQTBCLFdBQVcsZ0JBQWdCLElBQUksZ0JBQWdCLElBQUk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFdBQVcsY0FBYyxXQUFXO0FBQzdELDJCQUEyQixJQUFJLGdCQUFnQixJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFFBQVEsY0FBYyxRQUFRLGFBQWEsSUFBSTtBQUNwRSwwQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFdBQVcsZUFBZSxJQUFJLGdCQUFnQixJQUFJO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFdBQVcsZ0JBQWdCLFdBQVc7QUFDL0QsMkJBQTJCLElBQUksZUFBZSxJQUFJLGdCQUFnQixJQUFJO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFFBQVEsY0FBYyxRQUFRLGlCQUFpQixRQUFRO0FBQzFFLGdDQUFnQyxJQUFJLGdCQUFnQixJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixXQUFXLGVBQWUsSUFBSSxnQkFBZ0IsSUFBSTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRLGVBQWUsSUFBSSxnQkFBZ0IsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixJQUFJLGdCQUFnQixJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsSUFBSSxnQkFBZ0IsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLElBQUksZ0JBQWdCLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixJQUFJLGdCQUFnQixJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsVUFBVSxZQUFZLFdBQVcsZ0JBQWdCLElBQUk7QUFDMUUsa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFRLGNBQWMsWUFBWSxZQUFZLFFBQVE7QUFDMUUsZ0NBQWdDLElBQUksZ0JBQWdCLElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixXQUFXLFlBQVksUUFBUSxpQkFBaUIsSUFBSTtBQUMxRSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsY0FBYyxjQUFjLFFBQVEsY0FBYyxJQUFJO0FBQzNFLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFRLGNBQWMsUUFBUSxjQUFjLFFBQVE7QUFDeEUsaUNBQWlDLElBQUksZ0JBQWdCLElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixXQUFXLGNBQWMsV0FBVyxnQkFBZ0IsSUFBSTtBQUMzRSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixXQUFXLGNBQWMsSUFBSSxnQkFBZ0IsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixRQUFRLGFBQWEsV0FBVyxvQkFBb0I7QUFDM0UsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixRQUFRLGFBQWEsV0FBVyxvQkFBb0I7QUFDMUUsc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixRQUFRLGFBQWEsUUFBUSxlQUFlO0FBQ25FLDJDQUEyQyxJQUFJLGdCQUFnQixJQUFJO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsUUFBUSxhQUFhLFdBQVc7QUFDM0QsNkJBQTZCLElBQUksZ0JBQWdCLElBQUk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFRLGVBQWUsSUFBSSxnQkFBZ0IsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixRQUFRLGNBQWMsZUFBZSxhQUFhO0FBQ3hFLHlCQUF5QixxQkFBcUIsSUFBSSxnQkFBZ0IsSUFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRLGNBQWMsV0FBVyxjQUFjLFdBQVc7QUFDN0Usa0NBQWtDLFFBQVEsa0JBQWtCLFFBQVE7QUFDcEUsd0JBQXdCLElBQUksZ0JBQWdCLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRLGVBQWUsSUFBSSxnQkFBZ0IsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPLFdBQVcsSUFBSSxnQkFBZ0IsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPLFdBQVcsSUFBSSxnQkFBZ0IsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixRQUFRLGVBQWUsV0FBVztBQUMxRCwwQkFBMEIsZ0JBQWdCLGFBQWEsSUFBSSxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFFBQVEsZUFBZSxTQUFTO0FBQ3hELDBCQUEwQixnQkFBZ0IsYUFBYSxJQUFJLGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsV0FBVyxZQUFZLGdCQUFnQixhQUFhLElBQUk7QUFDM0UsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFdBQVcsY0FBYyxnQkFBZ0IsYUFBYSxJQUFJO0FBQzdFLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsV0FBVyxjQUFjLGdCQUFnQixhQUFhO0FBQzFFLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFRLGVBQWUsUUFBUSxlQUFlLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsUUFBUSxnQkFBZ0IsUUFBUTtBQUM1RCw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLFFBQVEsY0FBYyxRQUFRLGNBQWM7QUFDeEUsK0JBQStCLGNBQWMsSUFBSSxnQkFBZ0IsSUFBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsV0FBVyxjQUFjLFdBQVc7QUFDN0QsMkJBQTJCLFdBQVcsZUFBZSxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFdBQVcsYUFBYSxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFdBQVcsY0FBYyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQywwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQywyQkFBMkIsZ0JBQWdCLEVBQUU7QUFDN0MsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQyxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCLEVBQUU7QUFDakQsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCLEVBQUU7QUFDL0Msd0JBQXdCLGFBQWEsRUFBRTtBQUN2QywyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsNEJBQTRCLGlCQUFpQixFQUFFO0FBQy9DLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUIsRUFBRTtBQUMvQywwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCLEVBQUU7QUFDM0QsbUNBQW1DLHdCQUF3QixFQUFFO0FBQzdELDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQywyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsOEJBQThCLG1CQUFtQixFQUFFO0FBQ25ELDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQywrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCLEVBQUU7QUFDL0MsMkJBQTJCLGdCQUFnQixFQUFFO0FBQzdDLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQyw2QkFBNkIsa0JBQWtCLEVBQUU7QUFDakQsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWEsRUFBRTtBQUN2Qyw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0Msd0JBQXdCLGFBQWEsRUFBRTtBQUN2QywyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhLEVBQUU7QUFDdkMsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQyw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYyxFQUFFO0FBQ3pDLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWMsRUFBRTtBQUN6QyxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjLEVBQUU7QUFDekMsMkJBQTJCLGdCQUFnQixFQUFFO0FBQzdDLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWMsRUFBRTtBQUN6QyxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQyx5QkFBeUIsY0FBYyxFQUFFO0FBQ3pDLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQywwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLDhCQUE4QixtQkFBbUIsRUFBRTtBQUNuRCw4QkFBOEIsbUJBQW1CLEVBQUU7QUFDbkQsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsRUFBRTtBQUM3QywwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsRUFBRTtBQUM3QywyQkFBMkIsZ0JBQWdCLEVBQUU7QUFDN0MseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWEsRUFBRTtBQUN2Qyx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQixFQUFFO0FBQzdDLDJCQUEyQixnQkFBZ0IsRUFBRTtBQUM3QywwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCLEVBQUU7QUFDL0MsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQyx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxFQUFFO0FBQzNDLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQyw0QkFBNEIsaUJBQWlCLEVBQUU7QUFDL0MsMkJBQTJCLGdCQUFnQixFQUFFO0FBQzdDLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWMsRUFBRTtBQUN6QywyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsNEJBQTRCLGlCQUFpQjtBQUM3Qzs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlDQUFpQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRkFBMkYsUUFBUTtBQUNuRztBQUNBO0FBQ0EsaUhBQWlILFFBQVE7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFFBQVE7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkksUUFBUTtBQUNySjs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYztBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdCO0FBQ0EsSTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixJO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtB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UjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLFlBQVksRUFBRSxHQUFHIiwiZmlsZSI6Ijc4MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZpbGJlcnRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZmlsYmVydFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIFNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0dmFyIHRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBpbXByb3ZlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0XHRsb2NhdGlvbnM6IHRydWUsXG5cdFx0cmFuZ2VzOiB0cnVlLFxuXHRcdHNpcHBldHM6IHRydWUsXG5cdFx0ZmlsZW5hbWU6ICdmaWxlLnB5Jyxcblx0XHR1c2VMZXQ6IGZhbHNlLFxuXHRcdGZyaWVuZGx5RXJyb3JzOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gcmFuZ2VUb0xvYyh4LCBvZmZzZXRzKSB7XG5cdFx0dmFyIGJlc3QgPSAtMTtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aDsgKytpICkge1xuXHRcdFx0aWYgKCBvZmZzZXRzW2ldID4geCApIGJyZWFrO1xuXHRcdFx0YmVzdCA9IGk7XG5cdFx0fVxuXHRcdHZhciBvZmYgPSBiZXN0ID49IDAgPyBvZmZzZXRzW2Jlc3RdIDogMDtcblx0XHRyZXR1cm4ge2xpbmU6IGJlc3QrMiwgY29sdW1uOiB4IC0gb2ZmLCBwb3M6IHggfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvY1RvUmFuZ2UobGluZSwgY29sLCBvZmZzZXRzKSB7XG5cdFx0dmFyIGxvZmYgPSAwO1xuXHRcdGlmICggbGluZSA+IDIgJiYgKGxpbmUtMikgPCBvZmZzZXRzLmxlbmd0aCApIGxvZmYgPSBvZmZzZXRzW2xpbmUtMl07XG5cdFx0cmV0dXJuIGxvZmYgKyBjb2w7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvcmF0ZShuLCBjb2RlLCBvZmZzZXRzLCBvcHRpb25zKSB7XG5cdFx0dmFyIG51bXJhbmdlID0gbG9jVG9SYW5nZShuLmxpbmVubywgbi5jb2xfb2Zmc2V0LCBvZmZzZXRzKTtcblxuXHRcdHZhciByYW5nZSA9IFtcblx0XHRcdG51bXJhbmdlID09PSBudW1yYW5nZSA/IG51bXJhbmdlIDogSW5maW5pdHksXG5cdFx0XHRudW1yYW5nZSA9PT0gbnVtcmFuZ2UgPyBudW1yYW5nZSA6IC1JbmZpbml0eVxuXHRcdF07XG5cdFx0XG5cdFx0aWYgKCBuLnZhbHVlICkgcmFuZ2VbMV0gKz0gKG4udmFsdWUubGVuZ3RoKTtcblxuXHRcdGlmICggbi5jaGlsZHJlbiApXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbi5jaGlsZHJlbi5sZW5ndGg7ICsraSApIHtcblx0XHRcdHZhciByID0gZGVjb3JhdGUobi5jaGlsZHJlbltpXSwgY29kZSwgb2Zmc2V0cywgb3B0aW9ucyk7XG5cdFx0XHRyYW5nZVswXSA9IE1hdGgubWluKHJhbmdlWzBdLCByWzBdKTtcblx0XHRcdHJhbmdlWzFdID0gTWF0aC5tYXgocmFuZ2VbMV0sIHJbMV0pO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5yYW5nZXMgKSBuLnJhbmdlID0gcmFuZ2U7XG5cdFx0aWYgKCBvcHRpb25zLmxvY2F0aW9ucyApIHtcblx0XHRcdG4ubG9jID0ge1xuXHRcdFx0XHRzdGFydDogcmFuZ2VUb0xvYyhyYW5nZVswXSwgb2Zmc2V0cyksXG5cdFx0XHRcdGVuZDogcmFuZ2VUb0xvYyhyYW5nZVsxXSwgb2Zmc2V0cyksXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMuc25pcHBldHMgKSBuLnN0ciA9IGNvZGUuc3Vic3RyaW5nKHJhbmdlWzBdLCByYW5nZVsxXSk7XG5cblx0XHRyZXR1cm4gcmFuZ2U7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZXIoY29kZSwgb3B0aW9ucykge1xuXHRcdHZhciBsaW5lT2Zmc2V0cyA9IFtdO1xuXHRcdHZhciBpZHggPSAtMTtcblx0XHR2YXIgcGFyc2UsIGFzdDtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRmb3IgKCB2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zICkge1xuXHRcdFx0aWYgKCAhKG9wdCBpbiBvcHRpb25zKSApIG9wdGlvbnNbb3B0XSA9IGRlZmF1bHRPcHRpb25zW29wdF07XG5cdFx0fVxuXG5cdFx0d2hpbGUgKCB0cnVlICkge1xuXHRcdFx0aWR4ID0gY29kZS5pbmRleE9mKFwiXFxuXCIsIGlkeCsxKTtcblx0XHRcdGlmICggaWR4IDwgMCApIGJyZWFrO1xuXHRcdFx0bGluZU9mZnNldHMucHVzaChpZHgrMSk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHBhcnNlID0gU2sucGFyc2Uob3B0aW9ucy5maWxlbmFtZSwgY29kZSk7XG5cdFx0XHRkZWNvcmF0ZShwYXJzZS5jc3QsIGNvZGUsIGxpbmVPZmZzZXRzLCBvcHRpb25zKTtcblx0XHRcdHBhcnNlLmZsYWdzID0gcGFyc2UuZmxhZ3MgfCBTay5QYXJzZXIuQ09fRlVUVVJFX1VOSUNPREVfTElURVJBTFM7IC8vRW5hYmxlIGZ1dHVyZSB1bmljb2RlIGxpdGVyYWxzXG5cdFx0XHRhc3QgPSBTay5hc3RGcm9tUGFyc2UocGFyc2UuY3N0LCBvcHRpb25zLmZpbGVuYW1lLCBwYXJzZS5mbGFncyk7XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRpZiAoIGUuZXh0cmEgJiYgZS5leHRyYS5ub2RlICkgZGVjb3JhdGUoZS5leHRyYS5ub2RlLCBjb2RlLCBsaW5lT2Zmc2V0cywgb3B0aW9ucyk7XG5cdFx0XHRpbXByb3ZlRXJyb3IoZSwgb3B0aW9ucywgY29kZSk7XG5cdFx0XHRpZiAoIGUubG9jICkge1xuXHRcdFx0XHRlLnBvcyA9IGxvY1RvUmFuZ2UoZS5sb2MubGluZSwgZS5sb2MuY29sdW1uLCBsaW5lT2Zmc2V0cyk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblxuXHRcdC8vY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoYXN0LCBudWxsLCBcIiAgXCIpKTtcblx0XHR2YXIgY3R4ID0ge3ZhclR5cGU6IChvcHRpb25zLnVzZUxldCA/ICdsZXQnIDogJ3ZhcicpfTtcblx0XHR2YXIganMgPSB0cmFuc2Zvcm0oYXN0LCBjdHgpO1xuXHRcdHJldHVybiBqcztcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHRcdHBhcnNlOiBwYXJzZXIsXG5cdFx0cHl0aG9uUnVudGltZTogX193ZWJwYWNrX3JlcXVpcmVfXyg0KSxcblx0XHRkZWZhdWx0T3B0aW9uczoge3J1bnRpbWVQYXJhbU5hbWU6ICdfX3B5dGhvblJ1bnRpbWUnfVxuXHR9O1xuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuXHQvKiAtLS0tIC9Vc2Vycy9yb2Ivc2t1bHB0eS9saWIvcHJlYW1ibGUuanMgLS0tLSAqLyBcblxuXHR2YXIgZ29vZyA9IHtcblx0XHRnbG9iYWw6IGdsb2JhbFxuXHR9O1xuXG5cdHZhciBDT01QSUxFRCA9IGZhbHNlO1xuXG5cdGdvb2cuZXhwb3J0U3ltYm9sID0gZnVuY3Rpb24oKSB7fTtcblx0Z29vZy5yZXF1aXJlID0gZnVuY3Rpb24oKSB7fTtcblxuXHRnb29nLmluaGVyaXRzID0gZnVuY3Rpb24oY2hpbGRDdG9yLCBwYXJlbnRDdG9yKSB7XG5cdCAgaWYgKCAhcGFyZW50Q3RvciApIHRocm93IG5ldyBFcnJvcihcIkNhbnQgaW5oZXJpdCBmcm9tIHVuZGVmaW5lZD9cIik7XG5cdCAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuXHQgIGZ1bmN0aW9uIHRlbXBDdG9yKCkge307XG5cdCAgdGVtcEN0b3IucHJvdG90eXBlID0gcGFyZW50Q3Rvci5wcm90b3R5cGU7XG5cdCAgY2hpbGRDdG9yLnN1cGVyQ2xhc3NfID0gcGFyZW50Q3Rvci5wcm90b3R5cGU7XG5cdCAgY2hpbGRDdG9yLnByb3RvdHlwZSA9IG5ldyB0ZW1wQ3RvcigpO1xuXHQgIC8qKiBAb3ZlcnJpZGUgKi9cblx0ICBjaGlsZEN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGRDdG9yO1xuXHR9O1xuXG5cdGdvb2cuYXNzZXJ0cyA9IHtcblx0XHRhc3NlcnQ6IGZ1bmN0aW9uKHdoYXQsIHdoeSkge1xuXHQgICAgICAgIGlmICggIXdoYXQgKSB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb25GYWlsZWQ6XCIgKyB3aHkpO1xuXHQgICAgfVxuXHR9O1xuXG5cdHZhciBTayA9IFNrIHx8IHt9O1xuXG5cdFNrLmJ1aWx0aW4gPSBTay5idWlsdGluICB8fCAge307XG5cblx0U2suYnVpbHRpbi5ib29sID0gQm9vbGVhbjtcblx0U2suYnVpbHRpbi5pbnRfID0gZnVuY3Rpb24gSW50KHgpIHtcblx0ICB0aGlzLnYgPSB4O1xuXHR9O1xuXG5cdFNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGUudGhyZXNob2xkJCA9IEluZmluaXR5O1xuXHRTay5idWlsdGluLmludF8ucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudi52YWx1ZU9mKCk7IH07XG5cblx0U2suYnVpbHRpbi50dXBsZSA9IGZ1bmN0aW9uKHgpIHtcblx0ICB0aGlzLnYgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh4LCAwKTtcblx0fTtcblx0U2suYnVpbHRpbi50dXBsZS5wcm90b3R5cGUuc3EkbGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxlbmd0aDsgfTtcblxuXHRTay5idWlsdGluLmZsb2F0XyA9IE51bWJlcjtcblx0U2suYnVpbHRpbi5sb25nID0gTnVtYmVyO1xuXHRTay5idWlsdGluLmZ1bmMgPSBmdW5jdGlvbihmeCkgeyByZXR1cm4gZng7IH07XG5cblxuXHQvKiAtLS0tIC9Vc2Vycy9yb2Ivc2t1bHB0eS9saWIvLi4vbm9kZV9tb2R1bGVzL3NrdWxwdC9zcmMvdHlwZS5qcyAtLS0tICovIFxuXG5cdGlmKFNrLmJ1aWx0aW4gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgU2suYnVpbHRpbiA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIE1hcHMgUHl0aG9uIGR1bmRlciBuYW1lcyB0byB0aGUgU2t1bHB0IEphdmFzY3JpcHQgZnVuY3Rpb24gbmFtZXMgdGhhdFxuXHQgKiBpbXBsZW1lbnQgdGhlbS5cblx0ICpcblx0ICogTm90ZTogX19hZGRfXywgX19tdWxfXywgYW5kIF9fcm11bF9fIGNhbiBiZSB1c2VkIGZvciBlaXRoZXIgbnVtZXJpYyBvclxuXHQgKiBzZXF1ZW5jZSB0eXBlcy4gSGVyZSwgdGhleSBkZWZhdWx0IHRvIHRoZSBudW1lcmljIHZlcnNpb25zIChpLmUuIG5iJGFkZCxcblx0ICogbmIkbXVsdGlwbHksIGFuZCBuYiRyZWZsZWN0ZWRfbXVsdGlwbHkpLiBUaGlzIHdvcmtzIGJlY2F1c2UgU2suYWJzdHIuYmluYXJ5X29wX1xuXHQgKiBjaGVja3MgZm9yIHRoZSBudW1lcmljIHNob3J0Y3V0cyBhbmQgbm90IHRoZSBzZXF1ZW5jZSBzaG9ydGN1dHMgd2hlbiBjb21wdXRpbmdcblx0ICogYSBiaW5hcnkgb3BlcmF0aW9uLlxuXHQgKlxuXHQgKiBCZWNhdXNlIG1hbnkgb2YgdGhlc2UgZnVuY3Rpb25zIGFyZSB1c2VkIGluIGNvbnRleHRzIGluIHdoaWNoIFNrdWxwdCBkb2VzIG5vdFxuXHQgKiBbeWV0XSBoYW5kbGUgc3VzcGVuc2lvbnMsIHRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgdGhleSBtdXN0IG5vdCBzdXNwZW5kLiBIb3dldmVyLFxuXHQgKiBzb21lIG9mIHRoZXNlIGJ1aWx0LWluIGZ1bmN0aW9ucyBhcmUgYWNxdWlyaW5nICdjYW5TdXNwZW5kJyBhcmd1bWVudHMgdG8gc2lnbmFsXG5cdCAqIHdoZXJlIHRoaXMgaXMgbm90IHRoZSBjYXNlLiBUaGVzZSBuZWVkIHRvIGJlIHNwbGljZWQgb3V0IG9mIHRoZSBhcmd1bWVudCBsaXN0IGJlZm9yZVxuXHQgKiBpdCBpcyBwYXNzZWQgdG8gcHl0aG9uLiBBcnJheSB2YWx1ZXMgaW4gdGhpcyBtYXAgY29udGFpbiBbZHVuZGVyTmFtZSwgYXJndW1lbnRJZHhdLFxuXHQgKiB3aGVyZSBhcmd1bWVudElkeCBzcGVjaWZpZXMgdGhlIGluZGV4IG9mIHRoZSAnY2FuU3VzcGVuZCcgYm9vbGVhbiBhcmd1bWVudC5cblx0ICpcblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cdFNrLmR1bmRlclRvU2t1bHB0ID0ge1xuXHQgICAgXCJfX2VxX19cIjogXCJvYiRlcVwiLFxuXHQgICAgXCJfX25lX19cIjogXCJvYiRuZVwiLFxuXHQgICAgXCJfX2x0X19cIjogXCJvYiRsdFwiLFxuXHQgICAgXCJfX2xlX19cIjogXCJvYiRsZVwiLFxuXHQgICAgXCJfX2d0X19cIjogXCJvYiRndFwiLFxuXHQgICAgXCJfX2dlX19cIjogXCJvYiRnZVwiLFxuXHQgICAgXCJfX2hhc2hfX1wiOiBcInRwJGhhc2hcIixcblx0ICAgIFwiX19hYnNfX1wiOiBcIm5iJGFic1wiLFxuXHQgICAgXCJfX25lZ19fXCI6IFwibmIkbmVnYXRpdmVcIixcblx0ICAgIFwiX19wb3NfX1wiOiBcIm5iJHBvc2l0aXZlXCIsXG5cdCAgICBcIl9faW50X19cIjogXCJuYiRpbnRfXCIsXG5cdCAgICBcIl9fbG9uZ19fXCI6IFwibmIkbG5nXCIsXG5cdCAgICBcIl9fZmxvYXRfX1wiOiBcIm5iJGZsb2F0X1wiLFxuXHQgICAgXCJfX2FkZF9fXCI6IFwibmIkYWRkXCIsXG5cdCAgICBcIl9fcmFkZF9fXCI6IFwibmIkcmVmbGVjdGVkX2FkZFwiLFxuXHQgICAgXCJfX3N1Yl9fXCI6IFwibmIkc3VidHJhY3RcIixcblx0ICAgIFwiX19yc3ViX19cIjogXCJuYiRyZWZsZWN0ZWRfc3VidHJhY3RcIixcblx0ICAgIFwiX19tdWxfX1wiOiBcIm5iJG11bHRpcGx5XCIsXG5cdCAgICBcIl9fcm11bF9fXCI6IFwibmIkcmVmbGVjdGVkX211bHRpcGx5XCIsXG5cdCAgICBcIl9fZGl2X19cIjogXCJuYiRkaXZpZGVcIixcblx0ICAgIFwiX19yZGl2X19cIjogXCJuYiRyZWZsZWN0ZWRfZGl2aWRlXCIsXG5cdCAgICBcIl9fZmxvb3JkaXZfX1wiOiBcIm5iJGZsb29yX2RpdmlkZVwiLFxuXHQgICAgXCJfX3JmbG9vcmRpdl9fXCI6IFwibmIkcmVmbGVjdGVkX2Zsb29yX2RpdmlkZVwiLFxuXHQgICAgXCJfX21vZF9fXCI6IFwibmIkcmVtYWluZGVyXCIsXG5cdCAgICBcIl9fcm1vZF9fXCI6IFwibmIkcmVmbGVjdGVkX3JlbWFpbmRlclwiLFxuXHQgICAgXCJfX2Rpdm1vZF9fXCI6IFwibmIkZGl2bW9kXCIsXG5cdCAgICBcIl9fcmRpdm1vZF9fXCI6IFwibmIkcmVmbGVjdGVkX2Rpdm1vZFwiLFxuXHQgICAgXCJfX3Bvd19fXCI6IFwibmIkcG93ZXJcIixcblx0ICAgIFwiX19ycG93X19cIjogXCJuYiRyZWZsZWN0ZWRfcG93ZXJcIixcblx0ICAgIFwiX19jb250YWluc19fXCI6IFwic3EkY29udGFpbnNcIixcblx0ICAgIFwiX19sZW5fX1wiOiBbXCJzcSRsZW5ndGhcIiwgMF1cblx0fTtcblxuXHQvKipcblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gbmFtZSBuYW1lIG9yIG9iamVjdCB0byBnZXQgdHlwZSBvZiwgaWYgb25seSBvbmUgYXJnXG5cdCAqXG5cdCAqIEBwYXJhbSB7U2suYnVpbHRpbi50dXBsZT19IGJhc2VzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0PX0gZGljdFxuXHQgKlxuXHQgKlxuXHQgKiBUaGlzIHR5cGUgcmVwcmVzZW50cyB0aGUgdHlwZSBvZiBgdHlwZScuICpDYWxsaW5nKiBhbiBpbnN0YW5jZSBvZlxuXHQgKiB0aGlzIGJ1aWx0aW4gdHlwZSBuYW1lZCBcInR5cGVcIiBjcmVhdGVzIGNsYXNzIG9iamVjdHMuIFRoZSByZXN1bHRpbmdcblx0ICogY2xhc3Mgb2JqZWN0cyB3aWxsIGhhdmUgdmFyaW91cyB0cCR4eXogYXR0cmlidXRlcyBvbiB0aGVtIHRoYXQgYWxsb3dcblx0ICogZm9yIHRoZSB2YXJpb3VzIG9wZXJhdGlvbnMgb24gdGhhdCBvYmplY3QuXG5cdCAqXG5cdCAqIGNhbGxpbmcgdGhlIHR5cGUgb3IgY2FsbGluZyBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZT8gb3IgYm90aD9cblx0ICovXG5cdFNrLmJ1aWx0aW4udHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBiYXNlcywgZGljdCkge1xuXHQgICAgdmFyIG1ybztcblx0ICAgIHZhciBvYmo7XG5cdCAgICB2YXIga2xhc3M7XG5cdCAgICB2YXIgdjtcblx0ICAgIGlmIChiYXNlcyA9PT0gdW5kZWZpbmVkICYmIGRpY3QgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIC8vIDEgYXJnIHZlcnNpb24gb2YgdHlwZSgpXG5cdCAgICAgICAgLy8gdGhlIGFyZ3VtZW50IGlzIGFuIG9iamVjdCwgbm90IGEgbmFtZSBhbmQgcmV0dXJucyBhIHR5cGUgb2JqZWN0XG5cdCAgICAgICAgb2JqID0gbmFtZTtcblx0ICAgICAgICByZXR1cm4gb2JqLm9iJHR5cGU7XG5cdCAgICB9IGVsc2Uge1xuXG5cdCAgICAgICAgLy8gYXJndW1lbnQgZGljdCBtdXN0IGJlIG9mIHR5cGUgZGljdFxuXHQgICAgICAgIGlmKGRpY3QudHAkbmFtZSAhPT0gXCJkaWN0XCIpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHlwZSgpIGFyZ3VtZW50IDMgbXVzdCBiZSBkaWN0LCBub3QgXCIgKyBTay5hYnN0ci50eXBlTmFtZShkaWN0KSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gY2hlY2tzIGlmIG5hbWUgbXVzdCBiZSBzdHJpbmdcblx0ICAgICAgICBpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhuYW1lKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlKCkgYXJndW1lbnQgMSBtdXN0IGJlIHN0ciwgbm90IFwiICsgU2suYWJzdHIudHlwZU5hbWUobmFtZSkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGFyZ3VtZW50IGJhc2VzIG11c3QgYmUgb2YgdHlwZSB0dXBsZVxuXHQgICAgICAgIGlmKGJhc2VzLnRwJG5hbWUgIT09IFwidHVwbGVcIikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlKCkgYXJndW1lbnQgMiBtdXN0IGJlIHR1cGxlLCBub3QgXCIgKyBTay5hYnN0ci50eXBlTmFtZShiYXNlcykpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIHR5cGUgYnVpbGRpbmcgdmVyc2lvbiBvZiB0eXBlXG5cblx0ICAgICAgICAvLyBkaWN0IGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGUgY2xhc3NlcyBjb2RlIG9iamVjdFxuXHQgICAgICAgIC8vIChiYXNpY2FsbHkgdGhlIGRpY3Qgb2YgZnVuY3Rpb25zKS4gdGhvc2UgYmVjb21lIHRoZSBwcm90b3R5cGVcblx0ICAgICAgICAvLyBvYmplY3Qgb2YgdGhlIGNsYXNzKS5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICAgICovXG5cdCAgICAgICAga2xhc3MgPSBmdW5jdGlvbiAoa3dkaWN0LCB2YXJhcmdzZXEsIGt3cywgYXJncywgY2FuU3VzcGVuZCkge1xuXHQgICAgICAgICAgICB2YXIgaW5pdDtcblx0ICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgcztcblx0ICAgICAgICAgICAgdmFyIGFyZ3NfY29weTtcblx0ICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGtsYXNzKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBrbGFzcyhrd2RpY3QsIHZhcmFyZ3NlcSwga3dzLCBhcmdzLCBjYW5TdXNwZW5kKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHQgICAgICAgICAgICBzZWxmW1wiJGRcIl0gPSBuZXcgU2suYnVpbHRpbi5kaWN0KFtdKTtcblx0ICAgICAgICAgICAgc2VsZltcIiRkXCJdLm1wJGFzc19zdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19kaWN0X19cIiksIHNlbGZbXCIkZFwiXSk7XG5cblx0ICAgICAgICAgICAgaWYgKGtsYXNzLnByb3RvdHlwZS50cCRiYXNlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChrbGFzcy5wcm90b3R5cGUudHAkYmFzZS5zayRrbGFzcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS50cCRiYXNlLmNhbGwodGhpcywga3dkaWN0LCB2YXJhcmdzZXEsIGt3cywgYXJncy5zbGljZSgpLCBjYW5TdXNwZW5kKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBzdXBlciBjb25zdHJ1Y3RvciBpZiBzdWJjbGFzcyBvZiBhIGJ1aWx0aW5cblx0ICAgICAgICAgICAgICAgICAgICBhcmdzX2NvcHkgPSBhcmdzLnNsaWNlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJnc19jb3B5LnVuc2hpZnQoa2xhc3MsIHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIFNrLmFic3RyLnN1cGVyQ29uc3RydWN0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmdzX2NvcHkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaW5pdCA9IFNrLmJ1aWx0aW4udHlwZS50eXBlTG9va3VwKHNlbGYub2IkdHlwZSwgXCJfX2luaXRfX1wiKTtcblx0ICAgICAgICAgICAgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHNob3VsZCBiZSBOb25lIG9yIHRocm93IGEgVHlwZUVycm9yIG90aGVyd2lzZVxuXHQgICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KHNlbGYpO1xuXHQgICAgICAgICAgICAgICAgcyA9IFNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kKGluaXQsIGt3ZGljdCwgdmFyYXJnc2VxLCBrd3MsIGFyZ3MpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIGRvU3VzcChzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHMgaW5zdGFuY2VvZiBTay5taXNjZXZhbC5TdXNwZW5zaW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gSSAoTWVyZWR5ZGQpIGRvbid0IGtub3cgd2hldGhlciB3ZSBhcmUgZXZlciBjYWxsZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBhbnl3aGVyZSBleGNlcHQgU2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQoKS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90LCB3ZSBkb24ndCBuZWVkIGEgY2FuU3VzcGVuZCBwYXJhbWV0ZXIgYXQgYWxsLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuU3VzcGVuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKGRvU3VzcCwgcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSkocyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gc2VsZjtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgdmFyIF9uYW1lID0gU2suZmZpLnJlbWFwVG9KcyhuYW1lKTsgLy8gdW53cmFwIG5hbWUgc3RyaW5nIHRvIGpzIGZvciBsYXR0ZXIgdXNlXG5cblx0ICAgICAgICB2YXIgaW5oZXJpdHNGcm9tT2JqZWN0ID0gZmFsc2UsIGluaGVyaXRzQnVpbHRpbiA9IGZhbHNlO1xuXG5cdCAgICAgICAgaWYgKGJhc2VzLnYubGVuZ3RoID09PSAwICYmIFNrLnB5dGhvbjMpIHtcblx0ICAgICAgICAgICAgLy8gbmV3IHN0eWxlIGNsYXNzLCBpbmhlcml0cyBmcm9tIG9iamVjdCBieSBkZWZhdWx0XG5cdCAgICAgICAgICAgIGluaGVyaXRzRnJvbU9iamVjdCA9IHRydWU7XG5cdCAgICAgICAgICAgIFNrLmFic3RyLnNldFVwSW5oZXJpdGFuY2UoX25hbWUsIGtsYXNzLCBTay5idWlsdGluLm9iamVjdCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHBhcmVudCwgaXQsIGZpcnN0QW5jZXN0b3IsIGJ1aWx0aW5fYmFzZXMgPSBbXTtcblx0ICAgICAgICAvLyBTZXQgdXAgaW5oZXJpdGFuY2UgZnJvbSBhbnkgYnVpbHRpbnNcblx0ICAgICAgICBmb3IgKGl0ID0gYmFzZXMudHAkaXRlcigpLCBwYXJlbnQgPSBpdC50cCRpdGVybmV4dCgpOyBwYXJlbnQgIT09IHVuZGVmaW5lZDsgcGFyZW50ID0gaXQudHAkaXRlcm5leHQoKSkge1xuXHQgICAgICAgICAgICBpZiAoZmlyc3RBbmNlc3RvciA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICBmaXJzdEFuY2VzdG9yID0gcGFyZW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChwYXJlbnQucHJvdG90eXBlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5vYmplY3QgfHwgcGFyZW50ID09PSBTay5idWlsdGluLm9iamVjdCkge1xuXG5cdCAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50LnNrJGtsYXNzICYmIHBhcmVudC5wcm90b3R5cGUudHAkYmFzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wcm90b3R5cGUudHAkYmFzZTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQuc2ska2xhc3MgJiYgYnVpbHRpbl9iYXNlcy5pbmRleE9mKHBhcmVudCkgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVpbHRpbl9iYXNlcy5wdXNoKHBhcmVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFRoaXMgY2xhc3MgaW5oZXJpdHMgZnJvbSBTay5idWlsdGluLm9iamVjdCBhdCBzb21lIGxldmVsXG5cdCAgICAgICAgICAgICAgICBpbmhlcml0c0Zyb21PYmplY3QgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGJ1aWx0aW5fYmFzZXMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJNdWx0aXBsZSBpbmhlcml0YW5jZSB3aXRoIG1vcmUgdGhhbiBvbmUgYnVpbHRpbiB0eXBlIGlzIHVuc3VwcG9ydGVkXCIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEphdmFzY3JpcHQgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBsZSBpbmhlcml0YW5jZSwgc28gb25seSB0aGUgZmlyc3Rcblx0ICAgICAgICAvLyBiYXNlIChpZiBhbnkpIHdpbGwgZGlyZWN0bHkgaW5oZXJpdCBpbiBKYXZhc2NyaXB0XG5cdCAgICAgICAgaWYgKGZpcnN0QW5jZXN0b3IgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBnb29nLmluaGVyaXRzKGtsYXNzLCBmaXJzdEFuY2VzdG9yKTtcblxuXHQgICAgICAgICAgICBpZiAoZmlyc3RBbmNlc3Rvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBTay5idWlsdGluLm9iamVjdCB8fCBmaXJzdEFuY2VzdG9yID09PSBTay5idWlsdGluLm9iamVjdCkge1xuXHQgICAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnRwJGJhc2UgPSBmaXJzdEFuY2VzdG9yO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAga2xhc3MucHJvdG90eXBlLnRwJG5hbWUgPSBfbmFtZTtcblx0ICAgICAgICBrbGFzcy5wcm90b3R5cGUub2IkdHlwZSA9IFNrLmJ1aWx0aW4udHlwZS5tYWtlSW50b1R5cGVPYmooX25hbWUsIGtsYXNzKTtcblxuXHQgICAgICAgIGlmICghaW5oZXJpdHNGcm9tT2JqZWN0KSB7XG5cdCAgICAgICAgICAgIC8vIG9sZCBzdHlsZSBjbGFzcywgZG9lcyBub3QgaW5oZXJpdCBmcm9tIG9iamVjdFxuXHQgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUudHAkZ2V0YXR0ciA9IFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5HZW5lcmljR2V0QXR0cjtcblx0ICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnRwJHNldGF0dHIgPSBTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUuR2VuZXJpY1NldEF0dHI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gc2V0IF9fbW9kdWxlX18gaWYgbm90IHByZXNlbnQgKHJlcXVpcmVkIGJ5IGRpcmVjdCB0eXBlKG5hbWUsIGJhc2VzLCBkaWN0KSBjYWxscylcblx0ICAgICAgICB2YXIgbW9kdWxlX2xrID0gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19tb2R1bGVfX1wiKTtcblx0ICAgICAgICBpZihkaWN0Lm1wJGxvb2t1cChtb2R1bGVfbGspID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgZGljdC5tcCRhc3Nfc3Vic2NyaXB0KG1vZHVsZV9saywgU2suZ2xvYmFsc1tcIl9fbmFtZV9fXCJdKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBjb3B5IHByb3BlcnRpZXMgaW50byBvdXIga2xhc3Mgb2JqZWN0XG5cdCAgICAgICAgLy8gdXNlcyBweXRob24gaXRlciBtZXRob2RzXG5cdCAgICAgICAgdmFyIGs7XG5cdCAgICAgICAgZm9yIChpdCA9IGRpY3QudHAkaXRlcigpLCBrID0gaXQudHAkaXRlcm5leHQoKTsgayAhPT0gdW5kZWZpbmVkOyBrID0gaXQudHAkaXRlcm5leHQoKSkge1xuXHQgICAgICAgICAgICB2ID0gZGljdC5tcCRzdWJzY3JpcHQoayk7XG5cdCAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHYgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtrLnZdID0gdjtcblx0ICAgICAgICAgICAga2xhc3Nbay52XSA9IHY7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAga2xhc3NbXCJfX2NsYXNzX19cIl0gPSBrbGFzcztcblx0ICAgICAgICBrbGFzc1tcIl9fbmFtZV9fXCJdID0gbmFtZTtcblx0ICAgICAgICBrbGFzcy5zayRrbGFzcyA9IHRydWU7XG5cdCAgICAgICAga2xhc3MucHJvdG90eXBlLnRwJGRlc2NyX2dldCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZ29vZy5hc3NlcnRzLmZhaWwoXCJpbiB0eXBlIHRwJGRlc2NyX2dldFwiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGtsYXNzLnByb3RvdHlwZVtcIiRyXCJdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY25hbWU7XG5cdCAgICAgICAgICAgIHZhciBtb2Q7XG5cdCAgICAgICAgICAgIC8vIFRPRE8gdXNlIFNrLmFic3RyLmdhdHRyKCkgaGVyZSBzbyBfX3JlcHJfXyBjYW4gYmUgZHluYW1pY2FsbHkgcHJvdmlkZWQgKGVnIGJ5IF9fZ2V0YXR0cl9fKCkpXG5cdCAgICAgICAgICAgIHZhciByZXByZiA9IHRoaXMudHAkZ2V0YXR0cihcIl9fcmVwcl9fXCIpO1xuXHQgICAgICAgICAgICBpZiAocmVwcmYgIT09IHVuZGVmaW5lZCAmJiByZXByZi5pbV9mdW5jICE9PSBTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGVbXCJfX3JlcHJfX1wiXSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5KHJlcHJmLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBbXSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoKGtsYXNzLnByb3RvdHlwZS50cCRiYXNlICE9PSB1bmRlZmluZWQpICYmXG5cdCAgICAgICAgICAgICAgICAoa2xhc3MucHJvdG90eXBlLnRwJGJhc2UgIT09IFNrLmJ1aWx0aW4ub2JqZWN0KSAmJlxuXHQgICAgICAgICAgICAgICAgKGtsYXNzLnByb3RvdHlwZS50cCRiYXNlLnByb3RvdHlwZVtcIiRyXCJdICE9PSB1bmRlZmluZWQpKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBJZiBzdWJjbGFzcyBvZiBhIGJ1aWx0aW4gd2hpY2ggaXMgbm90IG9iamVjdCwgdXNlIHRoYXQgY2xhc3MnIHJlcHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBrbGFzcy5wcm90b3R5cGUudHAkYmFzZS5wcm90b3R5cGVbXCIkclwiXS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gRWxzZSwgdXNlIGRlZmF1bHQgcmVwciBmb3IgYSB1c2VyLWRlZmluZWQgY2xhc3MgaW5zdGFuY2Vcblx0ICAgICAgICAgICAgICAgIG1vZCA9IGRpY3QubXAkc3Vic2NyaXB0KG1vZHVsZV9sayk7IC8vIGxvb2t1cCBfX21vZHVsZV9fXG5cdCAgICAgICAgICAgICAgICBjbmFtZSA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICBpZiAobW9kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY25hbWUgPSBtb2QudiArIFwiLlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIjxcIiArIGNuYW1lICsgX25hbWUgKyBcIiBvYmplY3Q+XCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBrbGFzcy5wcm90b3R5cGUudHAkc3RyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBUT0RPIHVzZSBTay5hYnN0ci5nYXR0cigpIGhlcmUgc28gX19zdHJfXyBjYW4gYmUgZHluYW1pY2FsbHkgcHJvdmlkZWQgKGVnIGJ5IF9fZ2V0YXR0cl9fKCkpXG5cdCAgICAgICAgICAgIHZhciBzdHJmID0gdGhpcy50cCRnZXRhdHRyKFwiX19zdHJfX1wiKTtcblx0ICAgICAgICAgICAgaWYgKHN0cmYgIT09IHVuZGVmaW5lZCAmJiBzdHJmLmltX2Z1bmMgIT09IFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVtcIl9fc3RyX19cIl0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBTay5taXNjZXZhbC5hcHBseShzdHJmLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBbXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKChrbGFzcy5wcm90b3R5cGUudHAkYmFzZSAhPT0gdW5kZWZpbmVkKSAmJlxuXHQgICAgICAgICAgICAgICAgKGtsYXNzLnByb3RvdHlwZS50cCRiYXNlICE9PSBTay5idWlsdGluLm9iamVjdCkgJiZcblx0ICAgICAgICAgICAgICAgIChrbGFzcy5wcm90b3R5cGUudHAkYmFzZS5wcm90b3R5cGUudHAkc3RyICE9PSB1bmRlZmluZWQpKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBJZiBzdWJjbGFzcyBvZiBhIGJ1aWx0aW4gd2hpY2ggaXMgbm90IG9iamVjdCwgdXNlIHRoYXQgY2xhc3MnIHJlcHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBrbGFzcy5wcm90b3R5cGUudHAkYmFzZS5wcm90b3R5cGUudHAkc3RyLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCIkclwiXSgpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAga2xhc3MucHJvdG90eXBlLnRwJGxlbmd0aCA9IGZ1bmN0aW9uIChjYW5TdXNwZW5kKSB7XG5cdCAgICAgICAgICAgIHZhciByID0gU2subWlzY2V2YWwuY2hhaW4oU2suYWJzdHIuZ2F0dHIodGhpcywgXCJfX2xlbl9fXCIsIGNhblN1c3BlbmQpLCBmdW5jdGlvbihsZW5mKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gU2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQobGVuZiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgW10pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGNhblN1c3BlbmQgPyByIDogU2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAga2xhc3MucHJvdG90eXBlLnRwJGNhbGwgPSBmdW5jdGlvbiAoYXJncywga3cpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmFic3RyLmdhdHRyKHRoaXMsIFwiX19jYWxsX19cIiwgdHJ1ZSksIGZ1bmN0aW9uKGNhbGxmKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gU2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQoY2FsbGYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBrdywgYXJncyk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAga2xhc3MucHJvdG90eXBlLnRwJGl0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBpdGVyZiA9IFNrLmFic3RyLmdhdHRyKHRoaXMsIFwiX19pdGVyX19cIiwgZmFsc2UpO1xuXHQgICAgICAgICAgICByZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbShpdGVyZik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBrbGFzcy5wcm90b3R5cGUudHAkaXRlcm5leHQgPSBmdW5jdGlvbiAoY2FuU3VzcGVuZCkge1xuXHQgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciByID0gU2subWlzY2V2YWwuY2hhaW4oXG5cdCAgICAgICAgICAgICAgICBTay5taXNjZXZhbC50cnlDYXRjaChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2suYWJzdHIuZ2F0dHIoc2VsZiwgXCJuZXh0XCIsIGNhblN1c3BlbmQpO1xuXHQgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIgKyBTay5hYnN0ci50eXBlTmFtZShzZWxmKSArIFwiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSksXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uKC8qKiB7T2JqZWN0fSAqLyBpdGVybmV4dGYpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBTay5taXNjZXZhbC50cnlDYXRjaChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZChpdGVybmV4dGYpO1xuXHQgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNhblN1c3BlbmQgPyByIDogU2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHIpO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBrbGFzcy5wcm90b3R5cGUudHAkZ2V0aXRlbSA9IGZ1bmN0aW9uIChrZXksIGNhblN1c3BlbmQpIHtcblx0ICAgICAgICAgICAgdmFyIGdldGYgPSBTay5hYnN0ci5nYXR0cih0aGlzLCBcIl9fZ2V0aXRlbV9fXCIsIGNhblN1c3BlbmQpLCByO1xuXHQgICAgICAgICAgICBpZiAoZ2V0ZiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICByID0gU2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQoZ2V0ZiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgW2tleV0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhblN1c3BlbmQgPyByIDogU2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIiArIFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpICsgXCInIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IGluZGV4aW5nXCIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAga2xhc3MucHJvdG90eXBlLnRwJHNldGl0ZW0gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY2FuU3VzcGVuZCkge1xuXHQgICAgICAgICAgICB2YXIgc2V0ZiA9IFNrLmFic3RyLmdhdHRyKHRoaXMsIFwiX19zZXRpdGVtX19cIiwgY2FuU3VzcGVuZCksIHI7XG5cdCAgICAgICAgICAgIGlmIChzZXRmICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHIgPSBTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZChzZXRmLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBba2V5LCB2YWx1ZV0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhblN1c3BlbmQgPyByIDogU2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIiArIFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpICsgXCInIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IGl0ZW0gYXNzaWdubWVudFwiKTtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgaWYgKGJhc2VzKSB7XG5cdCAgICAgICAgICAgIC8vcHJpbnQoXCJidWlsZGluZyBtcm8gZm9yXCIsIG5hbWUpO1xuXHQgICAgICAgICAgICAvL2ZvciAodmFyIGkgPSAwOyBpIDwgYmFzZXMubGVuZ3RoOyArK2kpXG5cdCAgICAgICAgICAgIC8vcHJpbnQoXCJiYXNlW1wiICsgaSArIFwiXT1cIiArIGJhc2VzW2ldLnRwJG5hbWUpO1xuXHQgICAgICAgICAgICBrbGFzc1tcIiRkXCJdID0gbmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7XG5cdCAgICAgICAgICAgIGtsYXNzW1wiJGRcIl0ubXAkYXNzX3N1YnNjcmlwdChTay5idWlsdGluLnR5cGUuYmFzZXNTdHJfLCBiYXNlcyk7XG5cdCAgICAgICAgICAgIG1ybyA9IFNrLmJ1aWx0aW4udHlwZS5idWlsZE1STyhrbGFzcyk7XG5cdCAgICAgICAgICAgIGtsYXNzW1wiJGRcIl0ubXAkYXNzX3N1YnNjcmlwdChTay5idWlsdGluLnR5cGUubXJvU3RyXywgbXJvKTtcblx0ICAgICAgICAgICAga2xhc3MudHAkbXJvID0gbXJvO1xuXHQgICAgICAgICAgICAvL3ByaW50KFwibXJvIHJlc3VsdFwiLCBTay5idWlsdGluLnJlcHIobXJvKS52KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBmaXggZm9yIGNsYXNzIGF0dHJpYnV0ZXNcblx0ICAgICAgICBrbGFzcy50cCRzZXRhdHRyID0gU2suYnVpbHRpbi50eXBlLnByb3RvdHlwZS50cCRzZXRhdHRyO1xuXG5cdCAgICAgICAgdmFyIHNob3J0Y3V0RHVuZGVyID0gZnVuY3Rpb24gKHNrdWxwdF9uYW1lLCBtYWdpY19uYW1lLCBtYWdpY19mdW5jLCBjYW5TdXNwZW5kSWR4KSB7XG5cdCAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtza3VscHRfbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGNhblN1c3BlbmQ7XG5cdCAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobWFnaWNfZnVuYywgdGhpcyk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChjYW5TdXNwZW5kSWR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FuU3VzcGVuZCA9IGFyZ3NbY2FuU3VzcGVuZElkeCsxXTtcblx0ICAgICAgICAgICAgICAgICAgICBhcmdzLnNwbGljZShjYW5TdXNwZW5kSWR4KzEsIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYW5TdXNwZW5kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW0uYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgLy8gUmVnaXN0ZXIgc2t1bHB0IHNob3J0Y3V0cyB0byBtYWdpYyBtZXRob2RzIGRlZmluZWQgYnkgdGhpcyBjbGFzcy5cblx0ICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHNvbWV3aGF0IHByb2JsZW1hdGljLCBhcyBpdCBtZWFucyB0aGF0IGR5bmFtaWNhbGx5IGRlZmluZWRcblx0ICAgICAgICAvLyBtZXRob2RzIChlZyB0aG9zZSByZXR1cm5lZCBieSBfX2dldGF0dHJfXygpKSBjYW5ub3QgYmUgdXNlZCBieSB0aGVzZSBtYWdpY1xuXHQgICAgICAgIC8vIGZ1bmN0aW9ucy5cblx0ICAgICAgICB2YXIgZHVuZGVyLCBza3VscHRfbmFtZSwgY2FuU3VzcGVuZElkeDtcblx0ICAgICAgICBmb3IgKGR1bmRlciBpbiBTay5kdW5kZXJUb1NrdWxwdCkge1xuXHQgICAgICAgICAgICBza3VscHRfbmFtZSA9IFNrLmR1bmRlclRvU2t1bHB0W2R1bmRlcl07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Yoc2t1bHB0X25hbWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICBjYW5TdXNwZW5kSWR4ID0gbnVsbDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGNhblN1c3BlbmRJZHggPSBza3VscHRfbmFtZVsxXTtcblx0ICAgICAgICAgICAgICAgIHNrdWxwdF9uYW1lID0gc2t1bHB0X25hbWVbMF07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoa2xhc3NbZHVuZGVyXSkge1xuXHQgICAgICAgICAgICAgICAgLy8gc2NvcGUgd29ya2Fyb3VuZFxuXHQgICAgICAgICAgICAgICAgc2hvcnRjdXREdW5kZXIoc2t1bHB0X25hbWUsIGR1bmRlciwga2xhc3NbZHVuZGVyXSwgY2FuU3VzcGVuZElkeCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4ga2xhc3M7XG5cdCAgICB9XG5cblx0fTtcblxuXHQvKipcblx0ICpcblx0ICovXG5cdFNrLmJ1aWx0aW4udHlwZS5tYWtlVHlwZU9iaiA9IGZ1bmN0aW9uIChuYW1lLCBuZXdlZEluc3RhbmNlT2ZUeXBlKSB7XG5cdCAgICBTay5idWlsdGluLnR5cGUubWFrZUludG9UeXBlT2JqKG5hbWUsIG5ld2VkSW5zdGFuY2VPZlR5cGUpO1xuXHQgICAgcmV0dXJuIG5ld2VkSW5zdGFuY2VPZlR5cGU7XG5cdH07XG5cblx0U2suYnVpbHRpbi50eXBlLm1ha2VJbnRvVHlwZU9iaiA9IGZ1bmN0aW9uIChuYW1lLCB0KSB7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KG5hbWUgIT09IHVuZGVmaW5lZCk7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KHQgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0Lm9iJHR5cGUgPSBTay5idWlsdGluLnR5cGU7XG5cdCAgICB0LnRwJG5hbWUgPSBuYW1lO1xuXHQgICAgdFtcIiRyXCJdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBjdHlwZTtcblx0ICAgICAgICB2YXIgbW9kID0gdC5fX21vZHVsZV9fO1xuXHQgICAgICAgIHZhciBjbmFtZSA9IFwiXCI7XG5cdCAgICAgICAgaWYgKG1vZCkge1xuXHQgICAgICAgICAgICBjbmFtZSA9IG1vZC52ICsgXCIuXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGN0eXBlID0gXCJjbGFzc1wiO1xuXHQgICAgICAgIGlmICghbW9kICYmICF0LnNrJGtsYXNzICYmICFTay5weXRob24zKSB7XG5cdCAgICAgICAgICAgIGN0eXBlID0gXCJ0eXBlXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8XCIgKyBjdHlwZSArIFwiICdcIiArIGNuYW1lICsgdC50cCRuYW1lICsgXCInPlwiKTtcblx0ICAgIH07XG5cdCAgICB0LnRwJHN0ciA9IHVuZGVmaW5lZDtcblx0ICAgIHQudHAkZ2V0YXR0ciA9IFNrLmJ1aWx0aW4udHlwZS5wcm90b3R5cGUudHAkZ2V0YXR0cjtcblx0ICAgIHQudHAkc2V0YXR0ciA9IFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5HZW5lcmljU2V0QXR0cjtcblx0ICAgIHQudHAkcmljaGNvbXBhcmUgPSBTay5idWlsdGluLnR5cGUucHJvdG90eXBlLnRwJHJpY2hjb21wYXJlO1xuXHQgICAgdC5zayR0eXBlID0gdHJ1ZTtcblxuXHQgICAgcmV0dXJuIHQ7XG5cdH07XG5cblx0U2suYnVpbHRpbi50eXBlLm9iJHR5cGUgPSBTay5idWlsdGluLnR5cGU7XG5cdFNrLmJ1aWx0aW4udHlwZS50cCRuYW1lID0gXCJ0eXBlXCI7XG5cdFNrLmJ1aWx0aW4udHlwZVtcIiRyXCJdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYoU2sucHl0aG9uMykge1xuXHQgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8Y2xhc3MgJ3R5cGUnPlwiKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIjx0eXBlICd0eXBlJz5cIik7XG5cdCAgICB9XG5cdH07XG5cblx0Ly9Tay5idWlsdGluLnR5cGUucHJvdG90eXBlLnRwJGRlc2NyX2dldCA9IGZ1bmN0aW9uKCkgeyBwcmludChcImluIHR5cGUgZGVzY3JfZ2V0XCIpOyB9O1xuXG5cdC8vU2suYnVpbHRpbi50eXBlLnByb3RvdHlwZS50cCRuYW1lID0gXCJ0eXBlXCI7XG5cblx0Ly8gYmFzaWNhbGx5IHRoZSBzYW1lIGFzIEdlbmVyaWNHZXRBdHRyIGV4Y2VwdCBsb29rcyBpbiB0aGUgcHJvdG8gaW5zdGVhZFxuXHRTay5idWlsdGluLnR5cGUucHJvdG90eXBlLnRwJGdldGF0dHIgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgdmFyIHJlcztcblx0ICAgIHZhciB0cCA9IHRoaXM7XG5cdCAgICB2YXIgZGVzY3I7XG5cdCAgICB2YXIgZjtcblxuXHQgICAgaWYgKHRoaXNbXCIkZFwiXSkge1xuXHQgICAgICAgIHJlcyA9IHRoaXNbXCIkZFwiXS5tcCRsb29rdXAobmV3IFNrLmJ1aWx0aW4uc3RyKG5hbWUpKTtcblx0ICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGRlc2NyID0gU2suYnVpbHRpbi50eXBlLnR5cGVMb29rdXAodHAsIG5hbWUpO1xuXG5cdCAgICAvL3ByaW50KFwidHlwZS50cGdldGF0dHIgZGVzY3JcIiwgZGVzY3IsIGRlc2NyLnRwJG5hbWUsIGRlc2NyLmZ1bmNfY29kZSwgbmFtZSk7XG5cdCAgICBpZiAoZGVzY3IgIT09IHVuZGVmaW5lZCAmJiBkZXNjciAhPT0gbnVsbCAmJiBkZXNjci5vYiR0eXBlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBmID0gZGVzY3Iub2IkdHlwZS50cCRkZXNjcl9nZXQ7XG5cdCAgICAgICAgLy8gdG9kbztpZiAoZiAmJiBkZXNjci50cCRkZXNjcl9zZXQpIC8vIGlzIGEgZGF0YSBkZXNjcmlwdG9yIGlmIGl0IGhhcyBhIHNldFxuXHQgICAgICAgIC8vIHJldHVybiBmLmNhbGwoZGVzY3IsIHRoaXMsIHRoaXMub2IkdHlwZSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChmKSB7XG5cdCAgICAgICAgLy8gbm9uLWRhdGEgZGVzY3JpcHRvclxuXHQgICAgICAgIHJldHVybiBmLmNhbGwoZGVzY3IsIG51bGwsIHRwKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGRlc2NyICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gZGVzY3I7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdH07XG5cblx0U2suYnVpbHRpbi50eXBlLnByb3RvdHlwZS50cCRzZXRhdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdCAgICAvLyBjbGFzcyBhdHRyaWJ1dGVzIGFyZSBkaXJlY3QgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0XG5cdCAgICB0aGlzW25hbWVdID0gdmFsdWU7XG5cdH07XG5cblx0U2suYnVpbHRpbi50eXBlLnR5cGVMb29rdXAgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSkge1xuXHQgICAgdmFyIG1ybyA9IHR5cGUudHAkbXJvO1xuXHQgICAgdmFyIHB5bmFtZSA9IG5ldyBTay5idWlsdGluLnN0cihuYW1lKTtcblx0ICAgIHZhciBiYXNlO1xuXHQgICAgdmFyIHJlcztcblx0ICAgIHZhciBpO1xuXG5cdCAgICAvLyB0b2RvOyBwcm9iYWJseSBzaG91bGQgZml4IHRoaXMsIHVzZWQgZm9yIGJ1aWx0aW4gdHlwZXMgdG8gZ2V0IHN0dWZmXG5cdCAgICAvLyBmcm9tIHByb3RvdHlwZVxuXHQgICAgaWYgKCFtcm8pIHtcblx0ICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHR5cGUucHJvdG90eXBlW25hbWVdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbXJvLnYubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICBiYXNlID0gbXJvLnZbaV07XG5cdCAgICAgICAgaWYgKGJhc2UuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2VbbmFtZV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlcyA9IGJhc2VbXCIkZFwiXS5tcCRsb29rdXAocHluYW1lKTtcblx0ICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGJhc2UucHJvdG90eXBlICYmIGJhc2UucHJvdG90eXBlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2UucHJvdG90eXBlW25hbWVdO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0fTtcblxuXHRTay5idWlsdGluLnR5cGUubXJvTWVyZ2VfID0gZnVuY3Rpb24gKHNlcXMpIHtcblx0ICAgIC8qXG5cdCAgICAgdmFyIHRtcCA9IFtdO1xuXHQgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vxcy5sZW5ndGg7ICsraSlcblx0ICAgICB7XG5cdCAgICAgdG1wLnB1c2gobmV3IFNrLmJ1aWx0aW4ubGlzdChzZXFzW2ldKSk7XG5cdCAgICAgfVxuXHQgICAgIHByaW50KFNrLmJ1aWx0aW4ucmVwcihuZXcgU2suYnVpbHRpbi5saXN0KHRtcCkpLnYpO1xuXHQgICAgICovXG5cdCAgICB2YXIgc2VxO1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgbmV4dDtcblx0ICAgIHZhciBrO1xuXHQgICAgdmFyIHNzZXE7XG5cdCAgICB2YXIgajtcblx0ICAgIHZhciBjYW5kO1xuXHQgICAgdmFyIGNhbmRzO1xuXHQgICAgdmFyIHJlcyA9IFtdO1xuXHQgICAgZm9yICg7IDspIHtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vxcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICBzZXEgPSBzZXFzW2ldO1xuXHQgICAgICAgICAgICBpZiAoc2VxLmxlbmd0aCAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGkgPT09IHNlcXMubGVuZ3RoKSB7IC8vIGFsbCBlbXB0eVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYW5kcyA9IFtdO1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXFzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIHNlcSA9IHNlcXNbaV07XG5cdCAgICAgICAgICAgIC8vcHJpbnQoXCJYWFhcIiwgU2suYnVpbHRpbi5yZXByKG5ldyBTay5idWlsdGluLmxpc3Qoc2VxKSkudik7XG5cdCAgICAgICAgICAgIGlmIChzZXEubGVuZ3RoICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBjYW5kID0gc2VxWzBdO1xuXHQgICAgICAgICAgICAgICAgLy9wcmludChcIkNBTkRcIiwgU2suYnVpbHRpbi5yZXByKGNhbmQpLnYpO1xuXHQgICAgICAgICAgICAgICAgT1VURVI6XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHNlcXMubGVuZ3RoOyArK2opIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3NlcSA9IHNlcXNbal07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGsgPCBzc2VxLmxlbmd0aDsgKytrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3NlcVtrXSA9PT0gY2FuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIE9VVEVSO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBjYW5kIGlzIG5vdCBpbiBhbnkgc2VxdWVuY2VzJyB0YWlsIC0+IGNvbnN0cmFpbnQtZnJlZVxuXHQgICAgICAgICAgICAgICAgaWYgKGogPT09IHNlcXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FuZHMucHVzaChjYW5kKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjYW5kcy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiSW5jb25zaXN0ZW50IHByZWNlZGVuY2VzIGluIHR5cGUgaGllcmFyY2h5XCIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG5leHQgPSBjYW5kc1swXTtcblx0ICAgICAgICAvLyBhcHBlbmQgbmV4dCB0byByZXN1bHQgYW5kIHJlbW92ZSBmcm9tIHNlcXVlbmNlc1xuXHQgICAgICAgIHJlcy5wdXNoKG5leHQpO1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXFzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIHNlcSA9IHNlcXNbaV07XG5cdCAgICAgICAgICAgIGlmIChzZXEubGVuZ3RoID4gMCAmJiBzZXFbMF0gPT09IG5leHQpIHtcblx0ICAgICAgICAgICAgICAgIHNlcS5zcGxpY2UoMCwgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH07XG5cblx0U2suYnVpbHRpbi50eXBlLmJ1aWxkTVJPXyA9IGZ1bmN0aW9uIChrbGFzcykge1xuXHQgICAgLy8gTUVSR0Uoa2xhc3MgKyBtcm8oYmFzZXMpICsgYmFzZXMpXG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciBiYXNlcztcblx0ICAgIHZhciBhbGwgPSBbXG5cdCAgICAgICAgW2tsYXNzXVxuXHQgICAgXTtcblxuXHQgICAgLy9Tay5kZWJ1Z291dChcImJ1aWxkTVJPIGZvclwiLCBrbGFzcy50cCRuYW1lKTtcblxuXHQgICAgdmFyIGtiYXNlcyA9IGtsYXNzW1wiJGRcIl0ubXAkc3Vic2NyaXB0KFNrLmJ1aWx0aW4udHlwZS5iYXNlc1N0cl8pO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IGtiYXNlcy52Lmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgYWxsLnB1c2goU2suYnVpbHRpbi50eXBlLmJ1aWxkTVJPXyhrYmFzZXMudltpXSkpO1xuXHQgICAgfVxuXG5cdCAgICBiYXNlcyA9IFtdO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IGtiYXNlcy52Lmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgYmFzZXMucHVzaChrYmFzZXMudltpXSk7XG5cdCAgICB9XG5cdCAgICBhbGwucHVzaChiYXNlcyk7XG5cblx0ICAgIHJldHVybiBTay5idWlsdGluLnR5cGUubXJvTWVyZ2VfKGFsbCk7XG5cdH07XG5cblx0Lypcblx0ICogQzMgTVJPIChha2EgQ1BMKSBsaW5lYXJpemF0aW9uLiBGaWd1cmVzIG91dCB3aGljaCBvcmRlciB0byBzZWFyY2ggdGhyb3VnaFxuXHQgKiBiYXNlIGNsYXNzZXMgdG8gZGV0ZXJtaW5lIHdoYXQgc2hvdWxkIG92ZXJyaWRlIHdoYXQuIEMzIGRvZXMgdGhlIFwicmlnaHRcblx0ICogdGhpbmdcIiwgYW5kIGl0J3Mgd2hhdCBQeXRob24gaGFzIHVzZWQgc2luY2UgMi4zLlxuXHQgKlxuXHQgKiBLaW5kIG9mIGNvbXBsaWNhdGVkIHRvIGV4cGxhaW4sIGJ1dCBub3QgcmVhbGx5IHRoYXQgY29tcGxpY2F0ZWQgaW5cblx0ICogaW1wbGVtZW50YXRpb24uIEV4cGxhbmF0aW9uczpcblx0ICpcblx0ICogaHR0cDovL3Blb3BsZS5jc2FpbC5taXQuZWR1L2pyYi9nb28vbWFudWFsLjQzL2dvb21hbnVhbF81NS5odG1sXG5cdCAqIGh0dHA6Ly93d3cucHl0aG9uLm9yZy9kb3dubG9hZC9yZWxlYXNlcy8yLjMvbXJvL1xuXHQgKiBodHRwOi8vMTkyLjIyMC45Ni4yMDEvZHlsYW4vbGluZWFyaXphdGlvbi1vb3BzbGE5Ni5odG1sXG5cdCAqXG5cdCAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gYSBwb3N0IGJ5IFNhbXVlbGUgUGVkcm9uaSBvbiBweXRob24tZGV2XG5cdCAqIChodHRwOi8vbWFpbC5weXRob24ub3JnL3BpcGVybWFpbC9weXRob24tZGV2LzIwMDItT2N0b2Jlci8wMjkxNzYuaHRtbCkgd2hlblxuXHQgKiBkaXNjdXNzaW5nIGl0cyBhZGRpdGlvbiB0byBQeXRob24uXG5cdCAqL1xuXHRTay5idWlsdGluLnR5cGUuYnVpbGRNUk8gPSBmdW5jdGlvbiAoa2xhc3MpIHtcblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShTay5idWlsdGluLnR5cGUuYnVpbGRNUk9fKGtsYXNzKSk7XG5cdH07XG5cblx0U2suYnVpbHRpbi50eXBlLnByb3RvdHlwZS50cCRyaWNoY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlciwgb3ApIHtcblx0ICAgIHZhciByMjtcblx0ICAgIHZhciByMTtcblx0ICAgIGlmIChvdGhlci5vYiR0eXBlICE9IFNrLmJ1aWx0aW4udHlwZSkge1xuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgICBpZiAoIXRoaXNbXCIkclwiXSB8fCAhb3RoZXJbXCIkclwiXSkge1xuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgICByMSA9IG5ldyBTay5idWlsdGluLnN0cih0aGlzW1wiJHJcIl0oKS52LnNsaWNlKDEsNikpO1xuXHQgICAgcjIgPSBuZXcgU2suYnVpbHRpbi5zdHIob3RoZXJbXCIkclwiXSgpLnYuc2xpY2UoMSw2KSk7XG5cdCAgICBpZiAodGhpc1tcIiRyXCJdKCkudi5zbGljZSgxLDYpICE9PSBcImNsYXNzXCIpIHtcblx0ICAgICAgICByMSA9IHRoaXNbXCIkclwiXSgpO1xuXHQgICAgICAgIHIyID0gb3RoZXJbXCIkclwiXSgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHIxLnRwJHJpY2hjb21wYXJlKHIyLCBvcCk7XG5cdH07XG5cblxuXG5cdC8qIC0tLS0gL1VzZXJzL3JvYi9za3VscHR5L2xpYi8uLi9ub2RlX21vZHVsZXMvc2t1bHB0L3NyYy9hYnN0cmFjdC5qcyAtLS0tICovIFxuXG5cdC8qKlxuXHQgKiBAbmFtZXNwYWNlIFNrLmFic3RyXG5cdCAqXG5cdCAqL1xuXHRTay5hYnN0ciA9IHt9O1xuXG5cdC8vXG5cdC8vIE51bWJlclxuXHQvL1xuXG5cdFNrLmFic3RyLnR5cGVOYW1lID0gZnVuY3Rpb24gKHYpIHtcblx0ICAgIHZhciB2dHlwZW5hbWU7XG5cdCAgICBpZiAodi50cCRuYW1lICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICB2dHlwZW5hbWUgPSB2LnRwJG5hbWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZ0eXBlbmFtZSA9IFwiPGludmFsaWQgdHlwZT5cIjtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2dHlwZW5hbWU7XG5cdH07XG5cblx0U2suYWJzdHIuYmlub3BfdHlwZV9lcnJvciA9IGZ1bmN0aW9uICh2LCB3LCBuYW1lKSB7XG5cdCAgICB2YXIgdnR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUodiksXG5cdCAgICAgICAgd3R5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUodyk7XG5cblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInVuc3VwcG9ydGVkIG9wZXJhbmQgdHlwZShzKSBmb3IgXCIgKyBuYW1lICsgXCI6ICdcIiArIHZ0eXBlbmFtZSArIFwiJyBhbmQgJ1wiICsgd3R5cGVuYW1lICsgXCInXCIpO1xuXHR9O1xuXG5cdFNrLmFic3RyLnVub3BfdHlwZV9lcnJvciA9IGZ1bmN0aW9uICh2LCBuYW1lKSB7XG5cdCAgICB2YXIgdnR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUodiksXG5cdCAgICAgICAgdW9wID0ge1xuXHQgICAgICAgICAgICBcIlVBZGRcIiAgOiBcIitcIixcblx0ICAgICAgICAgICAgXCJVU3ViXCIgIDogXCItXCIsXG5cdCAgICAgICAgICAgIFwiSW52ZXJ0XCI6IFwiflwiXG5cdCAgICAgICAgfVtuYW1lXTtcblxuXHQgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYmFkIG9wZXJhbmQgdHlwZSBmb3IgdW5hcnkgXCIgKyB1b3AgKyBcIjogJ1wiICsgdnR5cGVuYW1lICsgXCInXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBsb29rdXAgYW5kIHJldHVybiB0aGUgTEhTIG9iamVjdCBzbG90IGZ1bmN0aW9uIG1ldGhvZC4gIFRoaXMgY291ZGwgYmUgZWl0aGVyIGEgYnVpbHRpbiBzbG90IGZ1bmN0aW9uIG9yIGEgZHVuZGVyIG1ldGhvZCBkZWZpbmVkIGJ5IHRoZSB1c2VyLlxuXHQgKiBAcGFyYW0gb2JqXG5cdCAqIEBwYXJhbSBuYW1lXG5cdCAqIEByZXR1cm5zIHtPYmplY3R8bnVsbHx1bmRlZmluZWR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRTay5hYnN0ci5ib05hbWVUb1Nsb3RGdW5jTGhzXyA9IGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcblx0ICAgIGlmIChvYmogPT09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICBzd2l0Y2ggKG5hbWUpIHtcblx0ICAgIGNhc2UgXCJBZGRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGFkZCA/IG9iai5uYiRhZGQgOiBvYmpbXCJfX2FkZF9fXCJdO1xuXHQgICAgY2FzZSBcIlN1YlwiOlxuXHQgICAgICAgIHJldHVybiBvYmoubmIkc3VidHJhY3QgPyBvYmoubmIkc3VidHJhY3QgOiBvYmpbXCJfX3N1Yl9fXCJdO1xuXHQgICAgY2FzZSBcIk11bHRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJG11bHRpcGx5ID8gb2JqLm5iJG11bHRpcGx5IDogb2JqW1wiX19tdWxfX1wiXTtcblx0ICAgIGNhc2UgXCJEaXZcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGRpdmlkZSA/IG9iai5uYiRkaXZpZGUgOiBvYmpbXCJfX2Rpdl9fXCJdO1xuXHQgICAgY2FzZSBcIkZsb29yRGl2XCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRmbG9vcl9kaXZpZGUgPyBvYmoubmIkZmxvb3JfZGl2aWRlIDogb2JqW1wiX19mbG9vcmRpdl9fXCJdO1xuXHQgICAgY2FzZSBcIk1vZFwiOlxuXHQgICAgICAgIHJldHVybiBvYmoubmIkcmVtYWluZGVyID8gb2JqLm5iJHJlbWFpbmRlciA6IG9ialtcIl9fbW9kX19cIl07XG5cdCAgICBjYXNlIFwiRGl2TW9kXCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRkaXZtb2QgPyBvYmoubmIkZGl2bW9kIDogb2JqW1wiX19kaXZtb2RfX1wiXTtcblx0ICAgIGNhc2UgXCJQb3dcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJHBvd2VyID8gb2JqLm5iJHBvd2VyIDogb2JqW1wiX19wb3dfX1wiXTtcblx0ICAgIGNhc2UgXCJMU2hpZnRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGxzaGlmdCA/IG9iai5uYiRsc2hpZnQgOiBvYmpbXCJfX2xzaGlmdF9fXCJdO1xuXHQgICAgY2FzZSBcIlJTaGlmdFwiOlxuXHQgICAgICAgIHJldHVybiBvYmoubmIkcnNoaWZ0ID8gb2JqLm5iJHJzaGlmdCA6IG9ialtcIl9fcnNoaWZ0X19cIl07XG5cdCAgICBjYXNlIFwiQml0QW5kXCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRhbmQgPyBvYmoubmIkYW5kIDogb2JqW1wiX19hbmRfX1wiXTtcblx0ICAgIGNhc2UgXCJCaXRYb3JcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJHhvciA/IG9iai5uYiR4b3IgOiBvYmpbXCJfX3hvcl9fXCJdO1xuXHQgICAgY2FzZSBcIkJpdE9yXCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRvciA/IG9iai5uYiRvciA6IG9ialtcIl9fb3JfX1wiXTtcblx0ICAgIH1cblx0fTtcblxuXHRTay5hYnN0ci5ib05hbWVUb1Nsb3RGdW5jUmhzXyA9IGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcblx0ICAgIGlmIChvYmogPT09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICBzd2l0Y2ggKG5hbWUpIHtcblx0ICAgIGNhc2UgXCJBZGRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJHJlZmxlY3RlZF9hZGQgPyBvYmoubmIkcmVmbGVjdGVkX2FkZCA6IG9ialtcIl9fcmFkZF9fXCJdO1xuXHQgICAgY2FzZSBcIlN1YlwiOlxuXHQgICAgICAgIHJldHVybiBvYmoubmIkcmVmbGVjdGVkX3N1YnRyYWN0ID8gb2JqLm5iJHJlZmxlY3RlZF9zdWJ0cmFjdCA6IG9ialtcIl9fcnN1Yl9fXCJdO1xuXHQgICAgY2FzZSBcIk11bHRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJHJlZmxlY3RlZF9tdWx0aXBseSA/IG9iai5uYiRyZWZsZWN0ZWRfbXVsdGlwbHkgOiBvYmpbXCJfX3JtdWxfX1wiXTtcblx0ICAgIGNhc2UgXCJEaXZcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJHJlZmxlY3RlZF9kaXZpZGUgPyBvYmoubmIkcmVmbGVjdGVkX2RpdmlkZSA6IG9ialtcIl9fcmRpdl9fXCJdO1xuXHQgICAgY2FzZSBcIkZsb29yRGl2XCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlID8gb2JqLm5iJHJlZmxlY3RlZF9mbG9vcl9kaXZpZGUgOiBvYmpbXCJfX3JmbG9vcmRpdl9fXCJdO1xuXHQgICAgY2FzZSBcIk1vZFwiOlxuXHQgICAgICAgIHJldHVybiBvYmoubmIkcmVmbGVjdGVkX3JlbWFpbmRlciA/IG9iai5uYiRyZWZsZWN0ZWRfcmVtYWluZGVyIDogb2JqW1wiX19ybW9kX19cIl07XG5cdCAgICBjYXNlIFwiRGl2TW9kXCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRyZWZsZWN0ZWRfZGl2bW9kID8gb2JqLm5iJHJlZmxlY3RlZF9kaXZtb2QgOiBvYmpbXCJfX3JkaXZtb2RfX1wiXTtcblx0ICAgIGNhc2UgXCJQb3dcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJHJlZmxlY3RlZF9wb3dlciA/IG9iai5uYiRyZWZsZWN0ZWRfcG93ZXIgOiBvYmpbXCJfX3Jwb3dfX1wiXTtcblx0ICAgIGNhc2UgXCJMU2hpZnRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJHJlZmxlY3RlZF9sc2hpZnQgPyBvYmoubmIkcmVmbGVjdGVkX2xzaGlmdCA6IG9ialtcIl9fcmxzaGlmdF9fXCJdO1xuXHQgICAgY2FzZSBcIlJTaGlmdFwiOlxuXHQgICAgICAgIHJldHVybiBvYmoubmIkcmVmbGVjdGVkX3JzaGlmdCA/IG9iai5uYiRyZWZsZWN0ZWRfcnNoaWZ0IDogb2JqW1wiX19ycnNoaWZ0X19cIl07XG5cdCAgICBjYXNlIFwiQml0QW5kXCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRyZWZsZWN0ZWRfYW5kID8gb2JqLm5iJHJlZmxlY3RlZF9hbmQgOiBvYmpbXCJfX3JhbmRfX1wiXTtcblx0ICAgIGNhc2UgXCJCaXRYb3JcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJHJlZmxlY3RlZF94b3IgPyBvYmoubmIkcmVmbGVjdGVkX3hvciA6IG9ialtcIl9fcnhvcl9fXCJdO1xuXHQgICAgY2FzZSBcIkJpdE9yXCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRyZWZsZWN0ZWRfb3IgPyBvYmoubmIkcmVmbGVjdGVkX29yIDogb2JqW1wiX19yb3JfX1wiXTtcblx0ICAgIH1cblx0fTtcblxuXHRTay5hYnN0ci5pYm9OYW1lVG9TbG90RnVuY18gPSBmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG5cdCAgICBzd2l0Y2ggKG5hbWUpIHtcblx0ICAgIGNhc2UgXCJBZGRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGlucGxhY2VfYWRkID8gb2JqLm5iJGlucGxhY2VfYWRkIDogb2JqW1wiX19pYWRkX19cIl07XG5cdCAgICBjYXNlIFwiU3ViXCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRpbnBsYWNlX3N1YnRyYWN0ID8gb2JqLm5iJGlucGxhY2Vfc3VidHJhY3QgOiBvYmpbXCJfX2lzdWJfX1wiXTtcblx0ICAgIGNhc2UgXCJNdWx0XCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRpbnBsYWNlX211bHRpcGx5ID8gb2JqLm5iJGlucGxhY2VfbXVsdGlwbHkgOiBvYmpbXCJfX2ltdWxfX1wiXTtcblx0ICAgIGNhc2UgXCJEaXZcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGlucGxhY2VfZGl2aWRlID8gb2JqLm5iJGlucGxhY2VfZGl2aWRlIDogb2JqW1wiX19pZGl2X19cIl07XG5cdCAgICBjYXNlIFwiRmxvb3JEaXZcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGlucGxhY2VfZmxvb3JfZGl2aWRlID8gb2JqLm5iJGlucGxhY2VfZmxvb3JfZGl2aWRlIDogb2JqW1wiX19pZmxvb3JkaXZfX1wiXTtcblx0ICAgIGNhc2UgXCJNb2RcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGlucGxhY2VfcmVtYWluZGVyO1xuXHQgICAgY2FzZSBcIlBvd1wiOlxuXHQgICAgICAgIHJldHVybiBvYmoubmIkaW5wbGFjZV9wb3dlcjtcblx0ICAgIGNhc2UgXCJMU2hpZnRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGlucGxhY2VfbHNoaWZ0ID8gb2JqLm5iJGlucGxhY2VfbHNoaWZ0IDogb2JqW1wiX19pbHNoaWZ0X19cIl07XG5cdCAgICBjYXNlIFwiUlNoaWZ0XCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRpbnBsYWNlX3JzaGlmdCA/IG9iai5uYiRpbnBsYWNlX3JzaGlmdCA6IG9ialtcIl9faXJzaGlmdF9fXCJdO1xuXHQgICAgY2FzZSBcIkJpdEFuZFwiOlxuXHQgICAgICAgIHJldHVybiBvYmoubmIkaW5wbGFjZV9hbmQ7XG5cdCAgICBjYXNlIFwiQml0T3JcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGlucGxhY2Vfb3I7XG5cdCAgICBjYXNlIFwiQml0WG9yXCI6XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRpbnBsYWNlX3hvciA/IG9iai5uYiRpbnBsYWNlX3hvciA6IG9ialtcIl9faXhvcl9fXCJdO1xuXHQgICAgfVxuXHR9O1xuXHRTay5hYnN0ci51b05hbWVUb1Nsb3RGdW5jXyA9IGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcblx0ICAgIGlmIChvYmogPT09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgICAgc3dpdGNoIChuYW1lKSB7XG5cdCAgICBjYXNlIFwiVVN1YlwiOlxuXHQgICAgICAgIHJldHVybiBvYmoubmIkbmVnYXRpdmUgPyBvYmoubmIkbmVnYXRpdmUgOiBvYmpbXCJfX25lZ19fXCJdO1xuXHQgICAgY2FzZSBcIlVBZGRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJHBvc2l0aXZlID8gb2JqLm5iJHBvc2l0aXZlIDogb2JqW1wiX19wb3NfX1wiXTtcblx0ICAgIGNhc2UgXCJJbnZlcnRcIjpcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJGludmVydCA/IG9iai5uYiRpbnZlcnQgOiBvYmpbXCJfX2ludmVydF9fXCJdO1xuXHQgICAgfVxuXHR9O1xuXG5cdFNrLmFic3RyLmJpbmFyeV9vcF8gPSBmdW5jdGlvbiAodiwgdywgb3BuYW1lKSB7XG5cdCAgICB2YXIgd29wO1xuXHQgICAgdmFyIHJldDtcblx0ICAgIHZhciB2b3A7XG5cblx0ICAgIC8vIEFsbCBQeXRob24gaW5oZXJpdGFuY2UgaXMgbm93IGVuZm9yY2VkIHdpdGggSmF2YXNjcmlwdCBpbmhlcml0YW5jZVxuXHQgICAgLy8gKHNlZSBTay5hYnN0ci5zZXRVcEluaGVyaXRhbmNlKS4gVGhpcyBjaGVja3MgaWYgdydzIHR5cGUgaXMgYSBzdHJpY3Rcblx0ICAgIC8vIHN1YmNsYXNzIG9mIHYncyB0eXBlXG5cdCAgICB2YXIgd19pc19zdWJjbGFzcyA9IHcuY29uc3RydWN0b3IucHJvdG90eXBlIGluc3RhbmNlb2Ygdi5jb25zdHJ1Y3RvcjtcblxuXHQgICAgLy8gRnJvbSB0aGUgUHl0aG9uIDIuNyBkb2NzOlxuXHQgICAgLy9cblx0ICAgIC8vIFwiSWYgdGhlIHJpZ2h0IG9wZXJhbmTigJlzIHR5cGUgaXMgYSBzdWJjbGFzcyBvZiB0aGUgbGVmdCBvcGVyYW5k4oCZcyB0eXBlIGFuZFxuXHQgICAgLy8gdGhhdCBzdWJjbGFzcyBwcm92aWRlcyB0aGUgcmVmbGVjdGVkIG1ldGhvZCBmb3IgdGhlIG9wZXJhdGlvbiwgdGhpc1xuXHQgICAgLy8gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSB0aGUgbGVmdCBvcGVyYW5k4oCZcyBub24tcmVmbGVjdGVkIG1ldGhvZC5cblx0ICAgIC8vIFRoaXMgYmVoYXZpb3IgYWxsb3dzIHN1YmNsYXNzZXMgdG8gb3ZlcnJpZGUgdGhlaXIgYW5jZXN0b3Jz4oCZIG9wZXJhdGlvbnMuXCJcblx0ICAgIC8vXG5cdCAgICAvLyAtLSBodHRwczovL2RvY3MucHl0aG9uLm9yZy8yL3JlZmVyZW5jZS9kYXRhbW9kZWwuaHRtbCNpbmRleC05MlxuXG5cdCAgICBpZiAod19pc19zdWJjbGFzcykge1xuXHQgICAgICAgIHdvcCA9IFNrLmFic3RyLmJvTmFtZVRvU2xvdEZ1bmNSaHNfKHcsIG9wbmFtZSk7XG5cdCAgICAgICAgaWYgKHdvcCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIGlmICh3b3AuY2FsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0ID0gd29wLmNhbGwodywgdik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltKHdvcCwgdywgdik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkICYmIHJldCAhPT0gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZvcCA9IFNrLmFic3RyLmJvTmFtZVRvU2xvdEZ1bmNMaHNfKHYsIG9wbmFtZSk7XG5cdCAgICBpZiAodm9wICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBpZiAodm9wLmNhbGwpIHtcblx0ICAgICAgICAgICAgcmV0ID0gdm9wLmNhbGwodiwgdyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbSh2b3AsIHYsIHcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQgJiYgcmV0ICE9PSBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIERvbid0IHJldHJ5IFJIUyBpZiBmYWlsZWQgYWJvdmVcblx0ICAgIGlmICghd19pc19zdWJjbGFzcykge1xuXHQgICAgICAgIHdvcCA9IFNrLmFic3RyLmJvTmFtZVRvU2xvdEZ1bmNSaHNfKHcsIG9wbmFtZSk7XG5cdCAgICAgICAgaWYgKHdvcCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIGlmICh3b3AuY2FsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0ID0gd29wLmNhbGwodywgdik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltKHdvcCwgdywgdik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkICYmIHJldCAhPT0gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBTay5hYnN0ci5iaW5vcF90eXBlX2Vycm9yKHYsIHcsIG9wbmFtZSk7XG5cdH07XG5cblx0U2suYWJzdHIuYmluYXJ5X2lvcF8gPSBmdW5jdGlvbiAodiwgdywgb3BuYW1lKSB7XG5cdCAgICB2YXIgd29wO1xuXHQgICAgdmFyIHJldDtcblx0ICAgIHZhciB2b3AgPSBTay5hYnN0ci5pYm9OYW1lVG9TbG90RnVuY18odiwgb3BuYW1lKTtcblx0ICAgIGlmICh2b3AgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGlmICh2b3AuY2FsbCkge1xuXHQgICAgICAgICAgICByZXQgPSB2b3AuY2FsbCh2LCB3KTtcblx0ICAgICAgICB9IGVsc2UgeyAgLy8gYXNzdW1lIHRoYXQgdm9wIGlzIGFuIF9feHh4X18gdHlwZSBtZXRob2Rcblx0ICAgICAgICAgICAgcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbSh2b3AsIHYsIHcpOyAvLyAgYWRkZWQgdG8gYmUgbGlrZSBub3QtaW4tcGxhY2UuLi4gaXMgdGhpcyBva2F5P1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQgJiYgcmV0ICE9PSBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHdvcCA9IFNrLmFic3RyLmlib05hbWVUb1Nsb3RGdW5jXyh3LCBvcG5hbWUpO1xuXHQgICAgaWYgKHdvcCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaWYgKHdvcC5jYWxsKSB7XG5cdCAgICAgICAgICAgIHJldCA9IHdvcC5jYWxsKHcsIHYpO1xuXHQgICAgICAgIH0gZWxzZSB7IC8vIGFzc3VtZSB0aGF0IHdvcCBpcyBhbiBfX3h4eF9fIHR5cGUgbWV0aG9kXG5cdCAgICAgICAgICAgIHJldCA9IFNrLm1pc2NldmFsLmNhbGxzaW0od29wLCB3LCB2KTsgLy8gIGFkZGVkIHRvIGJlIGxpa2Ugbm90LWluLXBsYWNlLi4uIGlzIHRoaXMgb2theT9cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkICYmIHJldCAhPT0gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBTay5hYnN0ci5iaW5vcF90eXBlX2Vycm9yKHYsIHcsIG9wbmFtZSk7XG5cdH07XG5cdFNrLmFic3RyLnVuYXJ5X29wXyA9IGZ1bmN0aW9uICh2LCBvcG5hbWUpIHtcblx0ICAgIHZhciByZXQ7XG5cdCAgICB2YXIgdm9wID0gU2suYWJzdHIudW9OYW1lVG9TbG90RnVuY18odiwgb3BuYW1lKTtcblx0ICAgIGlmICh2b3AgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGlmICh2b3AuY2FsbCkge1xuXHQgICAgICAgICAgICByZXQgPSB2b3AuY2FsbCh2KTtcblx0ICAgICAgICB9IGVsc2UgeyAgLy8gYXNzdW1lIHRoYXQgdm9wIGlzIGFuIF9feHh4X18gdHlwZSBtZXRob2Rcblx0ICAgICAgICAgICAgcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbSh2b3AsIHYpOyAvLyAgYWRkZWQgdG8gYmUgbGlrZSBub3QtaW4tcGxhY2UuLi4gaXMgdGhpcyBva2F5P1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBTay5hYnN0ci51bm9wX3R5cGVfZXJyb3Iodiwgb3BuYW1lKTtcblx0fTtcblxuXHQvL1xuXHQvLyBoYW5kbGUgdXBjb252ZXJ0aW5nIGEvYiBmcm9tIG51bWJlciB0byBsb25nIGlmIG9wIGNhdXNlcyB0b28gYmlnL3NtYWxsIGFcblx0Ly8gcmVzdWx0LCBvciBpZiBlaXRoZXIgb2YgdGhlIG9wcyBhcmUgYWxyZWFkeSBsb25nc1xuXHRTay5hYnN0ci5udW1PcEFuZFByb21vdGUgPSBmdW5jdGlvbiAoYSwgYiwgb3Bmbikge1xuXHQgICAgdmFyIHRtcDtcblx0ICAgIHZhciBhbnM7XG5cdCAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBiID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgYW5zID0gb3BmbihhLCBiKTtcblx0ICAgICAgICAvLyB0b2RvOyBoYW5kbGUgZmxvYXQgICBSZW1vdmVkIFJOTCAoYnVncyBpbiBsbmcsIGFuZCBpdCBzaG91bGQgYmUgYSBxdWVzdGlvbiBvZiBwcmVjaXNpb24sIG5vdCBtYWduaXR1ZGUgLS0gdGhpcyB3YXMganVzdCB3cm9uZylcblx0ICAgICAgICBpZiAoKGFucyA+IFNrLmJ1aWx0aW4uaW50Xy50aHJlc2hvbGQkIHx8IGFucyA8IC1Tay5idWlsdGluLmludF8udGhyZXNob2xkJCkgJiYgTWF0aC5mbG9vcihhbnMpID09PSBhbnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFtTay5idWlsdGluLmxuZy5mcm9tSW50JChhKSwgU2suYnVpbHRpbi5sbmcuZnJvbUludCQoYildO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhbnM7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTmFtZUVycm9yKFwiVW5kZWZpbmVkIHZhcmlhYmxlIGluIGV4cHJlc3Npb25cIik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBTay5idWlsdGluLmxuZykge1xuXHQgICAgICAgIHJldHVybiBbYSwgYl07XG5cdCAgICB9IGVsc2UgaWYgKChhLmNvbnN0cnVjdG9yID09PSBTay5idWlsdGluLmludF8gfHxcblx0ICAgICAgICAgICAgICAgIGEuY29uc3RydWN0b3IgPT09IFNrLmJ1aWx0aW4uZmxvYXRfKSAmJlxuXHQgICAgICAgICAgICAgICAgYi5jb25zdHJ1Y3RvciA9PT0gU2suYnVpbHRpbi5jb21wbGV4KSB7XG5cdCAgICAgICAgLy8gc3BlY2lhbCBjYXNlIG9mIHVwY29udmVydGluZyBubWJlciBhbmQgY29tcGxleFxuXHQgICAgICAgIC8vIGNhbiB3ZSB1c2UgaGVyZSB0aGUgU2suYnVpbHRpbi5jaGVja0NvbXBsZXgoKSBtZXRob2Q/XG5cdCAgICAgICAgdG1wID0gbmV3IFNrLmJ1aWx0aW4uY29tcGxleChhKTtcblx0ICAgICAgICByZXR1cm4gW3RtcCwgYl07XG5cdCAgICB9IGVsc2UgaWYgKGEuY29uc3RydWN0b3IgPT09IFNrLmJ1aWx0aW4uaW50XyB8fFxuXHQgICAgICAgICAgICAgICBhLmNvbnN0cnVjdG9yID09PSBTay5idWlsdGluLmZsb2F0Xykge1xuXHQgICAgICAgIHJldHVybiBbYSwgYl07XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgdG1wID0gU2suYnVpbHRpbi5hc3NrJChhKTtcblx0ICAgICAgICByZXR1cm4gW3RtcCwgYl07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdH07XG5cblx0U2suYWJzdHIuYm9OdW1Qcm9tb3RlXyA9IHtcblx0ICAgIFwiQWRkXCIgICAgIDogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gYSArIGI7XG5cdCAgICB9LFxuXHQgICAgXCJTdWJcIiAgICAgOiBmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBhIC0gYjtcblx0ICAgIH0sXG5cdCAgICBcIk11bHRcIiAgICA6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIGEgKiBiO1xuXHQgICAgfSxcblx0ICAgIFwiTW9kXCIgICAgIDogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICB2YXIgbTtcblx0ICAgICAgICBpZiAoYiA9PT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtID0gYSAlIGI7XG5cdCAgICAgICAgcmV0dXJuICgobSAqIGIpIDwgMCA/IChtICsgYikgOiBtKTtcblx0ICAgIH0sXG5cdCAgICBcIkRpdlwiICAgICA6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgaWYgKGIgPT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCJkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gYSAvIGI7XG5cdCAgICAgICAgfVxuXHQgICAgfSxcblx0ICAgIFwiRmxvb3JEaXZcIjogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICBpZiAoYiA9PT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGEgLyBiKTtcblx0ICAgICAgICB9IC8vIHRvZG87IHdyb25nPyBuZWc/XG5cdCAgICB9LFxuXHQgICAgXCJQb3dcIiAgICAgOiBNYXRoLnBvdyxcblx0ICAgIFwiQml0QW5kXCIgIDogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICB2YXIgbSA9IGEgJiBiO1xuXHQgICAgICAgIGlmIChtIDwgMCkge1xuXHQgICAgICAgICAgICBtID0gbSArIDQyOTQ5NjcyOTY7IC8vIGNvbnZlcnQgYmFjayB0byB1bnNpZ25lZFxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbTtcblx0ICAgIH0sXG5cdCAgICBcIkJpdE9yXCIgICA6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgdmFyIG0gPSBhIHwgYjtcblx0ICAgICAgICBpZiAobSA8IDApIHtcblx0ICAgICAgICAgICAgbSA9IG0gKyA0Mjk0OTY3Mjk2OyAvLyBjb252ZXJ0IGJhY2sgdG8gdW5zaWduZWRcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG07XG5cdCAgICB9LFxuXHQgICAgXCJCaXRYb3JcIiAgOiBmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgIHZhciBtID0gYSBeIGI7XG5cdCAgICAgICAgaWYgKG0gPCAwKSB7XG5cdCAgICAgICAgICAgIG0gPSBtICsgNDI5NDk2NzI5NjsgLy8gY29udmVydCBiYWNrIHRvIHVuc2lnbmVkXG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBtO1xuXHQgICAgfSxcblx0ICAgIFwiTFNoaWZ0XCIgIDogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICB2YXIgbTtcblx0ICAgICAgICBpZiAoYiA8IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm5lZ2F0aXZlIHNoaWZ0IGNvdW50XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtID0gYSA8PCBiO1xuXHQgICAgICAgIGlmIChtID4gYSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBGYWlsLCB0aGlzIHdpbGwgZ2V0IHJlY29tcHV0ZWQgd2l0aCBsb25nc1xuXHQgICAgICAgICAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIGIpO1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBcIlJTaGlmdFwiICA6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgdmFyIG07XG5cdCAgICAgICAgaWYgKGIgPCAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJuZWdhdGl2ZSBzaGlmdCBjb3VudFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbSA9IGEgPj4gYjtcblx0ICAgICAgICBpZiAoKGEgPiAwKSAmJiAobSA8IDApKSB7XG5cdCAgICAgICAgICAgIC8vIGZpeCBpbmNvcnJlY3Qgc2lnbiBleHRlbnNpb25cblx0ICAgICAgICAgICAgbSA9IG0gJiAoTWF0aC5wb3coMiwgMzIgLSBiKSAtIDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbTtcblx0ICAgIH1cblx0fTtcblxuXHRTay5hYnN0ci5udW1iZXJCaW5PcCA9IGZ1bmN0aW9uICh2LCB3LCBvcCkge1xuXHQgICAgdmFyIHRtcDtcblx0ICAgIHZhciBudW1Qcm9tb3RlRnVuYyA9IFNrLmFic3RyLmJvTnVtUHJvbW90ZV9bb3BdO1xuXHQgICAgaWYgKG51bVByb21vdGVGdW5jICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICB0bXAgPSBTay5hYnN0ci5udW1PcEFuZFByb21vdGUodiwgdywgbnVtUHJvbW90ZUZ1bmMpO1xuXHQgICAgICAgIGlmICh0eXBlb2YgdG1wID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0bXA7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0bXAgIT09IHVuZGVmaW5lZCAmJiB0bXAuY29uc3RydWN0b3IgPT09IFNrLmJ1aWx0aW4uaW50Xykge1xuXHQgICAgICAgICAgICByZXR1cm4gdG1wO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodG1wICE9PSB1bmRlZmluZWQgJiYgdG1wLmNvbnN0cnVjdG9yID09PSBTay5idWlsdGluLmZsb2F0Xykge1xuXHQgICAgICAgICAgICByZXR1cm4gdG1wO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodG1wICE9PSB1bmRlZmluZWQgJiYgdG1wLmNvbnN0cnVjdG9yID09PSBTay5idWlsdGluLmxuZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdG1wO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodG1wICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgdiA9IHRtcFswXTtcblx0ICAgICAgICAgICAgdyA9IHRtcFsxXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBTay5hYnN0ci5iaW5hcnlfb3BfKHYsIHcsIG9wKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5udW1iZXJCaW5PcFwiLCBTay5hYnN0ci5udW1iZXJCaW5PcCk7XG5cblx0U2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wID0gZnVuY3Rpb24gKHYsIHcsIG9wKSB7XG5cdCAgICB2YXIgdG1wO1xuXHQgICAgdmFyIG51bVByb21vdGVGdW5jID0gU2suYWJzdHIuYm9OdW1Qcm9tb3RlX1tvcF07XG5cdCAgICBpZiAobnVtUHJvbW90ZUZ1bmMgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHRtcCA9IFNrLmFic3RyLm51bU9wQW5kUHJvbW90ZSh2LCB3LCBudW1Qcm9tb3RlRnVuYyk7XG5cdCAgICAgICAgaWYgKHR5cGVvZiB0bXAgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRtcDtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRtcCAhPT0gdW5kZWZpbmVkICYmIHRtcC5jb25zdHJ1Y3RvciA9PT0gU2suYnVpbHRpbi5pbnRfKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0bXA7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0bXAgIT09IHVuZGVmaW5lZCAmJiB0bXAuY29uc3RydWN0b3IgPT09IFNrLmJ1aWx0aW4uZmxvYXRfKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0bXA7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0bXAgIT09IHVuZGVmaW5lZCAmJiB0bXAuY29uc3RydWN0b3IgPT09IFNrLmJ1aWx0aW4ubG5nKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0bXA7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0bXAgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICB2ID0gdG1wWzBdO1xuXHQgICAgICAgICAgICB3ID0gdG1wWzFdO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFNrLmFic3RyLmJpbmFyeV9pb3BfKHYsIHcsIG9wKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3BcIiwgU2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wKTtcblxuXHRTay5hYnN0ci5udW1iZXJVbmFyeU9wID0gZnVuY3Rpb24gKHYsIG9wKSB7XG5cdCAgICB2YXIgdmFsdWU7XG5cdCAgICBpZiAob3AgPT09IFwiTm90XCIpIHtcblx0ICAgICAgICByZXR1cm4gU2subWlzY2V2YWwuaXNUcnVlKHYpID8gU2suYnVpbHRpbi5ib29sLmZhbHNlJCA6IFNrLmJ1aWx0aW4uYm9vbC50cnVlJDtcblx0ICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYm9vbCkge1xuXHQgICAgICAgIHZhbHVlID0gU2suYnVpbHRpbi5hc251bSQodik7XG5cdCAgICAgICAgaWYgKG9wID09PSBcIlVTdWJcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XygtdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAob3AgPT09IFwiVUFkZFwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG9wID09PSBcIkludmVydFwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKH52YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAob3AgPT09IFwiVVN1YlwiICYmIHYubmIkbmVnYXRpdmUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHYubmIkbmVnYXRpdmUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG9wID09PSBcIlVBZGRcIiAmJiB2Lm5iJHBvc2l0aXZlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2Lm5iJHBvc2l0aXZlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvcCA9PT0gXCJJbnZlcnRcIiAmJiB2Lm5iJGludmVydCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdi5uYiRpbnZlcnQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBTay5hYnN0ci51bmFyeV9vcF8odiwgb3ApO1xuXHR9O1xuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLm51bWJlclVuYXJ5T3BcIiwgU2suYWJzdHIubnVtYmVyVW5hcnlPcCk7XG5cblx0Ly9cblx0Ly8gU2VxdWVuY2Vcblx0Ly9cblxuXHRTay5hYnN0ci5maXhTZXFJbmRleF8gPSBmdW5jdGlvbiAoc2VxLCBpKSB7XG5cdCAgICBpID0gU2suYnVpbHRpbi5hc251bSQoaSk7XG5cdCAgICBpZiAoaSA8IDAgJiYgc2VxLnNxJGxlbmd0aCkge1xuXHQgICAgICAgIGkgKz0gc2VxLnNxJGxlbmd0aCgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Kn0gc2VxXG5cdCAqIEBwYXJhbSB7Kn0gb2Jcblx0ICogQHBhcmFtIHtib29sZWFuPX0gY2FuU3VzcGVuZFxuXHQgKi9cblx0U2suYWJzdHIuc2VxdWVuY2VDb250YWlucyA9IGZ1bmN0aW9uIChzZXEsIG9iLCBjYW5TdXNwZW5kKSB7XG5cdCAgICB2YXIgc2VxdHlwZW5hbWU7XG5cdCAgICB2YXIgc3BlY2lhbDtcblx0ICAgIHZhciByO1xuXG5cdCAgICBpZiAoc2VxLnNxJGNvbnRhaW5zKSB7XG5cdCAgICAgICAgcmV0dXJuIHNlcS5zcSRjb250YWlucyhvYik7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogIExvb2sgZm9yIHNwZWNpYWwgbWV0aG9kIGFuZCBjYWxsIGl0LCB3ZSBoYXZlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gYnVpbHQtaW5zIGFuZFxuXHQgICAgICogIHB5dGhvbiBvYmplY3RzXG5cdCAgICAgKi9cblx0ICAgIHNwZWNpYWwgPSBTay5hYnN0ci5sb29rdXBTcGVjaWFsKHNlcSwgXCJfX2NvbnRhaW5zX19cIik7XG5cdCAgICBpZiAoc3BlY2lhbCAhPSBudWxsKSB7XG5cdCAgICAgICAgLy8gbWV0aG9kIG9uIGJ1aWx0aW4sIHByb3ZpZGUgdGhpcyBhcmdcblx0ICAgICAgICByZXR1cm4gU2subWlzY2V2YWwuaXNUcnVlKFNrLm1pc2NldmFsLmNhbGxzaW0oc3BlY2lhbCwgc2VxLCBvYikpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIVNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShzZXEpKSB7XG5cdCAgICAgICAgc2VxdHlwZW5hbWUgPSBTay5hYnN0ci50eXBlTmFtZShzZXEpO1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFyZ3VtZW50IG9mIHR5cGUgJ1wiICsgc2VxdHlwZW5hbWUgKyBcIicgaXMgbm90IGl0ZXJhYmxlXCIpO1xuXHQgICAgfVxuXG5cdCAgICByID0gU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKHNlcSksIGZ1bmN0aW9uKGkpIHtcblx0ICAgICAgICBpZiAoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGksIG9iLCBcIkVxXCIpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsodHJ1ZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0sIGZhbHNlKTtcblxuXHQgICAgcmV0dXJuIGNhblN1c3BlbmQgPyByIDogU2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHIpO1xuXHR9O1xuXG5cdFNrLmFic3RyLnNlcXVlbmNlQ29uY2F0ID0gZnVuY3Rpb24gKHNlcTEsIHNlcTIpIHtcblx0ICAgIHZhciBzZXExdHlwZW5hbWU7XG5cdCAgICBpZiAoc2VxMS5zcSRjb25jYXQpIHtcblx0ICAgICAgICByZXR1cm4gc2VxMS5zcSRjb25jYXQoc2VxMik7XG5cdCAgICB9XG5cdCAgICBzZXExdHlwZW5hbWUgPSBTay5hYnN0ci50eXBlTmFtZShzZXExKTtcblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIiArIHNlcTF0eXBlbmFtZSArIFwiJyBvYmplY3QgY2FuJ3QgYmUgY29uY2F0ZW5hdGVkXCIpO1xuXHR9O1xuXG5cdFNrLmFic3RyLnNlcXVlbmNlR2V0SW5kZXhPZiA9IGZ1bmN0aW9uIChzZXEsIG9iKSB7XG5cdCAgICB2YXIgc2VxdHlwZW5hbWU7XG5cdCAgICB2YXIgaSwgaXQ7XG5cdCAgICB2YXIgaW5kZXg7XG5cdCAgICBpZiAoc2VxLmluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW0oc2VxLmluZGV4LCBzZXEsIG9iKTtcblx0ICAgIH1cblx0ICAgIGlmIChTay5idWlsdGluLmNoZWNrSXRlcmFibGUoc2VxKSkge1xuXHQgICAgICAgIGluZGV4ID0gMDtcblx0ICAgICAgICBmb3IgKGl0ID0gU2suYWJzdHIuaXRlcihzZXEpLCBpID0gaXQudHAkaXRlcm5leHQoKTtcblx0ICAgICAgICAgICAgIGkgIT09IHVuZGVmaW5lZDsgaSA9IGl0LnRwJGl0ZXJuZXh0KCkpIHtcblx0ICAgICAgICAgICAgaWYgKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChvYiwgaSwgXCJFcVwiKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oaW5kZXgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGluZGV4ICs9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzZXF1ZW5jZS5pbmRleCh4KTogeCBub3QgaW4gc2VxdWVuY2VcIik7XG5cdCAgICB9XG5cblx0ICAgIHNlcXR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUoc2VxKTtcblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFyZ3VtZW50IG9mIHR5cGUgJ1wiICsgc2VxdHlwZW5hbWUgKyBcIicgaXMgbm90IGl0ZXJhYmxlXCIpO1xuXHR9O1xuXG5cdFNrLmFic3RyLnNlcXVlbmNlR2V0Q291bnRPZiA9IGZ1bmN0aW9uIChzZXEsIG9iKSB7XG5cdCAgICB2YXIgc2VxdHlwZW5hbWU7XG5cdCAgICB2YXIgaSwgaXQ7XG5cdCAgICB2YXIgY291bnQ7XG5cdCAgICBpZiAoc2VxLmNvdW50KSB7XG5cdCAgICAgICAgcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW0oc2VxLmNvdW50LCBzZXEsIG9iKTtcblx0ICAgIH1cblx0ICAgIGlmIChTay5idWlsdGluLmNoZWNrSXRlcmFibGUoc2VxKSkge1xuXHQgICAgICAgIGNvdW50ID0gMDtcblx0ICAgICAgICBmb3IgKGl0ID0gU2suYWJzdHIuaXRlcihzZXEpLCBpID0gaXQudHAkaXRlcm5leHQoKTtcblx0ICAgICAgICAgICAgIGkgIT09IHVuZGVmaW5lZDsgaSA9IGl0LnRwJGl0ZXJuZXh0KCkpIHtcblx0ICAgICAgICAgICAgaWYgKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChvYiwgaSwgXCJFcVwiKSkge1xuXHQgICAgICAgICAgICAgICAgY291bnQgKz0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyhjb3VudCk7XG5cdCAgICB9XG5cblx0ICAgIHNlcXR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUoc2VxKTtcblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFyZ3VtZW50IG9mIHR5cGUgJ1wiICsgc2VxdHlwZW5hbWUgKyBcIicgaXMgbm90IGl0ZXJhYmxlXCIpO1xuXHR9O1xuXG5cdFNrLmFic3RyLnNlcXVlbmNlR2V0SXRlbSA9IGZ1bmN0aW9uIChzZXEsIGksIGNhblN1c3BlbmQpIHtcblx0ICAgIHZhciBzZXF0eXBlbmFtZTtcblx0ICAgIGlmIChzZXEubXAkc3Vic2NyaXB0KSB7XG5cdCAgICAgICAgcmV0dXJuIHNlcS5tcCRzdWJzY3JpcHQoaSk7XG5cdCAgICB9XG5cblx0ICAgIHNlcXR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUoc2VxKTtcblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIiArIHNlcXR5cGVuYW1lICsgXCInIG9iamVjdCBpcyB1bnN1YnNjcmlwdGFibGVcIik7XG5cdH07XG5cblx0U2suYWJzdHIuc2VxdWVuY2VTZXRJdGVtID0gZnVuY3Rpb24gKHNlcSwgaSwgeCwgY2FuU3VzcGVuZCkge1xuXHQgICAgdmFyIHNlcXR5cGVuYW1lO1xuXHQgICAgaWYgKHNlcS5tcCRhc3Nfc3Vic2NyaXB0KSB7XG5cdCAgICAgICAgcmV0dXJuIHNlcS5tcCRhc3Nfc3Vic2NyaXB0KGksIHgpO1xuXHQgICAgfVxuXG5cdCAgICBzZXF0eXBlbmFtZSA9IFNrLmFic3RyLnR5cGVOYW1lKHNlcSk7XG5cdCAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIgKyBzZXF0eXBlbmFtZSArIFwiJyBvYmplY3QgZG9lcyBub3Qgc3VwcG9ydCBpdGVtIGFzc2lnbm1lbnRcIik7XG5cdH07XG5cblx0U2suYWJzdHIuc2VxdWVuY2VEZWxJdGVtID0gZnVuY3Rpb24gKHNlcSwgaSkge1xuXHQgICAgdmFyIHNlcXR5cGVuYW1lO1xuXHQgICAgaWYgKHNlcS5zcSRkZWxfaXRlbSkge1xuXHQgICAgICAgIGkgPSBTay5hYnN0ci5maXhTZXFJbmRleF8oc2VxLCBpKTtcblx0ICAgICAgICBzZXEuc3EkZGVsX2l0ZW0oaSk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBzZXF0eXBlbmFtZSA9IFNrLmFic3RyLnR5cGVOYW1lKHNlcSk7XG5cdCAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIgKyBzZXF0eXBlbmFtZSArIFwiJyBvYmplY3QgZG9lcyBub3Qgc3VwcG9ydCBpdGVtIGRlbGV0aW9uXCIpO1xuXHR9O1xuXG5cdFNrLmFic3RyLnNlcXVlbmNlUmVwZWF0ID0gZnVuY3Rpb24gKGYsIHNlcSwgbikge1xuXHQgICAgdmFyIG50eXBlbmFtZTtcblx0ICAgIHZhciBjb3VudDtcblx0ICAgIG4gPSBTay5idWlsdGluLmFzbnVtJChuKTtcblx0ICAgIGNvdW50ID0gU2subWlzY2V2YWwuYXNJbmRleChuKTtcblx0ICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgbnR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUobik7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgbXVsdGlwbHkgc2VxdWVuY2UgYnkgbm9uLWludCBvZiB0eXBlICdcIiArIG50eXBlbmFtZSArIFwiJ1wiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmLmNhbGwoc2VxLCBuKTtcblx0fTtcblxuXHRTay5hYnN0ci5zZXF1ZW5jZUdldFNsaWNlID0gZnVuY3Rpb24gKHNlcSwgaTEsIGkyKSB7XG5cdCAgICB2YXIgc2VxdHlwZW5hbWU7XG5cdCAgICBpZiAoc2VxLnNxJHNsaWNlKSB7XG5cdCAgICAgICAgaTEgPSBTay5hYnN0ci5maXhTZXFJbmRleF8oc2VxLCBpMSk7XG5cdCAgICAgICAgaTIgPSBTay5hYnN0ci5maXhTZXFJbmRleF8oc2VxLCBpMik7XG5cdCAgICAgICAgcmV0dXJuIHNlcS5zcSRzbGljZShpMSwgaTIpO1xuXHQgICAgfSBlbHNlIGlmIChzZXEubXAkc3Vic2NyaXB0KSB7XG5cdCAgICAgICAgcmV0dXJuIHNlcS5tcCRzdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uc2xpY2UoaTEsIGkyKSk7XG5cdCAgICB9XG5cblx0ICAgIHNlcXR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUoc2VxKTtcblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIiArIHNlcXR5cGVuYW1lICsgXCInIG9iamVjdCBpcyB1bnNsaWNlYWJsZVwiKTtcblx0fTtcblxuXHRTay5hYnN0ci5zZXF1ZW5jZURlbFNsaWNlID0gZnVuY3Rpb24gKHNlcSwgaTEsIGkyKSB7XG5cdCAgICB2YXIgc2VxdHlwZW5hbWU7XG5cdCAgICBpZiAoc2VxLnNxJGRlbF9zbGljZSkge1xuXHQgICAgICAgIGkxID0gU2suYWJzdHIuZml4U2VxSW5kZXhfKHNlcSwgaTEpO1xuXHQgICAgICAgIGkyID0gU2suYWJzdHIuZml4U2VxSW5kZXhfKHNlcSwgaTIpO1xuXHQgICAgICAgIHNlcS5zcSRkZWxfc2xpY2UoaTEsIGkyKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHNlcXR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUoc2VxKTtcblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIiArIHNlcXR5cGVuYW1lICsgXCInIGRvZXNuJ3Qgc3VwcG9ydCBzbGljZSBkZWxldGlvblwiKTtcblx0fTtcblxuXHRTay5hYnN0ci5zZXF1ZW5jZVNldFNsaWNlID0gZnVuY3Rpb24gKHNlcSwgaTEsIGkyLCB4KSB7XG5cdCAgICB2YXIgc2VxdHlwZW5hbWU7XG5cdCAgICBpZiAoc2VxLnNxJGFzc19zbGljZSkge1xuXHQgICAgICAgIGkxID0gU2suYWJzdHIuZml4U2VxSW5kZXhfKHNlcSwgaTEpO1xuXHQgICAgICAgIGkyID0gU2suYWJzdHIuZml4U2VxSW5kZXhfKHNlcSwgaTIpO1xuXHQgICAgICAgIHNlcS5zcSRhc3Nfc2xpY2UoaTEsIGkyLCB4KTtcblx0ICAgIH0gZWxzZSBpZiAoc2VxLm1wJGFzc19zdWJzY3JpcHQpIHtcblx0ICAgICAgICBzZXEubXAkYXNzX3N1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5zbGljZShpMSwgaTIpLCB4KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgc2VxdHlwZW5hbWUgPSBTay5hYnN0ci50eXBlTmFtZShzZXEpO1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIiArIHNlcXR5cGVuYW1lICsgXCInIG9iamVjdCBkb2Vzbid0IHN1cHBvcnQgc2xpY2UgYXNzaWdubWVudFwiKTtcblx0ICAgIH1cblx0fTtcblxuXHQvLyBzZXEgLSBQeXRob24gb2JqZWN0IHRvIHVucGFja1xuXHQvLyBuICAgLSBKYXZhU2NyaXB0IG51bWJlciBvZiBpdGVtcyB0byB1bnBhY2tcblx0U2suYWJzdHIuc2VxdWVuY2VVbnBhY2sgPSBmdW5jdGlvbiAoc2VxLCBuKSB7XG5cdCAgICB2YXIgcmVzID0gW107XG5cdCAgICB2YXIgaXQsIGk7XG5cblx0ICAgIGlmICghU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKHNlcSkpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIgKyBTay5hYnN0ci50eXBlTmFtZShzZXEpICsgXCInIG9iamVjdCBpcyBub3QgaXRlcmFibGVcIik7XG5cdCAgICB9XG5cblx0ICAgIGZvciAoaXQgPSBTay5hYnN0ci5pdGVyKHNlcSksIGkgPSBpdC50cCRpdGVybmV4dCgpO1xuXHQgICAgICAgICAoaSAhPT0gdW5kZWZpbmVkKSAmJiAocmVzLmxlbmd0aCA8IG4pO1xuXHQgICAgICAgICBpID0gaXQudHAkaXRlcm5leHQoKSkge1xuXHQgICAgICAgIHJlcy5wdXNoKGkpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocmVzLmxlbmd0aCA8IG4pIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibmVlZCBtb3JlIHRoYW4gXCIgKyByZXMubGVuZ3RoICsgXCIgdmFsdWVzIHRvIHVucGFja1wiKTtcblx0ICAgIH1cblx0ICAgIGlmIChpICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwidG9vIG1hbnkgdmFsdWVzIHRvIHVucGFja1wiKTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIEphdmFzY3JpcHQgYXJyYXkgb2YgaXRlbXNcblx0ICAgIHJldHVybiByZXM7XG5cdH07XG5cblx0Ly9cblx0Ly8gT2JqZWN0XG5cdC8vXG5cblx0U2suYWJzdHIub2JqZWN0Rm9ybWF0ID0gZnVuY3Rpb24gKG9iaiwgZm9ybWF0X3NwZWMpIHtcblx0ICAgIHZhciBtZXRoOyAvLyBQeU9iamVjdFxuXHQgICAgdmFyIHJlc3VsdDsgLy8gUHlPYmplY3RcblxuXHQgICAgLy8gSWYgbm8gZm9ybWF0X3NwZWMgaXMgcHJvdmlkZWQsIHVzZSBhbiBlbXB0eSBzdHJpbmdcblx0ICAgIGlmKGZvcm1hdF9zcGVjID09IG51bGwpIHtcblx0ICAgICAgICBmb3JtYXRfc3BlYyA9IFwiXCI7XG5cdCAgICB9XG5cblx0ICAgIC8vIEZpbmQgdGhlICh1bmJvdW5kISkgX19mb3JtYXRfXyBtZXRob2QgKGEgYm9ycm93ZWQgcmVmZXJlbmNlKVxuXHQgICAgbWV0aCA9IFNrLmFic3RyLmxvb2t1cFNwZWNpYWwob2JqLCBcIl9fZm9ybWF0X19cIik7XG5cdCAgICBpZiAobWV0aCA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiVHlwZSBcIiArIFNrLmFic3RyLnR5cGVOYW1lKG9iaikgKyBcImRvZXNuJ3QgZGVmaW5lIF9fZm9ybWF0X19cIik7XG5cdCAgICB9XG5cblx0ICAgIC8vIEFuZCBjYWxsIGl0XG5cdCAgICByZXN1bHQgPSBTay5taXNjZXZhbC5jYWxsc2ltKG1ldGgsIG9iaiwgZm9ybWF0X3NwZWMpO1xuXHQgICAgaWYgKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHJlc3VsdCkpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2Zvcm1hdF9fIG11c3QgcmV0dXJuIGEgc3RyLCBub3QgXCIgKyBTay5hYnN0ci50eXBlTmFtZShyZXN1bHQpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRTay5hYnN0ci5vYmplY3RBZGQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgdmFyIGJ0eXBlbmFtZTtcblx0ICAgIHZhciBhdHlwZW5hbWU7XG5cdCAgICBpZiAoYS5uYiRhZGQpIHtcblx0ICAgICAgICByZXR1cm4gYS5uYiRhZGQoYik7XG5cdCAgICB9XG5cblx0ICAgIGF0eXBlbmFtZSA9IFNrLmFic3RyLnR5cGVOYW1lKGEpO1xuXHQgICAgYnR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUoYik7XG5cdCAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ1bnN1cHBvcnRlZCBvcGVyYW5kIHR5cGUocykgZm9yICs6ICdcIiArIGF0eXBlbmFtZSArIFwiJyBhbmQgJ1wiICsgYnR5cGVuYW1lICsgXCInXCIpO1xuXHR9O1xuXG5cdC8vIGluIFB5dGhvbiAyLjYsIHRoaXMgYmVoYXZpb3VyIHNlZW1zIHRvIGJlIGRlZmluZWQgZm9yIG51bWJlcnMgYW5kIGJvb2xzIChjb252ZXJ0cyBib29sIHRvIGludClcblx0U2suYWJzdHIub2JqZWN0TmVnYXRpdmUgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB2YXIgb2JqdHlwZW5hbWU7XG5cdCAgICB2YXIgb2JqX2FzbnVtID0gU2suYnVpbHRpbi5hc251bSQob2JqKTsgLy8gdGhpcyB3aWxsIGFsc28gY29udmVydCBib29sIHR5cGUgdG8gaW50XG5cblx0ICAgIGlmIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmJvb2wpIHtcblx0ICAgICAgICBvYmogPSBuZXcgU2suYnVpbHRpbi5pbnRfKG9ial9hc251bSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChvYmoubmIkbmVnYXRpdmUpIHtcblx0ICAgICAgICByZXR1cm4gb2JqLm5iJG5lZ2F0aXZlKCk7XG5cdCAgICB9XG5cblx0ICAgIG9ianR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUob2JqKTtcblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImJhZCBvcGVyYW5kIHR5cGUgZm9yIHVuYXJ5IC06ICdcIiArIG9ianR5cGVuYW1lICsgXCInXCIpO1xuXHR9O1xuXG5cdC8vIGluIFB5dGhvbiAyLjYsIHRoaXMgYmVoYXZpb3VyIHNlZW1zIHRvIGJlIGRlZmluZWQgZm9yIG51bWJlcnMgYW5kIGJvb2xzIChjb252ZXJ0cyBib29sIHRvIGludClcblx0U2suYWJzdHIub2JqZWN0UG9zaXRpdmUgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB2YXIgb2JqdHlwZW5hbWUgPSBTay5hYnN0ci50eXBlTmFtZShvYmopO1xuXHQgICAgdmFyIG9ial9hc251bSA9IFNrLmJ1aWx0aW4uYXNudW0kKG9iaik7IC8vIHRoaXMgd2lsbCBhbHNvIGNvbnZlcnQgYm9vbCB0eXBlIHRvIGludFxuXG5cdCAgICBpZiAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ib29sKSB7XG5cdCAgICAgICAgb2JqID0gbmV3IFNrLmJ1aWx0aW4uaW50XyhvYmpfYXNudW0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob2JqLm5iJG5lZ2F0aXZlKSB7XG5cdCAgICAgICAgcmV0dXJuIG9iai5uYiRwb3NpdGl2ZSgpO1xuXHQgICAgfVxuXG5cdCAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJiYWQgb3BlcmFuZCB0eXBlIGZvciB1bmFyeSArOiAnXCIgKyBvYmp0eXBlbmFtZSArIFwiJ1wiKTtcblx0fTtcblxuXHRTay5hYnN0ci5vYmplY3REZWxJdGVtID0gZnVuY3Rpb24gKG8sIGtleSkge1xuXHQgICAgdmFyIG90eXBlbmFtZTtcblx0ICAgIHZhciBrZXl0eXBlbmFtZTtcblx0ICAgIHZhciBrZXlWYWx1ZTtcblx0ICAgIGlmIChvICE9PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKG8ubXAkZGVsX3N1YnNjcmlwdCkge1xuXHQgICAgICAgICAgICBvLm1wJGRlbF9zdWJzY3JpcHQoa2V5KTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoby5zcSRhc3NfaXRlbSkge1xuXHQgICAgICAgICAgICBrZXlWYWx1ZSA9IFNrLm1pc2NldmFsLmFzSW5kZXgoa2V5KTtcblx0ICAgICAgICAgICAgaWYgKGtleVZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIGtleXR5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUoa2V5KTtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNlcXVlbmNlIGluZGV4IG11c3QgYmUgaW50ZWdlciwgbm90ICdcIiArIGtleXR5cGVuYW1lICsgXCInXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIFNrLmFic3RyLnNlcXVlbmNlRGVsSXRlbShvLCBrZXlWYWx1ZSk7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gaWYgbyBpcyBhIHNsaWNlIGRvIHNvbWV0aGluZyBlbHNlLi4uXG5cdCAgICB9XG5cblx0ICAgIG90eXBlbmFtZSA9IFNrLmFic3RyLnR5cGVOYW1lKG8pO1xuXHQgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiICsgb3R5cGVuYW1lICsgXCInIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IGl0ZW0gZGVsZXRpb25cIik7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIub2JqZWN0RGVsSXRlbVwiLCBTay5hYnN0ci5vYmplY3REZWxJdGVtKTtcblxuXHRTay5hYnN0ci5vYmplY3RHZXRJdGVtID0gZnVuY3Rpb24gKG8sIGtleSwgY2FuU3VzcGVuZCkge1xuXHQgICAgdmFyIG90eXBlbmFtZTtcblx0ICAgIGlmIChvICE9PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKG8udHAkZ2V0aXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gby50cCRnZXRpdGVtKGtleSwgY2FuU3VzcGVuZCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChvLm1wJHN1YnNjcmlwdCkge1xuXHQgICAgICAgICAgICByZXR1cm4gby5tcCRzdWJzY3JpcHQoa2V5LCBjYW5TdXNwZW5kKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFNrLm1pc2NldmFsLmlzSW5kZXgoa2V5KSAmJiBvLnNxJGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFNrLmFic3RyLnNlcXVlbmNlR2V0SXRlbShvLCBTay5taXNjZXZhbC5hc0luZGV4KGtleSksIGNhblN1c3BlbmQpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgb3R5cGVuYW1lID0gU2suYWJzdHIudHlwZU5hbWUobyk7XG5cdCAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIgKyBvdHlwZW5hbWUgKyBcIicgZG9lcyBub3Qgc3VwcG9ydCBpbmRleGluZ1wiKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5vYmplY3RHZXRJdGVtXCIsIFNrLmFic3RyLm9iamVjdEdldEl0ZW0pO1xuXG5cdFNrLmFic3RyLm9iamVjdFNldEl0ZW0gPSBmdW5jdGlvbiAobywga2V5LCB2LCBjYW5TdXNwZW5kKSB7XG5cdCAgICB2YXIgb3R5cGVuYW1lO1xuXHQgICAgaWYgKG8gIT09IG51bGwpIHtcblx0ICAgICAgICBpZiAoby50cCRzZXRpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBvLnRwJHNldGl0ZW0oa2V5LCB2LCBjYW5TdXNwZW5kKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG8ubXAkYXNzX3N1YnNjcmlwdCkge1xuXHQgICAgICAgICAgICByZXR1cm4gby5tcCRhc3Nfc3Vic2NyaXB0KGtleSwgdiwgY2FuU3VzcGVuZCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChTay5taXNjZXZhbC5pc0luZGV4KGtleSkgJiYgby5zcSRhc3NfaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gU2suYWJzdHIuc2VxdWVuY2VTZXRJdGVtKG8sIFNrLm1pc2NldmFsLmFzSW5kZXgoa2V5KSwgdiwgY2FuU3VzcGVuZCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBvdHlwZW5hbWUgPSBTay5hYnN0ci50eXBlTmFtZShvKTtcblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIiArIG90eXBlbmFtZSArIFwiJyBkb2VzIG5vdCBzdXBwb3J0IGl0ZW0gYXNzaWdubWVudFwiKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5vYmplY3RTZXRJdGVtXCIsIFNrLmFic3RyLm9iamVjdFNldEl0ZW0pO1xuXG5cblx0U2suYWJzdHIuZ2F0dHIgPSBmdW5jdGlvbiAob2JqLCBuYW1lSlMsIGNhblN1c3BlbmQpIHtcblx0ICAgIHZhciByZXQsIGY7XG5cdCAgICB2YXIgb2JqbmFtZSA9IFNrLmFic3RyLnR5cGVOYW1lKG9iaik7XG5cblx0ICAgIGlmIChvYmogPT09IG51bGwpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcIidcIiArIG9iam5hbWUgKyBcIicgb2JqZWN0IGhhcyBubyBhdHRyaWJ1dGUgJ1wiICsgbmFtZUpTICsgXCInXCIpO1xuXHQgICAgfVxuXG5cblx0ICAgIGlmIChvYmoudHAkZ2V0YXR0ciAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgZiA9IG9iai50cCRnZXRhdHRyKFwiX19nZXRhdHRyaWJ1dGVfX1wiKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGYgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldCA9IFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQoZiwgbmV3IFNrLmJ1aWx0aW4uc3RyKG5hbWVKUykpO1xuXHQgICAgfVxuXG5cdCAgICByZXQgPSBTay5taXNjZXZhbC5jaGFpbihyZXQsIGZ1bmN0aW9uKHJldCkge1xuXHQgICAgICAgIHZhciBmO1xuXG5cdCAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkICYmIG9iai50cCRnZXRhdHRyICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmV0ID0gb2JqLnRwJGdldGF0dHIobmFtZUpTKTtcblxuXHQgICAgICAgICAgICBpZiAocmV0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIGYgPSBvYmoudHAkZ2V0YXR0cihcIl9fZ2V0YXR0cl9fXCIpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoZiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZChmLCBuZXcgU2suYnVpbHRpbi5zdHIobmFtZUpTKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgIH0sIGZ1bmN0aW9uKHIpIHtcblx0ICAgICAgICBpZiAociA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiJ1wiICsgb2JqbmFtZSArIFwiJyBvYmplY3QgaGFzIG5vIGF0dHJpYnV0ZSAnXCIgKyBuYW1lSlMgKyBcIidcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByO1xuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBjYW5TdXNwZW5kID8gcmV0IDogU2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHJldCk7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuZ2F0dHJcIiwgU2suYWJzdHIuZ2F0dHIpO1xuXG5cdFNrLmFic3RyLnNhdHRyID0gZnVuY3Rpb24gKG9iaiwgbmFtZUpTLCBkYXRhLCBjYW5TdXNwZW5kKSB7XG5cdCAgICB2YXIgb2JqbmFtZSA9IFNrLmFic3RyLnR5cGVOYW1lKG9iaiksIHIsIHNldGY7XG5cblx0ICAgIGlmIChvYmogPT09IG51bGwpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcIidcIiArIG9iam5hbWUgKyBcIicgb2JqZWN0IGhhcyBubyBhdHRyaWJ1dGUgJ1wiICsgbmFtZUpTICsgXCInXCIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob2JqLnRwJGdldGF0dHIgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHNldGYgPSBvYmoudHAkZ2V0YXR0cihcIl9fc2V0YXR0cl9fXCIpO1xuXHQgICAgICAgIGlmIChzZXRmICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgciA9IFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQoc2V0ZiwgbmV3IFNrLmJ1aWx0aW4uc3RyKG5hbWVKUyksIGRhdGEpO1xuXHQgICAgICAgICAgICByZXR1cm4gY2FuU3VzcGVuZCA/IHIgOiBTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3cocik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAob2JqLnRwJHNldGF0dHIgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIG9iai50cCRzZXRhdHRyKG5hbWVKUywgZGF0YSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiJ1wiICsgb2JqbmFtZSArIFwiJyBvYmplY3QgaGFzIG5vIGF0dHJpYnV0ZSAnXCIgKyBuYW1lSlMgKyBcIidcIik7XG5cdCAgICB9XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuc2F0dHJcIiwgU2suYWJzdHIuc2F0dHIpO1xuXG5cblx0U2suYWJzdHIuaXRlcm5leHQgPSBmdW5jdGlvbiAoaXQsIGNhblN1c3BlbmQpIHtcblx0ICAgIHJldHVybiBpdC50cCRpdGVybmV4dChjYW5TdXNwZW5kKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5pdGVybmV4dFwiLCBTay5hYnN0ci5pdGVybmV4dCk7XG5cblxuXHQvKipcblx0ICogR2V0IHRoZSBpdGVyYXRvciBmb3IgYSBQeXRob24gb2JqZWN0ICBUaGlzIGl0ZXJhdG9yIGNvdWxkIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nLlxuXHQgKiBUaGlzIGlzIHRoZSBwcmVmZXJyZWQgbWVjaGFuaXNtIGZvciBjb25zaXN0ZW50bHkgZ2V0dGluZyB0aGUgY29ycmVjdCBpdGVyYXRvci4gIFlvdSBzaG91bGRcblx0ICogbm90IGp1c3QgdXNlIHRwJGl0ZXIgYmVjYXVzZSB0aGF0IGNvdWxkIGxlYWQgdG8gaW5jb3JyZWN0IGJlaGF2aW9yIG9mIGEgdXNlciBjcmVhdGVkIGNsYXNzLlxuXHQgKlxuXHQgKiAtIHRwJGl0ZXJcblx0ICogLSBBIHVzZXIgZGVmaW5lZCBgX19pdGVyX19gIG1ldGhvZFxuXHQgKiAtIEEgdXNlciBkZWZpbmVkIGBfX2dldGl0ZW1fX2AgbWV0aG9kXG5cdCAqXG5cdCAqIEBwYXJhbSBvYmpcblx0ICpcblx0ICogQHRocm93cyB7U2suYnVpbHRpbi5UeXBlRXJyb3J9XG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqL1xuXG5cdFNrLmFic3RyLml0ZXIgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHZhciBpdGVyO1xuXHQgICAgdmFyIGdldGl0O1xuXHQgICAgdmFyIHJldDtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCdWlsZHMgYW4gaXRlcmF0b3IgYXJvdW5kIGNsYXNzZXMgdGhhdCBoYXZlIGEgX19nZXRpdGVtX18gbWV0aG9kLlxuXHQgICAgICpcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICovXG5cdCAgICB2YXIgc2VxSXRlciA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICB0aGlzLmlkeCA9IDA7XG5cdCAgICAgICAgdGhpcy5teW9iaiA9IG9iajtcblx0ICAgICAgICB0aGlzLmdldGl0ZW0gPSBTay5hYnN0ci5sb29rdXBTcGVjaWFsKG9iaiwgXCJfX2dldGl0ZW1fX1wiKTtcblx0ICAgICAgICB0aGlzLnRwJGl0ZXJuZXh0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmV0O1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbSh0aGlzLmdldGl0ZW0sIHRoaXMubXlvYmosIFNrLmZmaS5yZW1hcFRvUHkodGhpcy5pZHgpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTay5idWlsdGluLkluZGV4RXJyb3IgfHwgZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5pZHgrKztcblx0ICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblxuXHQgICAgaWYgKG9iai50cCRnZXRhdHRyKSB7XG5cdCAgICAgICAgaXRlciA9ICBTay5hYnN0ci5sb29rdXBTcGVjaWFsKG9iaixcIl9faXRlcl9fXCIpO1xuXHQgICAgICAgIGlmIChpdGVyKSB7XG5cdCAgICAgICAgICAgIHJldCA9IFNrLm1pc2NldmFsLmNhbGxzaW0oaXRlciwgb2JqKTtcblx0ICAgICAgICAgICAgaWYgKHJldC50cCRpdGVybmV4dCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChvYmoudHAkaXRlcikge1xuXHQgICAgICAgIHRyeSB7ICAvLyBjYXRjaCBhbmQgaWdub3JlIG5vdCBpdGVyYWJsZSBlcnJvciBoZXJlLlxuXHQgICAgICAgICAgICByZXQgPSBvYmoudHAkaXRlcigpO1xuXHQgICAgICAgICAgICBpZiAocmV0LnRwJGl0ZXJuZXh0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG5cdCAgICB9XG5cdCAgICBnZXRpdCA9IFNrLmFic3RyLmxvb2t1cFNwZWNpYWwob2JqLCBcIl9fZ2V0aXRlbV9fXCIpO1xuXHQgICAgaWYgKGdldGl0KSB7XG5cdCAgICAgICAgLy8gY3JlYXRlIGludGVybmFsIGl0ZXJvYmplY3QgaWYgX19nZXRpdGVtX19cblx0ICAgICAgICByZXR1cm4gbmV3IHNlcUl0ZXIob2JqKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIiArIFNrLmFic3RyLnR5cGVOYW1lKG9iaikgKyBcIicgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5pdGVyXCIsIFNrLmFic3RyLml0ZXIpO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWFsIG1ldGhvZCBsb29rIHVwLiBGaXJzdCB0cnkgZ2V0dGluZyB0aGUgbWV0aG9kIHZpYVxuXHQgKiBpbnRlcm5hbCBkaWN0IGFuZCBnZXRhdHRyLiBJZiBnZXRhdHRyIGlzIG5vdCBwcmVzZW50IChidWlsdGlucylcblx0ICogdHJ5IGlmIG1ldGhvZCBpcyBkZWZpbmVkIG9uIHRoZSBvYmplY3QgaXRzZWxmXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJuIG51bGwgaWYgbm90IGZvdW5kIG9yIHRoZSBmdW5jdGlvblxuXHQgKi9cblx0U2suYWJzdHIubG9va3VwU3BlY2lhbCA9IGZ1bmN0aW9uKG9wLCBzdHIpIHtcblx0ICAgIHZhciByZXM7XG5cdCAgICB2YXIgb2J0cDtcblx0ICAgIGlmIChvcC5vYiR0eXBlKSB7XG5cdCAgICAgICAgb2J0cCA9IG9wLm9iJHR5cGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gU2suYnVpbHRpbi50eXBlLnR5cGVMb29rdXAob2J0cCwgc3RyKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5sb29rdXBTcGVjaWFsXCIsIFNrLmFic3RyLmxvb2t1cFNwZWNpYWwpO1xuXG5cdC8qKlxuXHQgKiBNYXJrIGEgY2xhc3MgYXMgdW5oYXNoYWJsZSBhbmQgcHJldmVudCBpdHMgYF9faGFzaF9fYCBmdW5jdGlvbiBmcm9tIGJlaW5nIGNhbGxlZC5cblx0ICogQHBhcmFtICB7ZnVuY3Rpb24oLi4uWz9dKX0gdGhpc0NsYXNzIFRoZSBjbGFzcyB0byBtYXJrIGFzIHVuaGFzaGFibGUuXG5cdCAqIEByZXR1cm4ge3VuZGVmaW5lZH1cblx0ICovXG5cdFNrLmFic3RyLm1hcmtVbmhhc2hhYmxlID0gZnVuY3Rpb24gKHRoaXNDbGFzcykge1xuXHQgICAgdmFyIHByb3RvID0gdGhpc0NsYXNzLnByb3RvdHlwZTtcblx0ICAgIHByb3RvLl9faGFzaF9fID0gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuXHQgICAgcHJvdG8udHAkaGFzaCA9IFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHVwIGluaGVyaXRhbmNlIGJldHdlZW4gdHdvIFB5dGhvbiBjbGFzc2VzLiBUaGlzIGFsbG93cyBvbmx5IGZvciBzaW5nbGVcblx0ICogaW5oZXJpdGFuY2UgLS0gbXVsdGlwbGUgaW5oZXJpdGFuY2UgaXMgbm90IHN1cHBvcnRlZCBieSBKYXZhc2NyaXB0LlxuXHQgKlxuXHQgKiBKYXZhc2NyaXB0J3MgaW5oZXJpdGFuY2UgaXMgcHJvdG90eXBhbC4gVGhpcyBtZWFucyB0aGF0IHByb3BlcnRpZXMgbXVzdFxuXHQgKiBiZSBkZWZpbmVkIG9uIHRoZSBzdXBlcmNsYXNzJyBwcm90b3R5cGUgaW4gb3JkZXIgZm9yIHN1YmNsYXNzZXMgdG8gaW5oZXJpdFxuXHQgKiB0aGVtLlxuXHQgKlxuXHQgKiBgYGBcblx0ICogU2suc3VwZXJjbGFzcy5teVByb3BlcnR5ICAgICAgICAgICAgICAgICAjIHdpbGwgTk9UIGJlIGluaGVyaXRlZFxuXHQgKiBTay5zdXBlcmNsYXNzLnByb3RvdHlwZS5teVByb3BlcnR5ICAgICAgICMgd2lsbCBiZSBpbmhlcml0ZWRcblx0ICogYGBgXG5cdCAqXG5cdCAqIEluIG9yZGVyIGZvciBhIGNsYXNzIHRvIGJlIHN1YmNsYXNzYWJsZSwgaXQgbXVzdCAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSlcblx0ICogaW5oZXJpdCBmcm9tIFNrLmJ1aWx0aW4ub2JqZWN0IHNvIHRoYXQgaXQgd2lsbCBiZSBwcm9wZXJseSBpbml0aWFsaXplZCBpblxuXHQgKiB7QGxpbmsgU2suZG9PbmVUaW1lSW5pdGlhbGl6YXRpb259IChpbiBzcmMvaW1wb3J0LmpzKS4gRnVydGhlciwgYWxsIFB5dGhvblxuXHQgKiBidWlsdGlucyBzaG91bGQgaW5oZXJpdCBmcm9tIFNrLmJ1aWx0aW4ub2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGROYW1lIFRoZSBQeXRob24gbmFtZSBvZiB0aGUgY2hpbGQgKHN1YmNsYXNzKS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbiguLi5bP10pfSBjaGlsZCAgICAgVGhlIHN1YmNsYXNzLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLls/XSl9IHBhcmVudCAgICBUaGUgc3VwZXJjbGFzcy5cblx0ICogQHJldHVybiB7dW5kZWZpbmVkfVxuXHQgKi9cblx0U2suYWJzdHIuc2V0VXBJbmhlcml0YW5jZSA9IGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkLCBwYXJlbnQpIHtcblx0ICAgIGdvb2cuaW5oZXJpdHMoY2hpbGQsIHBhcmVudCk7XG5cdCAgICBjaGlsZC5wcm90b3R5cGUudHAkYmFzZSA9IHBhcmVudDtcblx0ICAgIGNoaWxkLnByb3RvdHlwZS50cCRuYW1lID0gY2hpbGROYW1lO1xuXHQgICAgY2hpbGQucHJvdG90eXBlLm9iJHR5cGUgPSBTay5idWlsdGluLnR5cGUubWFrZUludG9UeXBlT2JqKGNoaWxkTmFtZSwgY2hpbGQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsIHRoZSBzdXBlciBjb25zdHJ1Y3RvciBvZiB0aGUgcHJvdmlkZWQgY2xhc3MsIHdpdGggdGhlIG9iamVjdCBgc2VsZmAgYXNcblx0ICogdGhlIGB0aGlzYCB2YWx1ZSBvZiB0aGF0IGNvbnN0cnVjdG9yLiBBbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uXG5cdCAqIGFmdGVyIGBzZWxmYCB3aWxsIGJlIHBhc3NlZCBhcy1pcyB0byB0aGUgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSAge2Z1bmN0aW9uKC4uLls/XSl9IHRoaXNDbGFzcyBUaGUgc3ViY2xhc3MuXG5cdCAqIEBwYXJhbSAge09iamVjdH0gc2VsZiAgICAgIFRoZSBpbnN0YW5jZSBvZiB0aGUgc3ViY2xhcy5cblx0ICogQHBhcmFtICB7Li4uP30gYXJncyBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG5cdCAqIEByZXR1cm4ge3VuZGVmaW5lZH1cblx0ICovXG5cdFNrLmFic3RyLnN1cGVyQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAodGhpc0NsYXNzLCBzZWxmLCBhcmdzKSB7XG5cdCAgICB2YXIgYXJndW1lbnRzRm9yQ29uc3RydWN0b3IgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHQgICAgdGhpc0NsYXNzLnByb3RvdHlwZS50cCRiYXNlLmFwcGx5KHNlbGYsIGFyZ3VtZW50c0ZvckNvbnN0cnVjdG9yKTtcblx0fTtcblxuXG5cblx0LyogLS0tLSAvVXNlcnMvcm9iL3NrdWxwdHkvbGliLy4uL25vZGVfbW9kdWxlcy9za3VscHQvc3JjL29iamVjdC5qcyAtLS0tICovIFxuXG5cdC8qKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogU2suYnVpbHRpbi5vYmplY3Rcblx0ICpcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIENvbnN0cnVjdG9yIGZvciBQeXRob24gb2JqZWN0LiBBbGwgUHl0aG9uIGNsYXNzZXMgKGJ1aWx0aW4gYW5kIHVzZXItZGVmaW5lZClcblx0ICogc2hvdWxkIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTay5idWlsdGluLm9iamVjdH0gUHl0aG9uIG9iamVjdFxuXHQgKi9cblx0U2suYnVpbHRpbi5vYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5vYmplY3QpKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLm9iamVjdCgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0fTtcblxuXG5cblx0dmFyIF90cnlHZXRTdWJzY3JpcHQgPSBmdW5jdGlvbihkaWN0LCBweU5hbWUpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIGRpY3QubXAkc3Vic2NyaXB0KHB5TmFtZSk7XG5cdCAgICB9IGNhdGNoICh4KSB7XG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogQHJldHVybiB7dW5kZWZpbmVkfVxuXHQgKi9cblx0U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkdlbmVyaWNHZXRBdHRyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIHZhciByZXM7XG5cdCAgICB2YXIgZjtcblx0ICAgIHZhciBkZXNjcjtcblx0ICAgIHZhciB0cDtcblx0ICAgIHZhciBkaWN0O1xuXHQgICAgdmFyIHB5TmFtZSA9IG5ldyBTay5idWlsdGluLnN0cihuYW1lKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpO1xuXG5cdCAgICB0cCA9IHRoaXMub2IkdHlwZTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQodHAgIT09IHVuZGVmaW5lZCwgXCJvYmplY3QgaGFzIG5vIG9iJHR5cGUhXCIpO1xuXG5cdCAgICBkaWN0ID0gdGhpc1tcIiRkXCJdIHx8IHRoaXMuY29uc3RydWN0b3JbXCIkZFwiXTtcblxuXHQgICAgLy8gdG9kbzsgYXNzZXJ0PyBmb3JjZT9cblx0ICAgIGlmIChkaWN0KSB7XG5cdCAgICAgICAgaWYgKGRpY3QubXAkbG9va3VwKSB7XG5cdCAgICAgICAgICAgIHJlcyA9IGRpY3QubXAkbG9va3VwKHB5TmFtZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChkaWN0Lm1wJHN1YnNjcmlwdCkge1xuXHQgICAgICAgICAgICByZXMgPSBfdHJ5R2V0U3Vic2NyaXB0KGRpY3QsIHB5TmFtZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGljdCA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICAvLyB0b2RvOyBkZWZpbml0ZWx5IHRoZSB3cm9uZyBwbGFjZSBmb3IgdGhpcy4gb3RoZXIgY3VzdG9tIHRwJGdldGF0dHIgd29uJ3Qgd29yayBvbiBvYmplY3QgLS0gYm5tIC0tIGltcGxlbWVudGVkIGN1c3RvbSBfX2dldGF0dHJfXyBpbiBhYnN0cmFjdC5qc1xuXHQgICAgICAgICAgICByZXMgPSBkaWN0W25hbWVdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGRlc2NyID0gU2suYnVpbHRpbi50eXBlLnR5cGVMb29rdXAodHAsIG5hbWUpO1xuXG5cdCAgICAvLyBvdGhlcndpc2UsIGxvb2sgaW4gdGhlIHR5cGUgZm9yIGEgZGVzY3Jcblx0ICAgIGlmIChkZXNjciAhPT0gdW5kZWZpbmVkICYmIGRlc2NyICE9PSBudWxsICYmIGRlc2NyLm9iJHR5cGUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGYgPSBkZXNjci5vYiR0eXBlLnRwJGRlc2NyX2dldDtcblx0ICAgICAgICBpZiAoIShmKSAmJiBkZXNjcltcIl9fZ2V0X19cIl0pIHtcblx0ICAgICAgICAgICAgZiA9IGRlc2NyW1wiX19nZXRfX1wiXTtcblx0ICAgICAgICAgICAgcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQoZiwgZGVzY3IsIHRoaXMsIFNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIHRvZG87XG5cdCAgICAgICAgLy8gaWYgKGYgJiYgZGVzY3IudHAkZGVzY3Jfc2V0KSAvLyBpcyBhIGRhdGEgZGVzY3JpcHRvciBpZiBpdCBoYXMgYSBzZXRcblx0ICAgICAgICAvLyByZXR1cm4gZi5jYWxsKGRlc2NyLCB0aGlzLCB0aGlzLm9iJHR5cGUpO1xuXG5cdCAgICAgICAgaWYgKGYpIHtcblx0ICAgICAgICAgICAgLy8gbm9uLWRhdGEgZGVzY3JpcHRvclxuXHQgICAgICAgICAgICByZXR1cm4gZi5jYWxsKGRlc2NyLCB0aGlzLCB0aGlzLm9iJHR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKGRlc2NyICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gZGVzY3I7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkdlbmVyaWNHZXRBdHRyXCIsIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5HZW5lcmljR2V0QXR0cik7XG5cblx0U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkdlbmVyaWNQeXRob25HZXRBdHRyID0gZnVuY3Rpb24oc2VsZiwgbmFtZSkge1xuXHQgICAgcmV0dXJuIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5HZW5lcmljR2V0QXR0ci5jYWxsKHNlbGYsIG5hbWUudik7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkdlbmVyaWNQeXRob25HZXRBdHRyXCIsIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5HZW5lcmljUHl0aG9uR2V0QXR0cik7XG5cblx0U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkdlbmVyaWNTZXRBdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdCAgICB2YXIgb2JqbmFtZSA9IFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpO1xuXHQgICAgdmFyIHB5bmFtZTtcblx0ICAgIHZhciBkaWN0O1xuXHQgICAgdmFyIHRwID0gdGhpcy5vYiR0eXBlO1xuXHQgICAgdmFyIGRlc2NyO1xuXHQgICAgdmFyIGY7XG5cblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpO1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh0cCAhPT0gdW5kZWZpbmVkLCBcIm9iamVjdCBoYXMgbm8gb2IkdHlwZSFcIik7XG5cblx0ICAgIGRpY3QgPSB0aGlzW1wiJGRcIl0gfHwgdGhpcy5jb25zdHJ1Y3RvcltcIiRkXCJdO1xuXG5cdCAgICBkZXNjciA9IFNrLmJ1aWx0aW4udHlwZS50eXBlTG9va3VwKHRwLCBuYW1lKTtcblxuXHQgICAgLy8gb3RoZXJ3aXNlLCBsb29rIGluIHRoZSB0eXBlIGZvciBhIGRlc2NyXG5cdCAgICBpZiAoZGVzY3IgIT09IHVuZGVmaW5lZCAmJiBkZXNjciAhPT0gbnVsbCAmJiBkZXNjci5vYiR0eXBlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAvL2YgPSBkZXNjci5vYiR0eXBlLnRwJGRlc2NyX3NldDtcblx0ICAgICAgICBpZiAoZGVzY3JbXCJfX3NldF9fXCJdKSB7XG5cdCAgICAgICAgICAgIGYgPSBkZXNjcltcIl9fc2V0X19cIl07XG5cdCAgICAgICAgICAgIFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQoZiwgZGVzY3IsIHRoaXMsIHZhbHVlKTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyB0b2RvO1xuXHQgICAgICAgIC8vaWYgKGYgJiYgZGVzY3IudHAkZGVzY3Jfc2V0KSAvLyBpcyBhIGRhdGEgZGVzY3JpcHRvciBpZiBpdCBoYXMgYSBzZXRcblx0ICAgICAgICAvL3JldHVybiBmLmNhbGwoZGVzY3IsIHRoaXMsIHRoaXMub2IkdHlwZSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChkaWN0Lm1wJGFzc19zdWJzY3JpcHQpIHtcblx0ICAgICAgICBweW5hbWUgPSBuZXcgU2suYnVpbHRpbi5zdHIobmFtZSk7XG5cblx0ICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ub2JqZWN0ICYmICEodGhpcy5vYiR0eXBlLnNrJGtsYXNzKSAmJlxuXHQgICAgICAgICAgICBkaWN0Lm1wJGxvb2t1cChweW5hbWUpID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgLy8gQ2Fubm90IGFkZCBuZXcgYXR0cmlidXRlcyB0byBhIGJ1aWx0aW4gb2JqZWN0XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiJ1wiICsgb2JqbmFtZSArIFwiJyBvYmplY3QgaGFzIG5vIGF0dHJpYnV0ZSAnXCIgKyBuYW1lICsgXCInXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBkaWN0Lm1wJGFzc19zdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uc3RyKG5hbWUpLCB2YWx1ZSk7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBkaWN0ID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgZGljdFtuYW1lXSA9IHZhbHVlO1xuXHQgICAgfVxuXHR9O1xuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5HZW5lcmljU2V0QXR0clwiLCBTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUuR2VuZXJpY1NldEF0dHIpO1xuXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5HZW5lcmljUHl0aG9uU2V0QXR0ciA9IGZ1bmN0aW9uKHNlbGYsIG5hbWUsIHZhbHVlKSB7XG5cdCAgICByZXR1cm4gU2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkdlbmVyaWNTZXRBdHRyLmNhbGwoc2VsZiwgbmFtZS52LCB2YWx1ZSk7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkdlbmVyaWNQeXRob25TZXRBdHRyXCIsIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5HZW5lcmljUHl0aG9uU2V0QXR0cik7XG5cblx0U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkhhc2hOb3RJbXBsZW1lbnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInVuaGFzaGFibGUgdHlwZTogJ1wiICsgU2suYWJzdHIudHlwZU5hbWUodGhpcykgKyBcIidcIik7XG5cdH07XG5cblx0U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLnRwJGdldGF0dHIgPSBTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUuR2VuZXJpY0dldEF0dHI7XG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS50cCRzZXRhdHRyID0gU2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkdlbmVyaWNTZXRBdHRyO1xuXG5cdC8vIEFsdGhvdWdoIGFjdHVhbCBhdHRyaWJ1dGUtZ2V0dGluZyBoYXBwZW5zIGluIHB1cmUgSmF2YXNjcmlwdCB2aWEgdHAkZ2V0YXR0ciwgY2xhc3Nlc1xuXHQvLyBvdmVycmlkaW5nIF9fZ2V0YXR0cl9fIGV0YyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsbCBvYmplY3QuX19nZXRhdHRyX18gZXRjIGZyb20gUHl0aG9uXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVtcIl9fZ2V0YXR0cl9fXCJdID0gU2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLkdlbmVyaWNQeXRob25HZXRBdHRyO1xuXHRTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGVbXCJfX3NldGF0dHJfX1wiXSA9IFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5HZW5lcmljUHl0aG9uU2V0QXR0cjtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgb2YgdGhpcyBjbGFzcy5cblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS50cCRuYW1lID0gXCJvYmplY3RcIjtcblxuXHQvKipcblx0ICogVGhlIHR5cGUgb2JqZWN0IG9mIHRoaXMgY2xhc3MuXG5cdCAqIEB0eXBlIHtTay5idWlsdGluLnR5cGV9XG5cdCAqL1xuXHRTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUub2IkdHlwZSA9IFNrLmJ1aWx0aW4udHlwZS5tYWtlSW50b1R5cGVPYmooXCJvYmplY3RcIiwgU2suYnVpbHRpbi5vYmplY3QpO1xuXHRTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUub2IkdHlwZS5zayRrbGFzcyA9IHVuZGVmaW5lZDsgICAvLyBOb25zZW5zZSBmb3IgY2xvc3VyZSBjb21waWxlclxuXG5cdC8qKiBEZWZhdWx0IGltcGxlbWVudGF0aW9ucyBvZiBkdW5kZXIgbWV0aG9kcyBmb3VuZCBpbiBhbGwgUHl0aG9uIG9iamVjdHMgKi9cblxuXHQvKipcblx0ICogUHl0aG9uIHdyYXBwZXIgZm9yIGBfX3JlcHJfX2AgbWV0aG9kLlxuXHQgKiBAbmFtZSAgX19yZXByX19cblx0ICogQG1lbWJlck9mIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICovXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVtcIl9fcmVwcl9fXCJdID0gZnVuY3Rpb24gKHNlbGYpIHtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX3JlcHJfX1wiLCBhcmd1bWVudHMsIDAsIDAsIGZhbHNlLCB0cnVlKTtcblxuXHQgICAgcmV0dXJuIHNlbGZbXCIkclwiXSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQeXRob24gd3JhcHBlciBmb3IgYF9fc3RyX19gIG1ldGhvZC5cblx0ICogQG5hbWUgIF9fc3RyX19cblx0ICogQG1lbWJlck9mIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICovXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVtcIl9fc3RyX19cIl0gPSBmdW5jdGlvbiAoc2VsZikge1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcIl9fc3RyX19cIiwgYXJndW1lbnRzLCAwLCAwLCBmYWxzZSwgdHJ1ZSk7XG5cblx0ICAgIHJldHVybiBzZWxmW1wiJHJcIl0oKTtcblx0fTtcblxuXHQvKipcblx0ICogUHl0aG9uIHdyYXBwZXIgZm9yIGBfX2hhc2hfX2AgbWV0aG9kLlxuXHQgKiBAbmFtZSAgX19oYXNoX19cblx0ICogQG1lbWJlck9mIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICovXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVtcIl9faGFzaF9fXCJdID0gZnVuY3Rpb24gKHNlbGYpIHtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2hhc2hfX1wiLCBhcmd1bWVudHMsIDAsIDAsIGZhbHNlLCB0cnVlKTtcblxuXHQgICAgcmV0dXJuIHNlbGYudHAkaGFzaCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQeXRob24gd3JhcHBlciBmb3IgYF9fZXFfX2AgbWV0aG9kLlxuXHQgKiBAbmFtZSAgX19lcV9fXG5cdCAqIEBtZW1iZXJPZiBTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGVcblx0ICogQGluc3RhbmNlXG5cdCAqL1xuXHRTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGVbXCJfX2VxX19cIl0gPSBmdW5jdGlvbiAoc2VsZiwgb3RoZXIpIHtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2VxX19cIiwgYXJndW1lbnRzLCAxLCAxLCBmYWxzZSwgdHJ1ZSk7XG5cblx0ICAgIHJldHVybiBzZWxmLm9iJGVxKG90aGVyKTtcblx0fTtcblxuXHQvKipcblx0ICogUHl0aG9uIHdyYXBwZXIgZm9yIGBfX25lX19gIG1ldGhvZC5cblx0ICogQG5hbWUgIF9fbmVfX1xuXHQgKiBAbWVtYmVyT2YgU2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKi9cblx0U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlW1wiX19uZV9fXCJdID0gZnVuY3Rpb24gKHNlbGYsIG90aGVyKSB7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiX19uZV9fXCIsIGFyZ3VtZW50cywgMSwgMSwgZmFsc2UsIHRydWUpO1xuXG5cdCAgICByZXR1cm4gc2VsZi5vYiRuZShvdGhlcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFB5dGhvbiB3cmFwcGVyIGZvciBgX19sdF9fYCBtZXRob2QuXG5cdCAqIEBuYW1lICBfX2x0X19cblx0ICogQG1lbWJlck9mIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICovXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVtcIl9fbHRfX1wiXSA9IGZ1bmN0aW9uIChzZWxmLCBvdGhlcikge1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcIl9fbHRfX1wiLCBhcmd1bWVudHMsIDEsIDEsIGZhbHNlLCB0cnVlKTtcblxuXHQgICAgcmV0dXJuIHNlbGYub2IkbHQob3RoZXIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQeXRob24gd3JhcHBlciBmb3IgYF9fbGVfX2AgbWV0aG9kLlxuXHQgKiBAbmFtZSAgX19sZV9fXG5cdCAqIEBtZW1iZXJPZiBTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGVcblx0ICogQGluc3RhbmNlXG5cdCAqL1xuXHRTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGVbXCJfX2xlX19cIl0gPSBmdW5jdGlvbiAoc2VsZiwgb3RoZXIpIHtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2xlX19cIiwgYXJndW1lbnRzLCAxLCAxLCBmYWxzZSwgdHJ1ZSk7XG5cblx0ICAgIHJldHVybiBzZWxmLm9iJGxlKG90aGVyKTtcblx0fTtcblxuXHQvKipcblx0ICogUHl0aG9uIHdyYXBwZXIgZm9yIGBfX2d0X19gIG1ldGhvZC5cblx0ICogQG5hbWUgIF9fZ3RfX1xuXHQgKiBAbWVtYmVyT2YgU2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlXG5cdCAqIEBpbnN0YW5jZVxuXHQgKi9cblx0U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlW1wiX19ndF9fXCJdID0gZnVuY3Rpb24gKHNlbGYsIG90aGVyKSB7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiX19ndF9fXCIsIGFyZ3VtZW50cywgMSwgMSwgZmFsc2UsIHRydWUpO1xuXG5cdCAgICByZXR1cm4gc2VsZi5vYiRndChvdGhlcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFB5dGhvbiB3cmFwcGVyIGZvciBgX19nZV9fYCBtZXRob2QuXG5cdCAqIEBuYW1lICBfX2dlX19cblx0ICogQG1lbWJlck9mIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVxuXHQgKiBAaW5zdGFuY2Vcblx0ICovXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZVtcIl9fZ2VfX1wiXSA9IGZ1bmN0aW9uIChzZWxmLCBvdGhlcikge1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcIl9fZ2VfX1wiLCBhcmd1bWVudHMsIDEsIDEsIGZhbHNlLCB0cnVlKTtcblxuXHQgICAgcmV0dXJuIHNlbGYub2IkZ2Uob3RoZXIpO1xuXHR9O1xuXG5cdC8qKiBEZWZhdWx0IGltcGxlbWVudGF0aW9ucyBvZiBKYXZhc2NyaXB0IGZ1bmN0aW9ucyB1c2VkIGluIGR1bmRlciBtZXRob2RzICovXG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEphdmFzY3JpcHQgZnVuY3Rpb24sIHJldHVybnMgUHl0aG9uIG9iamVjdC5cblx0ICpcblx0ICogQG5hbWUgICRyXG5cdCAqIEBtZW1iZXJPZiBTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGVcblx0ICogQHJldHVybiB7U2suYnVpbHRpbi5zdHJ9IFRoZSBQeXRob24gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgaW5zdGFuY2UuXG5cdCAqL1xuXHRTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGVbXCIkclwiXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8b2JqZWN0PlwiKTtcblx0fTtcblxuXHRTay5idWlsdGluLmhhc2hDb3VudCA9IDE7XG5cdFNrLmJ1aWx0aW4uaWRDb3VudCA9IDE7XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgaGFzaCB2YWx1ZSBvZiB0aGlzIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBKYXZhc2NyaXB0IGZ1bmN0aW9uLCByZXR1cm5zIFB5dGhvbiBvYmplY3QuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1NrLmJ1aWx0aW4uaW50X30gVGhlIGhhc2ggdmFsdWVcblx0ICovXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS50cCRoYXNoID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCF0aGlzLiRzYXZlZEhhc2hfKSB7XG5cdCAgICAgICAgdGhpcy4kc2F2ZWRIYXNoXyA9IG5ldyBTay5idWlsdGluLmludF8oU2suYnVpbHRpbi5oYXNoQ291bnQrKyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLiRzYXZlZEhhc2hfO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQZXJmb3JtIGVxdWFsaXR5IGNoZWNrIGJldHdlZW4gdGhpcyBpbnN0YW5jZSBhbmQgYSBQeXRob24gb2JqZWN0IChpLmUuIHRoaXMgPT0gb3RoZXIpLlxuXHQgKlxuXHQgKiBJbXBsZW1lbnRzIGBfX2VxX19gIGR1bmRlciBtZXRob2QuXG5cdCAqXG5cdCAqIEphdmFzY3JpcHQgZnVuY3Rpb24sIHJldHVybnMgUHl0aG9uIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvdGhlciBUaGUgUHl0aG9uIG9iamVjdCB0byBjaGVjayBmb3IgZXF1YWxpdHkuXG5cdCAqIEByZXR1cm4geyhTay5idWlsdGluLmJvb2x8U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZCl9IHRydWUgaWYgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLm9iJGVxID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBlcmZvcm0gbm9uLWVxdWFsaXR5IGNoZWNrIGJldHdlZW4gdGhpcyBpbnN0YW5jZSBhbmQgYSBQeXRob24gb2JqZWN0IChpLmUuIHRoaXMgIT0gb3RoZXIpLlxuXHQgKlxuXHQgKiBJbXBsZW1lbnRzIGBfX25lX19gIGR1bmRlciBtZXRob2QuXG5cdCAqXG5cdCAqIEphdmFzY3JpcHQgZnVuY3Rpb24sIHJldHVybnMgUHl0aG9uIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvdGhlciBUaGUgUHl0aG9uIG9iamVjdCB0byBjaGVjayBmb3Igbm9uLWVxdWFsaXR5LlxuXHQgKiBAcmV0dXJuIHsoU2suYnVpbHRpbi5ib29sfFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQpfSB0cnVlIGlmIG5vdCBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUub2IkbmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuXHQgICAgICAgIHJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGlzIGluc3RhbmNlIGlzIGxlc3MgdGhhbiBhIFB5dGhvbiBvYmplY3QgKGkuZS4gdGhpcyA8IG90aGVyKS5cblx0ICpcblx0ICogSW1wbGVtZW50cyBgX19sdF9fYCBkdW5kZXIgbWV0aG9kLlxuXHQgKlxuXHQgKiBKYXZhc2NyaXB0IGZ1bmN0aW9uLCByZXR1cm5zIFB5dGhvbiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3RoZXIgVGhlIFB5dGhvbiBvYmplY3QgdG8gY29tcGFyZS5cblx0ICogQHJldHVybiB7KFNrLmJ1aWx0aW4uYm9vbHxTay5idWlsdGluLk5vdEltcGxlbWVudGVkKX0gdHJ1ZSBpZiB0aGlzIDwgb3RoZXIsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLm9iJGx0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICByZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGlzIGluc3RhbmNlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBhIFB5dGhvbiBvYmplY3QgKGkuZS4gdGhpcyA8PSBvdGhlcikuXG5cdCAqXG5cdCAqIEltcGxlbWVudHMgYF9fbGVfX2AgZHVuZGVyIG1ldGhvZC5cblx0ICpcblx0ICogSmF2YXNjcmlwdCBmdW5jdGlvbiwgcmV0dXJucyBQeXRob24gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG90aGVyIFRoZSBQeXRob24gb2JqZWN0IHRvIGNvbXBhcmUuXG5cdCAqIEByZXR1cm4geyhTay5idWlsdGluLmJvb2x8U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZCl9IHRydWUgaWYgdGhpcyA8PSBvdGhlciwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUub2IkbGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgIHJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoaXMgaW5zdGFuY2UgaXMgZ3JlYXRlciB0aGFuIGEgUHl0aG9uIG9iamVjdCAoaS5lLiB0aGlzID4gb3RoZXIpLlxuXHQgKlxuXHQgKiBJbXBsZW1lbnRzIGBfX2d0X19gIGR1bmRlciBtZXRob2QuXG5cdCAqXG5cdCAqIEphdmFzY3JpcHQgZnVuY3Rpb24sIHJldHVybnMgUHl0aG9uIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvdGhlciBUaGUgUHl0aG9uIG9iamVjdCB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJuIHsoU2suYnVpbHRpbi5ib29sfFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQpfSB0cnVlIGlmIHRoaXMgPiBvdGhlciwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUub2IkZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgIHJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoaXMgaW5zdGFuY2UgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGEgUHl0aG9uIG9iamVjdCAoaS5lLiB0aGlzID49IG90aGVyKS5cblx0ICpcblx0ICogSW1wbGVtZW50cyBgX19nZV9fYCBkdW5kZXIgbWV0aG9kLlxuXHQgKlxuXHQgKiBKYXZhc2NyaXB0IGZ1bmN0aW9uLCByZXR1cm5zIFB5dGhvbiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3RoZXIgVGhlIFB5dGhvbiBvYmplY3QgdG8gY29tcGFyZS5cblx0ICogQHJldHVybiB7KFNrLmJ1aWx0aW4uYm9vbHxTay5idWlsdGluLk5vdEltcGxlbWVudGVkKX0gdHJ1ZSBpZiB0aGlzID49IG90aGVyLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS5vYiRnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO1xuXHR9O1xuXG5cdC8vIFdyYXAgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgaW4gU2suYnVpbHRpbi5mdW5jIG9uY2UgdGhhdCBjbGFzcyBpcyBpbml0aWFsaXplZFxuXHQvKipcblx0ICogQXJyYXkgb2YgYWxsIHRoZSBQeXRob24gZnVuY3Rpb25zIHdoaWNoIGFyZSBtZXRob2RzIG9mIHRoaXMgY2xhc3MuXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICovXG5cdFNrLmJ1aWx0aW4ub2JqZWN0LnB5dGhvbkZ1bmN0aW9ucyA9IFtcIl9fcmVwcl9fXCIsIFwiX19zdHJfX1wiLCBcIl9faGFzaF9fXCIsXG5cdFwiX19lcV9fXCIsIFwiX19uZV9fXCIsIFwiX19sdF9fXCIsIFwiX19sZV9fXCIsIFwiX19ndF9fXCIsIFwiX19nZV9fXCIsIFwiX19nZXRhdHRyX19cIiwgXCJfX3NldGF0dHJfX1wiXTtcblxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIFNrLmJ1aWx0aW4ubm9uZVxuXHQgKlxuXHQgKiBAZXh0ZW5kcyB7U2suYnVpbHRpbi5vYmplY3R9XG5cdCAqL1xuXHRTay5idWlsdGluLm5vbmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnYgPSBudWxsO1xuXHR9O1xuXHRTay5hYnN0ci5zZXRVcEluaGVyaXRhbmNlKFwiTm9uZVR5cGVcIiwgU2suYnVpbHRpbi5ub25lLCBTay5idWlsdGluLm9iamVjdCk7XG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRTay5idWlsdGluLm5vbmUucHJvdG90eXBlW1wiJHJcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJOb25lXCIpOyB9O1xuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0U2suYnVpbHRpbi5ub25lLnByb3RvdHlwZS50cCRoYXNoID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFB5dGhvbiBOb25lIGNvbnN0YW50LlxuXHQgKiBAdHlwZSB7U2suYnVpbHRpbi5ub25lfVxuXHQgKi9cblx0U2suYnVpbHRpbi5ub25lLm5vbmUkID0gbmV3IFNrLmJ1aWx0aW4ubm9uZSgpO1xuXG5cdC8qKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZFxuXHQgKlxuXHQgKiBAZXh0ZW5kcyB7U2suYnVpbHRpbi5vYmplY3R9XG5cdCAqL1xuXHRTay5idWlsdGluLk5vdEltcGxlbWVudGVkID0gZnVuY3Rpb24oKSB7IH07XG5cdFNrLmFic3RyLnNldFVwSW5oZXJpdGFuY2UoXCJOb3RJbXBsZW1lbnRlZFR5cGVcIiwgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZCwgU2suYnVpbHRpbi5vYmplY3QpO1xuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5wcm90b3R5cGVbXCIkclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIk5vdEltcGxlbWVudGVkXCIpOyB9O1xuXG5cdC8qKlxuXHQgKiBQeXRob24gTm90SW1wbGVtZW50ZWQgY29uc3RhbnQuXG5cdCAqIEB0eXBlIHtTay5idWlsdGluLk5vdEltcGxlbWVudGVkfVxuXHQgKi9cblx0U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQgPSBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZCgpO1xuXG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5ub25lXCIsIFNrLmJ1aWx0aW4ubm9uZSk7XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZFwiLCBTay5idWlsdGluLk5vdEltcGxlbWVudGVkKTtcblxuXG5cblx0LyogLS0tLSAvVXNlcnMvcm9iL3NrdWxwdHkvbGliLy4uL25vZGVfbW9kdWxlcy9za3VscHQvc3JjL2Z1bmN0aW9uLmpzIC0tLS0gKi8gXG5cblx0LyoqXG5cdCAqIEBuYW1lc3BhY2UgU2suYnVpbHRpblxuXHQgKi9cblxuXG5cdC8qKlxuXHQgKiBDaGVjayBhcmd1bWVudHMgdG8gUHl0aG9uIGZ1bmN0aW9ucyB0byBlbnN1cmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mXG5cdCAqIGFyZ3VtZW50cyBhcmUgcGFzc2VkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgdGhlIGFyZ3MgcGFzc2VkIHRvIHRoZSBmdW5jdGlvblxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluYXJncyB0aGUgbWluaW11bSBudW1iZXIgb2YgYWxsb3dhYmxlIGFyZ3VtZW50c1xuXHQgKiBAcGFyYW0ge251bWJlcj19IG1heGFyZ3Mgb3B0aW9uYWwgbWF4aW11bSBudW1iZXIgb2YgYWxsb3dhYmxlXG5cdCAqIGFyZ3VtZW50cyAoZGVmYXVsdDogSW5maW5pdHkpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGt3YXJncyBvcHRpb25hbCB0cnVlIGlmIGt3YXJncywgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqIChkZWZhdWx0OiBmYWxzZSlcblx0ICogQHBhcmFtIHtib29sZWFuPX0gZnJlZSBvcHRpb25hbCB0cnVlIGlmIGZyZWUgdmFycywgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqIChkZWZhdWx0OiBmYWxzZSlcblx0ICovXG5cdFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MgPSBmdW5jdGlvbiAobmFtZSwgYXJncywgbWluYXJncywgbWF4YXJncywga3dhcmdzLCBmcmVlKSB7XG5cdCAgICB2YXIgbmFyZ3MgPSBhcmdzLmxlbmd0aDtcblx0ICAgIHZhciBtc2cgPSBcIlwiO1xuXG5cdCAgICBpZiAobWF4YXJncyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgbWF4YXJncyA9IEluZmluaXR5O1xuXHQgICAgfVxuXHQgICAgaWYgKGt3YXJncykge1xuXHQgICAgICAgIG5hcmdzIC09IDE7XG5cdCAgICB9XG5cdCAgICBpZiAoZnJlZSkge1xuXHQgICAgICAgIG5hcmdzIC09IDE7XG5cdCAgICB9XG5cdCAgICBpZiAoKG5hcmdzIDwgbWluYXJncykgfHwgKG5hcmdzID4gbWF4YXJncykpIHtcblx0ICAgICAgICBpZiAobWluYXJncyA9PT0gbWF4YXJncykge1xuXHQgICAgICAgICAgICBtc2cgPSBuYW1lICsgXCIoKSB0YWtlcyBleGFjdGx5IFwiICsgbWluYXJncyArIFwiIGFyZ3VtZW50c1wiO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobmFyZ3MgPCBtaW5hcmdzKSB7XG5cdCAgICAgICAgICAgIG1zZyA9IG5hbWUgKyBcIigpIHRha2VzIGF0IGxlYXN0IFwiICsgbWluYXJncyArIFwiIGFyZ3VtZW50c1wiO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIG1zZyA9IG5hbWUgKyBcIigpIHRha2VzIGF0IG1vc3QgXCIgKyBtYXhhcmdzICsgXCIgYXJndW1lbnRzXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG1zZyArPSBcIiAoXCIgKyBuYXJncyArIFwiIGdpdmVuKVwiO1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihtc2cpO1xuXHQgICAgfVxuXHR9O1xuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NcIiwgU2suYnVpbHRpbi5weUNoZWNrQXJncyk7XG5cblx0LyoqXG5cdCAqIENoZWNrIHR5cGUgb2YgYXJndW1lbnQgdG8gUHl0aG9uIGZ1bmN0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBleHB0eXBlIHN0cmluZyBvZiB0aGUgZXhwZWN0ZWQgdHlwZSBuYW1lXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2sgdHJ1dGh5IGlmIHR5cGUgY2hlY2sgcGFzc2VzLCBmYWxzeSBvdGhlcndpc2Vcblx0ICovXG5cdFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUgPSBmdW5jdGlvbiAobmFtZSwgZXhwdHlwZSwgY2hlY2spIHtcblx0ICAgIGlmICghY2hlY2spIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IobmFtZSArIFwiIG11c3QgYmUgYSBcIiArIGV4cHR5cGUpO1xuXHQgICAgfVxuXHR9O1xuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ucHlDaGVja1R5cGVcIiwgU2suYnVpbHRpbi5weUNoZWNrVHlwZSk7XG5cblx0U2suYnVpbHRpbi5jaGVja1NlcXVlbmNlID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgcmV0dXJuIChhcmcgIT09IG51bGwgJiYgYXJnLm1wJHN1YnNjcmlwdCAhPT0gdW5kZWZpbmVkKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrU2VxdWVuY2VcIiwgU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKTtcblxuXHQvKipcblx0ICogVXNlIHRoaXMgdG8gdGVzdCB3aGV0aGVyIG9yIG5vdCBhIFB5dGhvbiBvYmplY3QgaXMgaXRlcmFibGUuICBZb3Ugc2hvdWxkICoqbm90KiogcmVseVxuXHQgKiBvbiB0aGUgcHJlc2VuY2Ugb2YgdHAkaXRlciBvbiB0aGUgb2JqZWN0IGFzIGEgZ29vZCB0ZXN0LCBhcyBpdCBjb3VsZCBiZSBhIHVzZXIgZGVmaW5lZFxuXHQgKiBjbGFzcyB3aXRoIGBfX2l0ZXJfX2AgZGVmaW5lZCBvciBgYF9fZ2V0aXRlbV9fYGAgIFRoaXMgdGVzdHMgZm9yIGFsbCBvZiB0aG9zZSBjYXNlc1xuXHQgKlxuXHQgKiBAcGFyYW0gYXJnIHtPYmplY3R9ICAgQSBQeXRob24gb2JqZWN0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgaXRlcmFibGVcblx0ICovXG5cdFNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZSA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgIHZhciByZXQgPSBmYWxzZTtcblx0ICAgIGlmIChhcmcgIT09IG51bGwgKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0ID0gU2suYWJzdHIuaXRlcihhcmcpO1xuXHQgICAgICAgICAgICBpZiAocmV0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTay5idWlsdGluLlR5cGVFcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXQ7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlXCIsIFNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZSk7XG5cblx0U2suYnVpbHRpbi5jaGVja0NhbGxhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgLy8gdGFrZXMgY2FyZSBvZiBidWlsdGluIGZ1bmN0aW9ucyBhbmQgbWV0aG9kcywgYnVpbHRpbnNcblx0ICAgIGlmICh0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIC8vIHRha2VzIGNhcmUgb2YgcHl0aG9uIGZ1bmN0aW9uLCBtZXRob2RzIGFuZCBsYW1iZGFzXG5cdCAgICBpZiAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mdW5jKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICAvLyB0YWtlcyBjYXJlIG9mIGluc3RhbmNlcyBvZiBtZXRob2RzXG5cdCAgICBpZiAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5tZXRob2QpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIC8vIGdvIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gc2VlIGlmIHRoZSBjbGFzcyBoYXMgYSBfX2NhbGxfXyBtZXRob2Rcblx0ICAgIGlmIChTay5hYnN0ci5sb29rdXBTcGVjaWFsKG9iaiwgXCJfX2NhbGxfX1wiKSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IFxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICByZXR1cm4gKGFyZyAhPT0gbnVsbCAmJiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIiB8fFxuXHQgICAgICAgIGFyZyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XyB8fFxuXHQgICAgICAgIGFyZyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfIHx8XG5cdCAgICAgICAgYXJnIGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmcpKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrTnVtYmVyXCIsIFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIpO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgZm9yIGNvbXBsZXggdHlwZSwgZGVsZWdhdGVzIHRvIGludGVybmFsIG1ldGhvZFxuXHQgKiBNb3N0IHNrdWxwdCB1c2VycyB3b3VsZCBzZWFyY2ggaGVyZSFcblx0ICovXG5cdFNrLmJ1aWx0aW4uY2hlY2tDb21wbGV4ID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgcmV0dXJuIFNrLmJ1aWx0aW4uY29tcGxleC5fY29tcGxleF9jaGVjayhhcmcpO1xuXHR9O1xuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tDb21wbGV4XCIsIFNrLmJ1aWx0aW4uY2hlY2tDb21wbGV4KTtcblxuXHRTay5idWlsdGluLmNoZWNrSW50ID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgcmV0dXJuIChhcmcgIT09IG51bGwpICYmICgodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIiAmJiBhcmcgPT09IChhcmcgfCAwKSkgfHxcblx0ICAgICAgICBhcmcgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8gfHxcblx0ICAgICAgICBhcmcgaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZyk7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0ludFwiLCBTay5idWlsdGluLmNoZWNrSW50KTtcblxuXHRTay5idWlsdGluLmNoZWNrRmxvYXQgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICByZXR1cm4gKGFyZyAhPT0gbnVsbCkgJiYgKGFyZyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrRmxvYXRcIiwgU2suYnVpbHRpbi5jaGVja0Zsb2F0KTtcblxuXHRTay5idWlsdGluLmNoZWNrU3RyaW5nID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgcmV0dXJuIChhcmcgIT09IG51bGwgJiYgYXJnLl9fY2xhc3NfXyA9PSBTay5idWlsdGluLnN0cik7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja1N0cmluZ1wiLCBTay5idWlsdGluLmNoZWNrU3RyaW5nKTtcblxuXHRTay5idWlsdGluLmNoZWNrQ2xhc3MgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICByZXR1cm4gKGFyZyAhPT0gbnVsbCAmJiBhcmcuc2skdHlwZSk7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0NsYXNzXCIsIFNrLmJ1aWx0aW4uY2hlY2tDbGFzcyk7XG5cblx0U2suYnVpbHRpbi5jaGVja0Jvb2wgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICByZXR1cm4gKGFyZyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYm9vbCk7XG5cdH07XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0Jvb2xcIiwgU2suYnVpbHRpbi5jaGVja0Jvb2wpO1xuXG5cdFNrLmJ1aWx0aW4uY2hlY2tOb25lID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgcmV0dXJuIChhcmcgaW5zdGFuY2VvZiBTay5idWlsdGluLm5vbmUpO1xuXHR9O1xuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tOb25lXCIsIFNrLmJ1aWx0aW4uY2hlY2tOb25lKTtcblxuXHRTay5idWlsdGluLmNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICByZXR1cm4gKGFyZyAhPT0gbnVsbCAmJiBhcmcudHAkY2FsbCAhPT0gdW5kZWZpbmVkKTtcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrRnVuY3Rpb25cIiwgU2suYnVpbHRpbi5jaGVja0Z1bmN0aW9uKTtcblxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIFNrLmJ1aWx0aW4uZnVuY1xuXHQgKlxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gaW50byBhIFB5dGhvbiBvYmplY3QgdGhhdCBpcyBjYWxsYWJsZS4gIE9yIGp1c3Rcblx0ICogdGhpbmsgb2YgaXQgYXMgYSBQeXRob24gZnVuY3Rpb24gcmF0aGVyIHRoYW4gYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIG5vdy4gIFRoaXMgaXMgYW4gaW1wb3J0YW50XG5cdCAqIGRpc3RpbmN0aW9uIGluIHNrdWxwdCBiZWNhdXNlIG9uY2UgeW91IGhhdmUgUHl0aG9uIGZ1bmN0aW9uIHlvdSBjYW5ub3QganVzdCBjYWxsIGl0LlxuXHQgKiBZb3UgbXVzdCBub3cgdXNlIFNrLm1pc2NldmFsLmNhbGxzaW0gdG8gY2FsbCB0aGUgUHl0aG9uIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb2RlIHRoZSBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb25cblx0ICogQHBhcmFtIHtPYmplY3Q9fSBnbG9iYWxzIHRoZSBnbG9iYWxzIHdoZXJlIHRoaXMgZnVuY3Rpb24gd2FzIGRlZmluZWQuXG5cdCAqIENhbiBiZSB1bmRlZmluZWQgKHdoaWNoIHdpbGwgYmUgc3RvcmVkIGFzIG51bGwpIGZvciBidWlsdGlucy4gKGlzXG5cdCAqIHRoYXQgb2s/KVxuXHQgKiBAcGFyYW0ge09iamVjdD19IGNsb3N1cmUgZGljdCBvZiBmcmVlIHZhcmlhYmxlc1xuXHQgKiBAcGFyYW0ge09iamVjdD19IGNsb3N1cmUyIGFub3RoZXIgZGljdCBvZiBmcmVlIHZhcmlhYmxlcyB0aGF0IHdpbGwgYmVcblx0ICogbWVyZ2VkIGludG8gJ2Nsb3N1cmUnLiB0aGVyZSdzIDIgdG8gc2ltcGxpZnkgZ2VuZXJhdGVkIGNvZGUgKG9uZSBpcyAkZnJlZSxcblx0ICogdGhlIG90aGVyIGlzICRjZWxsKVxuXHQgKlxuXHQgKiBjbG9zdXJlIGlzIHRoZSBjZWxsIHZhcmlhYmxlcyBmcm9tIHRoZSBwYXJlbnQgc2NvcGUgdGhhdCB3ZSBuZWVkIHRvIGNsb3NlXG5cdCAqIG92ZXIuIGNsb3N1cmUyIGlzIHRoZSBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgcGFyZW50IHNjb3BlIHRoYXQgd2UgYWxzbyBtaWdodFxuXHQgKiBuZWVkIHRvIGFjY2Vzcy5cblx0ICpcblx0ICogTk9URTogY29fdmFybmFtZXMgYW5kIGNvX25hbWUgYXJlIGRlZmluZWQgYnkgY29tcGlsZWQgY29kZSBvbmx5LCBzbyB3ZSBoYXZlXG5cdCAqIHRvIGFjY2VzcyB0aGVtIHZpYSBkaWN0LXN0eWxlIGxvb2t1cCBmb3IgY2xvc3VyZS5cblx0ICpcblx0ICovXG5cdFNrLmJ1aWx0aW4uZnVuYyA9IGZ1bmN0aW9uIChjb2RlLCBnbG9iYWxzLCBjbG9zdXJlLCBjbG9zdXJlMikge1xuXHQgICAgdmFyIGs7XG5cdCAgICB0aGlzLmZ1bmNfY29kZSA9IGNvZGU7XG5cdCAgICB0aGlzLmZ1bmNfZ2xvYmFscyA9IGdsb2JhbHMgfHwgbnVsbDtcblx0ICAgIGlmIChjbG9zdXJlMiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgLy8gdG9kbzsgY29uZmlybSB0aGF0IG1vZGlmaWNhdGlvbiBoZXJlIGNhbid0IGNhdXNlIHByb2JsZW1zXG5cdCAgICAgICAgZm9yIChrIGluIGNsb3N1cmUyKSB7XG5cdCAgICAgICAgICAgIGNsb3N1cmVba10gPSBjbG9zdXJlMltrXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICB0aGlzLmZ1bmNfY2xvc3VyZSA9IGNsb3N1cmU7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmZ1bmNcIiwgU2suYnVpbHRpbi5mdW5jKTtcblxuXG5cdFNrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGUudHAkbmFtZSA9IFwiZnVuY3Rpb25cIjtcblx0U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS50cCRkZXNjcl9nZXQgPSBmdW5jdGlvbiAob2JqLCBvYmp0eXBlKSB7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KG9iaiAhPT0gdW5kZWZpbmVkICYmIG9ianR5cGUgIT09IHVuZGVmaW5lZCk7XG5cdCAgICBpZiAob2JqID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5tZXRob2QodGhpcywgb2JqLCBvYmp0eXBlKTtcblx0fTtcblx0U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS50cCRjYWxsID0gZnVuY3Rpb24gKGFyZ3MsIGt3KSB7XG5cdCAgICB2YXIgajtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIG51bXZhcm5hbWVzO1xuXHQgICAgdmFyIHZhcm5hbWVzO1xuXHQgICAgdmFyIGt3bGVuO1xuXHQgICAgdmFyIGt3YXJnc2Fycjtcblx0ICAgIHZhciBleHBlY3Rza3c7XG5cdCAgICB2YXIgbmFtZTtcblx0ICAgIHZhciBudW1hcmdzO1xuXG5cdCAgICAvLyBub3RlOiBmdW5jdGlvbnMgZXhwZWN0ICd0aGlzJyB0byBiZSBnbG9iYWxzIHRvIGF2b2lkIGhhdmluZyB0b1xuXHQgICAgLy8gc2xpY2UvdW5zaGlmdCBvbnRvIHRoZSBtYWluIGFyZ3Ncblx0ICAgIGlmICh0aGlzLmZ1bmNfY2xvc3VyZSkge1xuXHQgICAgICAgIC8vIHRvZG87IE9LIHRvIG1vZGlmeT9cblx0ICAgICAgICBpZiAodGhpcy5mdW5jX2NvZGVbXCIkZGVmYXVsdHNcIl0gJiYgdGhpcy5mdW5jX2NvZGVbXCJjb192YXJuYW1lc1wiXSkge1xuXHQgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGRlZmF1bHQgYXJndW1lbnRzIGFyZSBpbiBhcmdzIGJlZm9yZSBhZGRpbmcgY2xvc3VyZVxuXHQgICAgICAgICAgICBudW1hcmdzID0gYXJncy5sZW5ndGg7XG5cdCAgICAgICAgICAgIG51bXZhcm5hbWVzID0gdGhpcy5mdW5jX2NvZGVbXCJjb192YXJuYW1lc1wiXS5sZW5ndGg7XG5cdCAgICAgICAgICAgIGZvciAoaSA9IG51bWFyZ3M7IGkgPCBudW12YXJuYW1lczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBhcmdzLnB1c2godW5kZWZpbmVkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBhcmdzLnB1c2godGhpcy5mdW5jX2Nsb3N1cmUpO1xuXHQgICAgfVxuXG5cdCAgICBleHBlY3Rza3cgPSB0aGlzLmZ1bmNfY29kZVtcImNvX2t3YXJnc1wiXTtcblx0ICAgIGt3YXJnc2FyciA9IFtdO1xuXG5cdCAgICBpZiAodGhpcy5mdW5jX2NvZGVbXCJub19rd1wiXSAmJiBrdykge1xuXHQgICAgICAgIG5hbWUgPSAodGhpcy5mdW5jX2NvZGUgJiYgdGhpcy5mdW5jX2NvZGVbXCJjb19uYW1lXCJdICYmIHRoaXMuZnVuY19jb2RlW1wiY29fbmFtZVwiXS52KSB8fCBcIjxuYXRpdmUgSlM+XCI7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKG5hbWUgKyBcIigpIHRha2VzIG5vIGtleXdvcmQgYXJndW1lbnRzXCIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoa3cpIHtcblx0ICAgICAgICAvLyBiaW5kIHRoZSBrdyBhcmdzXG5cdCAgICAgICAga3dsZW4gPSBrdy5sZW5ndGg7XG5cdCAgICAgICAgdmFybmFtZXMgPSB0aGlzLmZ1bmNfY29kZVtcImNvX3Zhcm5hbWVzXCJdO1xuXHQgICAgICAgIG51bXZhcm5hbWVzID0gdmFybmFtZXMgJiYgdmFybmFtZXMubGVuZ3RoO1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrd2xlbjsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgIC8vIHRvZG87IG1ha2UgdGhpcyBhIGRpY3QgbWFwcGluZyBuYW1lIHRvIG9mZnNldFxuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbnVtdmFybmFtZXM7ICsraikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGt3W2ldID09PSB2YXJuYW1lc1tqXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh2YXJuYW1lcyAmJiBqICE9PSBudW12YXJuYW1lcykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGogaW4gYXJncykge1xuXHQgICAgICAgICAgICAgICAgICAgIG5hbWUgPSAodGhpcy5mdW5jX2NvZGUgJiYgdGhpcy5mdW5jX2NvZGVbXCJjb19uYW1lXCJdICYmIHRoaXMuZnVuY19jb2RlW1wiY29fbmFtZVwiXS52KSB8fCBcIjxuYXRpdmUgSlM+XCI7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKG5hbWUgKyBcIigpIGdvdCBtdWx0aXBsZSB2YWx1ZXMgZm9yIGtleXdvcmQgYXJndW1lbnQgJ1wiICsga3dbaV0gKyBcIidcIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBhcmdzW2pdID0ga3dbaSArIDFdO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdHNrdykge1xuXHQgICAgICAgICAgICAgICAgLy8gYnVpbGQga3dhcmdzIGRpY3Rcblx0ICAgICAgICAgICAgICAgIGt3YXJnc2Fyci5wdXNoKG5ldyBTay5idWlsdGluLnN0cihrd1tpXSkpO1xuXHQgICAgICAgICAgICAgICAga3dhcmdzYXJyLnB1c2goa3dbaSArIDFdKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5hbWUgPSAodGhpcy5mdW5jX2NvZGUgJiYgdGhpcy5mdW5jX2NvZGVbXCJjb19uYW1lXCJdICYmIHRoaXMuZnVuY19jb2RlW1wiY29fbmFtZVwiXS52KSB8fCBcIjxuYXRpdmUgSlM+XCI7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IobmFtZSArIFwiKCkgZ290IGFuIHVuZXhwZWN0ZWQga2V5d29yZCBhcmd1bWVudCAnXCIgKyBrd1tpXSArIFwiJ1wiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChleHBlY3Rza3cpIHtcblx0ICAgICAgICBhcmdzLnVuc2hpZnQoa3dhcmdzYXJyKTtcblx0ICAgIH1cblxuXHQgICAgLy9wcmludChKU09OLnN0cmluZ2lmeShhcmdzLCBudWxsLCAyKSk7XG5cblx0ICAgIHJldHVybiB0aGlzLmZ1bmNfY29kZS5hcHBseSh0aGlzLmZ1bmNfZ2xvYmFscywgYXJncyk7XG5cdH07XG5cblx0U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS50cCRnZXRhdHRyID0gZnVuY3Rpb24gKGtleSkge1xuXHQgICAgcmV0dXJuIHRoaXNba2V5XTtcblx0fTtcblx0U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS50cCRzZXRhdHRyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuXHR9O1xuXG5cdC8vdG9kbzsgaW52ZXN0aWdhdGUgd2h5IHRoZSBvdGhlciBkb2Vzbid0IHdvcmtcblx0Ly9Tay5idWlsdGluLnR5cGUubWFrZUludG9UeXBlT2JqKCdmdW5jdGlvbicsIFNrLmJ1aWx0aW4uZnVuYyk7XG5cdFNrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGUub2IkdHlwZSA9IFNrLmJ1aWx0aW4udHlwZS5tYWtlVHlwZU9iaihcImZ1bmN0aW9uXCIsIG5ldyBTay5idWlsdGluLmZ1bmMobnVsbCwgbnVsbCkpO1xuXG5cdFNrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGVbXCIkclwiXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBuYW1lID0gKHRoaXMuZnVuY19jb2RlICYmIHRoaXMuZnVuY19jb2RlW1wiY29fbmFtZVwiXSAmJiB0aGlzLmZ1bmNfY29kZVtcImNvX25hbWVcIl0udikgfHwgXCI8bmF0aXZlIEpTPlwiO1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIjxmdW5jdGlvbiBcIiArIG5hbWUgKyBcIj5cIik7XG5cdH07XG5cblxuXG5cdC8qIC0tLS0gL1VzZXJzL3JvYi9za3VscHR5L2xpYi8uLi9ub2RlX21vZHVsZXMvc2t1bHB0L3NyYy9zZXF0eXBlLmpzIC0tLS0gKi8gXG5cblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBTay5idWlsdGluLnNlcXR5cGVcblx0ICpcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIEFic3RyYWN0IGNsYXNzIGZvciBQeXRob24gc2VxdWVuY2UgdHlwZXMuXG5cdCAqXG5cdCAqIEBleHRlbmRzIHtTay5idWlsdGluLm9iamVjdH1cblx0ICpcblx0ICogQHJldHVybiB7dW5kZWZpbmVkfSBDYW5ub3QgaW5zdGFudGlhdGUgYSBTay5idWlsdGluLnNlcXR5cGUgb2JqZWN0XG5cdCAqL1xuXHRTay5idWlsdGluLnNlcXR5cGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLkV4dGVybmFsRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgU2suYnVpbHRpbi5zZXF0eXBlIGNsYXNzXCIpO1xuXG5cdH07XG5cblx0U2suYWJzdHIuc2V0VXBJbmhlcml0YW5jZShcIlNlcXVlbmNlVHlwZVwiLCBTay5idWlsdGluLnNlcXR5cGUsIFNrLmJ1aWx0aW4ub2JqZWN0KTtcblxuXHRTay5idWlsdGluLnNlcXR5cGUuc2skYWJzdHJhY3QgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBQeXRob24gd3JhcHBlciBvZiBgX19sZW5fX2AgbWV0aG9kLlxuXHQgKlxuXHQgKiBAbmFtZSAgX19sZW5fX1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlck9mIFNrLmJ1aWx0aW4uc2VxdHlwZS5wcm90b3R5cGVcblx0ICovXG5cdFNrLmJ1aWx0aW4uc2VxdHlwZS5wcm90b3R5cGVbXCJfX2xlbl9fXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZikge1xuXG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiX19sZW5fX1wiLCBhcmd1bWVudHMsIDAsIDAsIGZhbHNlLCB0cnVlKTtcblxuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oc2VsZi5zcSRsZW5ndGgoKSk7ICAgIFxuXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBQeXRob24gd3JhcHBlciBvZiBgX19pdGVyX19gIG1ldGhvZC5cblx0ICpcblx0ICogQG5hbWUgIF9faXRlcl9fXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyT2YgU2suYnVpbHRpbi5zZXF0eXBlLnByb3RvdHlwZVxuXHQgKi9cblx0U2suYnVpbHRpbi5zZXF0eXBlLnByb3RvdHlwZVtcIl9faXRlcl9fXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZikge1xuXG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiX19pdGVyX19cIiwgYXJndW1lbnRzLCAwLCAwLCBmYWxzZSwgdHJ1ZSk7XG5cblx0ICAgIHJldHVybiBzZWxmLnRwJGl0ZXIoKTtcblxuXHR9KTtcblxuXHQvKipcblx0ICogUHl0aG9uIHdyYXBwZXIgb2YgYF9fY29udGFpbnNfX2AgbWV0aG9kLlxuXHQgKlxuXHQgKiBAbmFtZSAgX19jb250YWluc19fXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyT2YgU2suYnVpbHRpbi5zZXF0eXBlLnByb3RvdHlwZVxuXHQgKi9cblx0U2suYnVpbHRpbi5zZXF0eXBlLnByb3RvdHlwZVtcIl9fY29udGFpbnNfX1wiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIGl0ZW0pIHtcblxuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcIl9fY29udGFpbnNfX1wiLCBhcmd1bWVudHMsIDEsIDEsIGZhbHNlLCB0cnVlKTtcblxuXHQgICAgaWYgKHNlbGYuc3EkY29udGFpbnMoaXRlbSkpIHtcblx0ICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDtcblx0ICAgIH1cblxuXHR9KTtcblxuXHQvKipcblx0ICogUHl0aG9uIHdyYXBwZXIgb2YgYF9fZ2V0aXRlbV9fYCBtZXRob2QuXG5cdCAqXG5cdCAqIEBuYW1lICBfX2dldGl0ZW1fX1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlck9mIFNrLmJ1aWx0aW4uc2VxdHlwZS5wcm90b3R5cGVcblx0ICovXG5cdFNrLmJ1aWx0aW4uc2VxdHlwZS5wcm90b3R5cGVbXCJfX2dldGl0ZW1fX1wiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIGtleSkge1xuXG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiX19nZXRpdGVtX19cIiwgYXJndW1lbnRzLCAxLCAxLCBmYWxzZSwgdHJ1ZSk7XG5cblx0ICAgIHJldHVybiBzZWxmLm1wJHN1YnNjcmlwdChrZXkpO1xuXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBQeXRob24gd3JhcHBlciBvZiBgX19hZGRfX2AgbWV0aG9kLlxuXHQgKlxuXHQgKiBAbmFtZSAgX19hZGRfX1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlck9mIFNrLmJ1aWx0aW4uc2VxdHlwZS5wcm90b3R5cGVcblx0ICovXG5cdFNrLmJ1aWx0aW4uc2VxdHlwZS5wcm90b3R5cGVbXCJfX2FkZF9fXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgb3RoZXIpIHtcblxuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcIl9fYWRkX19cIiwgYXJndW1lbnRzLCAxLCAxLCBmYWxzZSwgdHJ1ZSk7XG5cblx0ICAgIHJldHVybiBzZWxmLnNxJGNvbmNhdChvdGhlcik7XG5cblx0fSk7XG5cblx0LyoqXG5cdCAqIFB5dGhvbiB3cmFwcGVyIG9mIGBfX211bF9fYCBtZXRob2QuXG5cdCAqXG5cdCAqIEBuYW1lICBfX211bF9fXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyT2YgU2suYnVpbHRpbi5zZXF0eXBlLnByb3RvdHlwZVxuXHQgKi9cblx0U2suYnVpbHRpbi5zZXF0eXBlLnByb3RvdHlwZVtcIl9fbXVsX19cIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCBuKSB7XG5cblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX211bF9fXCIsIGFyZ3VtZW50cywgMSwgMSwgZmFsc2UsIHRydWUpO1xuXG5cdCAgICBpZiAoIVNrLm1pc2NldmFsLmlzSW5kZXgobikpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBtdWx0aXBseSBzZXF1ZW5jZSBieSBub24taW50IG9mIHR5cGUgJ1wiICsgU2suYWJzdHIudHlwZU5hbWUobikgKyBcIidcIik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzZWxmLnNxJHJlcGVhdChuKTtcblxuXHR9KTtcblxuXHQvKipcblx0ICogUHl0aG9uIHdyYXBwZXIgb2YgYF9fcm11bF9fYCBtZXRob2QuXG5cdCAqXG5cdCAqIEBuYW1lICBfX3JtdWxfX1xuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlck9mIFNrLmJ1aWx0aW4uc2VxdHlwZS5wcm90b3R5cGVcblx0ICovXG5cdFNrLmJ1aWx0aW4uc2VxdHlwZS5wcm90b3R5cGVbXCJfX3JtdWxfX1wiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIG4pIHtcblxuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcIl9fcm11bF9fXCIsIGFyZ3VtZW50cywgMSwgMSwgZmFsc2UsIHRydWUpO1xuXG5cdCAgICByZXR1cm4gc2VsZi5zcSRyZXBlYXQobik7ICAgIFxuXG5cdH0pO1xuXG5cblxuXHQvKiAtLS0tIC9Vc2Vycy9yb2Ivc2t1bHB0eS9saWIvLi4vbm9kZV9tb2R1bGVzL3NrdWxwdC9zcmMvc3RyLmpzIC0tLS0gKi8gXG5cblx0U2suYnVpbHRpbi5pbnRlcm5lZCA9IHt9O1xuXG5cdC8qKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHsqfSB4XG5cdCAqIEBleHRlbmRzIFNrLmJ1aWx0aW4ub2JqZWN0XG5cdCAqL1xuXHRTay5idWlsdGluLnN0ciA9IGZ1bmN0aW9uICh4KSB7XG5cdCAgICB2YXIgcmV0O1xuXHQgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHggPSBcIlwiO1xuXHQgICAgfVxuXHQgICAgaWYgKHggaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cikge1xuXHQgICAgICAgIHJldHVybiB4O1xuXHQgICAgfVxuXHQgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoeCk7XG5cdCAgICB9XG5cblxuXHQgICAgLy8gY29udmVydCB0byBqcyBzdHJpbmdcblx0ICAgIGlmICh4ID09PSB0cnVlKSB7XG5cdCAgICAgICAgcmV0ID0gXCJUcnVlXCI7XG5cdCAgICB9IGVsc2UgaWYgKHggPT09IGZhbHNlKSB7XG5cdCAgICAgICAgcmV0ID0gXCJGYWxzZVwiO1xuXHQgICAgfSBlbHNlIGlmICgoeCA9PT0gbnVsbCkgfHwgKHggaW5zdGFuY2VvZiBTay5idWlsdGluLm5vbmUpKSB7XG5cdCAgICAgICAgcmV0ID0gXCJOb25lXCI7XG5cdCAgICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBTay5idWlsdGluLmJvb2wpIHtcblx0ICAgICAgICBpZiAoeC52KSB7XG5cdCAgICAgICAgICAgIHJldCA9IFwiVHJ1ZVwiO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldCA9IFwiRmFsc2VcIjtcblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgcmV0ID0geC50b1N0cmluZygpO1xuXHQgICAgICAgIGlmIChyZXQgPT09IFwiSW5maW5pdHlcIikge1xuXHQgICAgICAgICAgICByZXQgPSBcImluZlwiO1xuXHQgICAgICAgIH0gZWxzZSBpZiAocmV0ID09PSBcIi1JbmZpbml0eVwiKSB7XG5cdCAgICAgICAgICAgIHJldCA9IFwiLWluZlwiO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICByZXQgPSB4O1xuXHQgICAgfSBlbHNlIGlmICh4LnRwJHN0ciAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0ID0geC50cCRzdHIoKTtcblx0ICAgICAgICBpZiAoIShyZXQgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cikpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIl9fc3RyX18gZGlkbid0IHJldHVybiBhIHN0clwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIFNrLm1pc2NldmFsLm9iamVjdFJlcHIoeCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIGludGVybmluZyByZXF1aXJlZCBmb3Igc3RyaW5ncyBpbiBweVxuXHQgICAgaWYgKFNrLmJ1aWx0aW4uaW50ZXJuZWRbXCIxXCIgKyByZXRdKSB7XG5cdCAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4uaW50ZXJuZWRbXCIxXCIgKyByZXRdO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9fY2xhc3NfXyA9IFNrLmJ1aWx0aW4uc3RyO1xuXHQgICAgdGhpcy52ID0gcmV0O1xuXHQgICAgdGhpc1tcInZcIl0gPSB0aGlzLnY7XG5cdCAgICBTay5idWlsdGluLmludGVybmVkW1wiMVwiICsgcmV0XSA9IHRoaXM7XG5cdCAgICByZXR1cm4gdGhpcztcblxuXHR9O1xuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uc3RyXCIsIFNrLmJ1aWx0aW4uc3RyKTtcblxuXHRTay5hYnN0ci5zZXRVcEluaGVyaXRhbmNlKFwic3RyXCIsIFNrLmJ1aWx0aW4uc3RyLCBTay5idWlsdGluLnNlcXR5cGUpO1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5tcCRzdWJzY3JpcHQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0ICAgIHZhciByZXQ7XG5cdCAgICBpZiAoU2subWlzY2V2YWwuaXNJbmRleChpbmRleCkpIHtcblx0ICAgICAgICBpbmRleCA9IFNrLm1pc2NldmFsLmFzSW5kZXgoaW5kZXgpO1xuXHQgICAgICAgIGlmIChpbmRleCA8IDApIHtcblx0ICAgICAgICAgICAgaW5kZXggPSB0aGlzLnYubGVuZ3RoICsgaW5kZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy52Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5JbmRleEVycm9yKFwic3RyaW5nIGluZGV4IG91dCBvZiByYW5nZVwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYuY2hhckF0KGluZGV4KSk7XG5cdCAgICB9IGVsc2UgaWYgKGluZGV4IGluc3RhbmNlb2YgU2suYnVpbHRpbi5zbGljZSkge1xuXHQgICAgICAgIHJldCA9IFwiXCI7XG5cdCAgICAgICAgaW5kZXguc3NzaXRlciQodGhpcywgZnVuY3Rpb24gKGksIHdydCkge1xuXHQgICAgICAgICAgICBpZiAoaSA+PSAwICYmIGkgPCB3cnQudi5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHJldCArPSB3cnQudi5jaGFyQXQoaSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHJldCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInN0cmluZyBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMsIG5vdCBcIiArIFNrLmFic3RyLnR5cGVOYW1lKGluZGV4KSk7XG5cdCAgICB9XG5cdH07XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlLnNxJGxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLnYubGVuZ3RoO1xuXHR9O1xuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGUuc3EkY29uY2F0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICB2YXIgb3R5cGVuYW1lO1xuXHQgICAgaWYgKCFvdGhlciB8fCAhU2suYnVpbHRpbi5jaGVja1N0cmluZyhvdGhlcikpIHtcblx0ICAgICAgICBvdHlwZW5hbWUgPSBTay5hYnN0ci50eXBlTmFtZShvdGhlcik7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2Fubm90IGNvbmNhdGVuYXRlICdzdHInIGFuZCAnXCIgKyBvdHlwZW5hbWUgKyBcIicgb2JqZWN0c1wiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52ICsgb3RoZXIudik7XG5cdH07XG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5uYiRhZGQgPSBTay5idWlsdGluLnN0ci5wcm90b3R5cGUuc3EkY29uY2F0O1xuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGUubmIkaW5wbGFjZV9hZGQgPSBTay5idWlsdGluLnN0ci5wcm90b3R5cGUuc3EkY29uY2F0O1xuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGUuc3EkcmVwZWF0ID0gZnVuY3Rpb24gKG4pIHtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIHJldDtcblxuXHQgICAgaWYgKCFTay5taXNjZXZhbC5pc0luZGV4KG4pKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgbXVsdGlwbHkgc2VxdWVuY2UgYnkgbm9uLWludCBvZiB0eXBlICdcIiArIFNrLmFic3RyLnR5cGVOYW1lKG4pICsgXCInXCIpO1xuXHQgICAgfVxuXG5cdCAgICBuID0gU2subWlzY2V2YWwuYXNJbmRleChuKTtcblx0ICAgIHJldCA9IFwiXCI7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG5cdCAgICAgICAgcmV0ICs9IHRoaXMudjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIocmV0KTtcblx0fTtcblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlLm5iJG11bHRpcGx5ID0gU2suYnVpbHRpbi5zdHIucHJvdG90eXBlLnNxJHJlcGVhdDtcblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlLm5iJGlucGxhY2VfbXVsdGlwbHkgPSBTay5idWlsdGluLnN0ci5wcm90b3R5cGUuc3EkcmVwZWF0O1xuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGUuc3EkaXRlbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5mYWlsKCk7XG5cdH07XG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5zcSRzbGljZSA9IGZ1bmN0aW9uIChpMSwgaTIpIHtcblx0ICAgIGkxID0gU2suYnVpbHRpbi5hc251bSQoaTEpO1xuXHQgICAgaTIgPSBTay5idWlsdGluLmFzbnVtJChpMik7XG5cdCAgICBpZiAoaTEgPCAwKSB7XG5cdCAgICAgICAgaTEgPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYuc3Vic3RyKGkxLCBpMiAtIGkxKSk7XG5cdH07XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlLnNxJGNvbnRhaW5zID0gZnVuY3Rpb24gKG9iKSB7XG5cdCAgICBpZiAoIShvYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIlR5cGVFcnJvcjogJ0luIDxzdHJpbmc+IHJlcXVpcmVzIHN0cmluZyBhcyBsZWZ0IG9wZXJhbmRcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy52LmluZGV4T2Yob2IudikgIT0gLTE7XG5cdH07XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlLl9faXRlcl9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZikge1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cl9pdGVyXyhzZWxmKTtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlLnRwJGl0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyX2l0ZXJfKHRoaXMpO1xuXHR9O1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS50cCRyaWNoY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlciwgb3ApIHtcblx0ICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIpKSB7XG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblxuXHQgICAgc3dpdGNoIChvcCkge1xuXHQgICAgICAgIGNhc2UgXCJMdFwiOlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy52IDwgb3RoZXIudjtcblx0ICAgICAgICBjYXNlIFwiTHRFXCI6XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnYgPD0gb3RoZXIudjtcblx0ICAgICAgICBjYXNlIFwiRXFcIjpcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudiA9PT0gb3RoZXIudjtcblx0ICAgICAgICBjYXNlIFwiTm90RXFcIjpcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudiAhPT0gb3RoZXIudjtcblx0ICAgICAgICBjYXNlIFwiR3RcIjpcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudiA+IG90aGVyLnY7XG5cdCAgICAgICAgY2FzZSBcIkd0RVwiOlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy52ID49IG90aGVyLnY7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgZ29vZy5hc3NlcnRzLmZhaWwoKTtcblx0ICAgIH1cblx0fTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCIkclwiXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIHNpbmdsZSBpcyBwcmVmZXJyZWRcblx0ICAgIHZhciBhc2hleDtcblx0ICAgIHZhciBjO1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgcmV0O1xuXHQgICAgdmFyIGxlbjtcblx0ICAgIHZhciBxdW90ZSA9IFwiJ1wiO1xuXHQgICAgLy9qc2hpbnQgaWdub3JlOnN0YXJ0XG5cdCAgICBpZiAodGhpcy52LmluZGV4T2YoXCInXCIpICE9PSAtMSAmJiB0aGlzLnYuaW5kZXhPZignXCInKSA9PT0gLTEpIHtcblx0ICAgICAgICBxdW90ZSA9ICdcIic7XG5cdCAgICB9XG5cdCAgICAvL2pzaGludCBpZ25vcmU6ZW5kXG5cdCAgICBsZW4gPSB0aGlzLnYubGVuZ3RoO1xuXHQgICAgcmV0ID0gcXVvdGU7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgICAgICBjID0gdGhpcy52LmNoYXJBdChpKTtcblx0ICAgICAgICBpZiAoYyA9PT0gcXVvdGUgfHwgYyA9PT0gXCJcXFxcXCIpIHtcblx0ICAgICAgICAgICAgcmV0ICs9IFwiXFxcXFwiICsgYztcblx0ICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiXFx0XCIpIHtcblx0ICAgICAgICAgICAgcmV0ICs9IFwiXFxcXHRcIjtcblx0ICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiXFxuXCIpIHtcblx0ICAgICAgICAgICAgcmV0ICs9IFwiXFxcXG5cIjtcblx0ICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiXFxyXCIpIHtcblx0ICAgICAgICAgICAgcmV0ICs9IFwiXFxcXHJcIjtcblx0ICAgICAgICB9IGVsc2UgaWYgKGMgPCBcIiBcIiB8fCBjID49IDB4N2YpIHtcblx0ICAgICAgICAgICAgYXNoZXggPSBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuXHQgICAgICAgICAgICBpZiAoYXNoZXgubGVuZ3RoIDwgMikge1xuXHQgICAgICAgICAgICAgICAgYXNoZXggPSBcIjBcIiArIGFzaGV4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldCArPSBcIlxcXFx4XCIgKyBhc2hleDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXQgKz0gYztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXQgKz0gcXVvdGU7XG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHJldCk7XG5cdH07XG5cblxuXHRTay5idWlsdGluLnN0ci5yZV9lc2NhcGVfID0gZnVuY3Rpb24gKHMpIHtcblx0ICAgIHZhciBjO1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgcmV0ID0gW107XG5cdCAgICB2YXIgcmUgPSAvXltBLVphLXowLTldKyQvO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICBjID0gcy5jaGFyQXQoaSk7XG5cblx0ICAgICAgICBpZiAocmUudGVzdChjKSkge1xuXHQgICAgICAgICAgICByZXQucHVzaChjKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAoYyA9PT0gXCJcXFxcMDAwXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldC5wdXNoKFwiXFxcXDAwMFwiKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldC5wdXNoKFwiXFxcXFwiICsgYyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmV0LmpvaW4oXCJcIik7XG5cdH07XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wibG93ZXJcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmKSB7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwibG93ZXJcIiwgYXJndW1lbnRzLCAxLCAxKTtcblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoc2VsZi52LnRvTG93ZXJDYXNlKCkpO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJ1cHBlclwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYpIHtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJ1cHBlclwiLCBhcmd1bWVudHMsIDEsIDEpO1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihzZWxmLnYudG9VcHBlckNhc2UoKSk7XG5cdH0pO1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZVtcImNhcGl0YWxpemVcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmKSB7XG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciBjYXA7XG5cdCAgICB2YXIgb3JpZztcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJjYXBpdGFsaXplXCIsIGFyZ3VtZW50cywgMSwgMSk7XG5cdCAgICBvcmlnID0gc2VsZi52O1xuXG5cdCAgICBpZiAob3JpZy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIpO1xuXHQgICAgfVxuXHQgICAgY2FwID0gb3JpZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcblxuXHQgICAgZm9yIChpID0gMTsgaSA8IG9yaWcubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBjYXAgKz0gb3JpZy5jaGFyQXQoaSkudG9Mb3dlckNhc2UoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoY2FwKTtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wiam9pblwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIHNlcSkge1xuXHQgICAgdmFyIGl0LCBpO1xuXHQgICAgdmFyIGFyck9mU3Rycztcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJqb2luXCIsIGFyZ3VtZW50cywgMiwgMik7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwic2VxXCIsIFwiaXRlcmFibGVcIiwgU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKHNlcSkpO1xuXHQgICAgYXJyT2ZTdHJzID0gW107XG5cdCAgICBmb3IgKGl0ID0gc2VxLnRwJGl0ZXIoKSwgaSA9IGl0LnRwJGl0ZXJuZXh0KCk7IGkgIT09IHVuZGVmaW5lZDsgaSA9IGl0LnRwJGl0ZXJuZXh0KCkpIHtcblx0ICAgICAgICBpZiAoaS5jb25zdHJ1Y3RvciAhPT0gU2suYnVpbHRpbi5zdHIpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiVHlwZUVycm9yOiBzZXF1ZW5jZSBpdGVtIFwiICsgYXJyT2ZTdHJzLmxlbmd0aCArIFwiOiBleHBlY3RlZCBzdHJpbmcsIFwiICsgdHlwZW9mIGkgKyBcIiBmb3VuZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYXJyT2ZTdHJzLnB1c2goaS52KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYXJyT2ZTdHJzLmpvaW4oc2VsZi52KSk7XG5cdH0pO1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZVtcInNwbGl0XCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgb24sIGhvd21hbnkpIHtcblx0ICAgIHZhciBzcGxpdHM7XG5cdCAgICB2YXIgaW5kZXg7XG5cdCAgICB2YXIgbWF0Y2g7XG5cdCAgICB2YXIgcmVzdWx0O1xuXHQgICAgdmFyIHM7XG5cdCAgICB2YXIgc3RyO1xuXHQgICAgdmFyIHJlZ2V4O1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInNwbGl0XCIsIGFyZ3VtZW50cywgMSwgMyk7XG5cdCAgICBpZiAoKG9uID09PSB1bmRlZmluZWQpIHx8IChvbiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubm9uZSkpIHtcblx0ICAgICAgICBvbiA9IG51bGw7XG5cdCAgICB9XG5cdCAgICBpZiAoKG9uICE9PSBudWxsKSAmJiAhU2suYnVpbHRpbi5jaGVja1N0cmluZyhvbikpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJleHBlY3RlZCBhIHN0cmluZ1wiKTtcblx0ICAgIH1cblx0ICAgIGlmICgob24gIT09IG51bGwpICYmIG9uLnYgPT09IFwiXCIpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiZW1wdHkgc2VwYXJhdG9yXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKChob3dtYW55ICE9PSB1bmRlZmluZWQpICYmICFTay5idWlsdGluLmNoZWNrSW50KGhvd21hbnkpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZFwiKTtcblx0ICAgIH1cblxuXHQgICAgaG93bWFueSA9IFNrLmJ1aWx0aW4uYXNudW0kKGhvd21hbnkpO1xuXHQgICAgcmVnZXggPSAvW1xcc10rL2c7XG5cdCAgICBzdHIgPSBzZWxmLnY7XG5cdCAgICBpZiAob24gPT09IG51bGwpIHtcblx0ICAgICAgICBzdHIgPSBnb29nLnN0cmluZy50cmltTGVmdChzdHIpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIFwib25cIiBzbyB3ZSBjYW4gdXNlIGEgcmVnZXhwXG5cdCAgICAgICAgcyA9IG9uLnYucmVwbGFjZSgvKFsuKis/PXxcXFxcXFwvKClcXFtcXF1cXHtcXH1eJF0pL2csIFwiXFxcXCQxXCIpO1xuXHQgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChzLCBcImdcIik7XG5cdCAgICB9XG5cblx0ICAgIC8vIFRoaXMgaXMgYWxtb3N0IGlkZW50aWNhbCB0byByZS5zcGxpdCxcblx0ICAgIC8vIGV4Y2VwdCBob3cgdGhlIHJlZ2V4cCBpcyBjb25zdHJ1Y3RlZFxuXG5cdCAgICByZXN1bHQgPSBbXTtcblx0ICAgIGluZGV4ID0gMDtcblx0ICAgIHNwbGl0cyA9IDA7XG5cdCAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhzdHIpKSAhPSBudWxsKSB7XG5cdCAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSByZWdleC5sYXN0SW5kZXgpIHtcblx0ICAgICAgICAgICAgLy8gZW1wdHkgbWF0Y2hcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTay5idWlsdGluLnN0cihzdHIuc3Vic3RyaW5nKGluZGV4LCBtYXRjaC5pbmRleCkpKTtcblx0ICAgICAgICBpbmRleCA9IHJlZ2V4Lmxhc3RJbmRleDtcblx0ICAgICAgICBzcGxpdHMgKz0gMTtcblx0ICAgICAgICBpZiAoaG93bWFueSAmJiAoc3BsaXRzID49IGhvd21hbnkpKSB7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoaW5kZXgpO1xuXHQgICAgaWYgKG9uICE9PSBudWxsIHx8IChzdHIubGVuZ3RoID4gMCkpIHtcblx0ICAgICAgICByZXN1bHQucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoc3RyKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHJlc3VsdCk7XG5cdH0pO1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZVtcInN0cmlwXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgY2hhcnMpIHtcblx0ICAgIHZhciByZWdleDtcblx0ICAgIHZhciBwYXR0ZXJuO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInN0cmlwXCIsIGFyZ3VtZW50cywgMSwgMik7XG5cdCAgICBpZiAoKGNoYXJzICE9PSB1bmRlZmluZWQpICYmICFTay5idWlsdGluLmNoZWNrU3RyaW5nKGNoYXJzKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInN0cmlwIGFyZyBtdXN0IGJlIE5vbmUgb3Igc3RyXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKGNoYXJzID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBwYXR0ZXJuID0gL15cXHMrfFxccyskL2c7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlZ2V4ID0gU2suYnVpbHRpbi5zdHIucmVfZXNjYXBlXyhjaGFycy52KTtcblx0ICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl5bXCIgKyByZWdleCArIFwiXSt8W1wiICsgcmVnZXggKyBcIl0rJFwiLCBcImdcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHNlbGYudi5yZXBsYWNlKHBhdHRlcm4sIFwiXCIpKTtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wibHN0cmlwXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgY2hhcnMpIHtcblx0ICAgIHZhciByZWdleDtcblx0ICAgIHZhciBwYXR0ZXJuO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImxzdHJpcFwiLCBhcmd1bWVudHMsIDEsIDIpO1xuXHQgICAgaWYgKChjaGFycyAhPT0gdW5kZWZpbmVkKSAmJiAhU2suYnVpbHRpbi5jaGVja1N0cmluZyhjaGFycykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJsc3RyaXAgYXJnIG11c3QgYmUgTm9uZSBvciBzdHJcIik7XG5cdCAgICB9XG5cdCAgICBpZiAoY2hhcnMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHBhdHRlcm4gPSAvXlxccysvZztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmVnZXggPSBTay5idWlsdGluLnN0ci5yZV9lc2NhcGVfKGNoYXJzLnYpO1xuXHQgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXltcIiArIHJlZ2V4ICsgXCJdK1wiLCBcImdcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHNlbGYudi5yZXBsYWNlKHBhdHRlcm4sIFwiXCIpKTtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wicnN0cmlwXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgY2hhcnMpIHtcblx0ICAgIHZhciByZWdleDtcblx0ICAgIHZhciBwYXR0ZXJuO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInJzdHJpcFwiLCBhcmd1bWVudHMsIDEsIDIpO1xuXHQgICAgaWYgKChjaGFycyAhPT0gdW5kZWZpbmVkKSAmJiAhU2suYnVpbHRpbi5jaGVja1N0cmluZyhjaGFycykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJyc3RyaXAgYXJnIG11c3QgYmUgTm9uZSBvciBzdHJcIik7XG5cdCAgICB9XG5cdCAgICBpZiAoY2hhcnMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHBhdHRlcm4gPSAvXFxzKyQvZztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmVnZXggPSBTay5idWlsdGluLnN0ci5yZV9lc2NhcGVfKGNoYXJzLnYpO1xuXHQgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiW1wiICsgcmVnZXggKyBcIl0rJFwiLCBcImdcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHNlbGYudi5yZXBsYWNlKHBhdHRlcm4sIFwiXCIpKTtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wicGFydGl0aW9uXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgc2VwKSB7XG5cdCAgICB2YXIgcG9zO1xuXHQgICAgdmFyIHNlcFN0cjtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJwYXJ0aXRpb25cIiwgYXJndW1lbnRzLCAyLCAyKTtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJzZXBcIiwgXCJzdHJpbmdcIiwgU2suYnVpbHRpbi5jaGVja1N0cmluZyhzZXApKTtcblx0ICAgIHNlcFN0ciA9IG5ldyBTay5idWlsdGluLnN0cihzZXApO1xuXHQgICAgcG9zID0gc2VsZi52LmluZGV4T2Yoc2VwU3RyLnYpO1xuXHQgICAgaWYgKHBvcyA8IDApIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW3NlbGYsIFNrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0ciwgU2suYnVpbHRpbi5zdHIuJGVtcHR5c3RyXSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbXG5cdCAgICAgICAgbmV3IFNrLmJ1aWx0aW4uc3RyKHNlbGYudi5zdWJzdHJpbmcoMCwgcG9zKSksXG5cdCAgICAgICAgc2VwU3RyLFxuXHQgICAgICAgIG5ldyBTay5idWlsdGluLnN0cihzZWxmLnYuc3Vic3RyaW5nKHBvcyArIHNlcFN0ci52Lmxlbmd0aCkpXSk7XG5cdH0pO1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZVtcInJwYXJ0aXRpb25cIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCBzZXApIHtcblx0ICAgIHZhciBwb3M7XG5cdCAgICB2YXIgc2VwU3RyO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInJwYXJ0aXRpb25cIiwgYXJndW1lbnRzLCAyLCAyKTtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJzZXBcIiwgXCJzdHJpbmdcIiwgU2suYnVpbHRpbi5jaGVja1N0cmluZyhzZXApKTtcblx0ICAgIHNlcFN0ciA9IG5ldyBTay5idWlsdGluLnN0cihzZXApO1xuXHQgICAgcG9zID0gc2VsZi52Lmxhc3RJbmRleE9mKHNlcFN0ci52KTtcblx0ICAgIGlmIChwb3MgPCAwKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtTay5idWlsdGluLnN0ci4kZW1wdHlzdHIsIFNrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0ciwgc2VsZl0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW1xuXHQgICAgICAgIG5ldyBTay5idWlsdGluLnN0cihzZWxmLnYuc3Vic3RyaW5nKDAsIHBvcykpLFxuXHQgICAgICAgIHNlcFN0cixcblx0ICAgICAgICBuZXcgU2suYnVpbHRpbi5zdHIoc2VsZi52LnN1YnN0cmluZyhwb3MgKyBzZXBTdHIudi5sZW5ndGgpKV0pO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJjb3VudFwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIHBhdCwgc3RhcnQsIGVuZCkge1xuXHQgICAgdmFyIG5vcm1hbHRleHQ7XG5cdCAgICB2YXIgY3RsO1xuXHQgICAgdmFyIHNsaWNlO1xuXHQgICAgdmFyIG07XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiY291bnRcIiwgYXJndW1lbnRzLCAyLCA0KTtcblx0ICAgIGlmICghU2suYnVpbHRpbi5jaGVja1N0cmluZyhwYXQpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZXhwZWN0ZWQgYSBjaGFyYWN0ZXIgYnVmZmVyIG9iamVjdFwiKTtcblx0ICAgIH1cblx0ICAgIGlmICgoc3RhcnQgIT09IHVuZGVmaW5lZCkgJiYgIVNrLmJ1aWx0aW4uY2hlY2tJbnQoc3RhcnQpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic2xpY2UgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIE5vbmUgb3IgaGF2ZSBhbiBfX2luZGV4X18gbWV0aG9kXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKChlbmQgIT09IHVuZGVmaW5lZCkgJiYgIVNrLmJ1aWx0aW4uY2hlY2tJbnQoZW5kKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNsaWNlIGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBOb25lIG9yIGhhdmUgYW4gX19pbmRleF9fIG1ldGhvZFwiKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBzdGFydCA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN0YXJ0ID0gU2suYnVpbHRpbi5hc251bSQoc3RhcnQpO1xuXHQgICAgICAgIHN0YXJ0ID0gc3RhcnQgPj0gMCA/IHN0YXJ0IDogc2VsZi52Lmxlbmd0aCArIHN0YXJ0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBlbmQgPSBzZWxmLnYubGVuZ3RoO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBlbmQgPSBTay5idWlsdGluLmFzbnVtJChlbmQpO1xuXHQgICAgICAgIGVuZCA9IGVuZCA+PSAwID8gZW5kIDogc2VsZi52Lmxlbmd0aCArIGVuZDtcblx0ICAgIH1cblxuXHQgICAgbm9ybWFsdGV4dCA9IHBhdC52LnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcblx0ICAgIG0gPSBuZXcgUmVnRXhwKG5vcm1hbHRleHQsIFwiZ1wiKTtcblx0ICAgIHNsaWNlID0gc2VsZi52LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXHQgICAgY3RsID0gc2xpY2UubWF0Y2gobSk7XG5cdCAgICBpZiAoIWN0bCkge1xuXHQgICAgICAgIHJldHVybiAgbmV3IFNrLmJ1aWx0aW4uaW50XygwKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oY3RsLmxlbmd0aCk7XG5cdCAgICB9XG5cblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wibGp1c3RcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCBsZW4sIGZpbGxjaGFyKSB7XG5cdCAgICB2YXIgbmV3c3RyO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImxqdXN0XCIsIGFyZ3VtZW50cywgMiwgMyk7XG5cdCAgICBpZiAoIVNrLmJ1aWx0aW4uY2hlY2tJbnQobGVuKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImludGVnZXIgYXJndW1lbnQgZXhlcGN0ZWQsIGdvdCBcIiArIFNrLmFic3RyLnR5cGVOYW1lKGxlbikpO1xuXHQgICAgfVxuXHQgICAgaWYgKChmaWxsY2hhciAhPT0gdW5kZWZpbmVkKSAmJiAoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZmlsbGNoYXIpIHx8IGZpbGxjaGFyLnYubGVuZ3RoICE9PSAxKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm11c3QgYmUgY2hhciwgbm90IFwiICsgU2suYWJzdHIudHlwZU5hbWUoZmlsbGNoYXIpKTtcblx0ICAgIH1cblx0ICAgIGlmIChmaWxsY2hhciA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgZmlsbGNoYXIgPSBcIiBcIjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZmlsbGNoYXIgPSBmaWxsY2hhci52O1xuXHQgICAgfVxuXHQgICAgbGVuID0gU2suYnVpbHRpbi5hc251bSQobGVuKTtcblx0ICAgIGlmIChzZWxmLnYubGVuZ3RoID49IGxlbikge1xuXHQgICAgICAgIHJldHVybiBzZWxmO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBuZXdzdHIgPSBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKHtsZW5ndGg6IE1hdGguZmxvb3IobGVuIC0gc2VsZi52Lmxlbmd0aCkgKyAxfSwgZmlsbGNoYXIpO1xuXHQgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoc2VsZi52ICsgbmV3c3RyKTtcblx0ICAgIH1cblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wicmp1c3RcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCBsZW4sIGZpbGxjaGFyKSB7XG5cdCAgICB2YXIgbmV3c3RyO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInJqdXN0XCIsIGFyZ3VtZW50cywgMiwgMyk7XG5cdCAgICBpZiAoIVNrLmJ1aWx0aW4uY2hlY2tJbnQobGVuKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImludGVnZXIgYXJndW1lbnQgZXhlcGN0ZWQsIGdvdCBcIiArIFNrLmFic3RyLnR5cGVOYW1lKGxlbikpO1xuXHQgICAgfVxuXHQgICAgaWYgKChmaWxsY2hhciAhPT0gdW5kZWZpbmVkKSAmJiAoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZmlsbGNoYXIpIHx8IGZpbGxjaGFyLnYubGVuZ3RoICE9PSAxKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm11c3QgYmUgY2hhciwgbm90IFwiICsgU2suYWJzdHIudHlwZU5hbWUoZmlsbGNoYXIpKTtcblx0ICAgIH1cblx0ICAgIGlmIChmaWxsY2hhciA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgZmlsbGNoYXIgPSBcIiBcIjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZmlsbGNoYXIgPSBmaWxsY2hhci52O1xuXHQgICAgfVxuXHQgICAgbGVuID0gU2suYnVpbHRpbi5hc251bSQobGVuKTtcblx0ICAgIGlmIChzZWxmLnYubGVuZ3RoID49IGxlbikge1xuXHQgICAgICAgIHJldHVybiBzZWxmO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBuZXdzdHIgPSBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKHtsZW5ndGg6IE1hdGguZmxvb3IobGVuIC0gc2VsZi52Lmxlbmd0aCkgKyAxfSwgZmlsbGNoYXIpO1xuXHQgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIobmV3c3RyICsgc2VsZi52KTtcblx0ICAgIH1cblxuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJjZW50ZXJcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCBsZW4sIGZpbGxjaGFyKSB7XG5cdCAgICB2YXIgbmV3c3RyO1xuXHQgICAgdmFyIG5ld3N0cjE7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiY2VudGVyXCIsIGFyZ3VtZW50cywgMiwgMyk7XG5cdCAgICBpZiAoIVNrLmJ1aWx0aW4uY2hlY2tJbnQobGVuKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImludGVnZXIgYXJndW1lbnQgZXhlcGN0ZWQsIGdvdCBcIiArIFNrLmFic3RyLnR5cGVOYW1lKGxlbikpO1xuXHQgICAgfVxuXHQgICAgaWYgKChmaWxsY2hhciAhPT0gdW5kZWZpbmVkKSAmJiAoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZmlsbGNoYXIpIHx8IGZpbGxjaGFyLnYubGVuZ3RoICE9PSAxKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm11c3QgYmUgY2hhciwgbm90IFwiICsgU2suYWJzdHIudHlwZU5hbWUoZmlsbGNoYXIpKTtcblx0ICAgIH1cblx0ICAgIGlmIChmaWxsY2hhciA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgZmlsbGNoYXIgPSBcIiBcIjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZmlsbGNoYXIgPSBmaWxsY2hhci52O1xuXHQgICAgfVxuXHQgICAgbGVuID0gU2suYnVpbHRpbi5hc251bSQobGVuKTtcblx0ICAgIGlmIChzZWxmLnYubGVuZ3RoID49IGxlbikge1xuXHQgICAgICAgIHJldHVybiBzZWxmO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBuZXdzdHIxID0gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbCh7bGVuZ3RoOiBNYXRoLmZsb29yKChsZW4gLSBzZWxmLnYubGVuZ3RoKSAvIDIpICsgMX0sIGZpbGxjaGFyKTtcblx0ICAgICAgICBuZXdzdHIgPSBuZXdzdHIxICsgc2VsZi52ICsgbmV3c3RyMTtcblx0ICAgICAgICBpZiAobmV3c3RyLmxlbmd0aCA8IGxlbikge1xuXHQgICAgICAgICAgICBuZXdzdHIgPSBuZXdzdHIgKyBmaWxsY2hhcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihuZXdzdHIpO1xuXHQgICAgfVxuXG5cdH0pO1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZVtcImZpbmRcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCB0Z3QsIHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciBpZHg7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZmluZFwiLCBhcmd1bWVudHMsIDIsIDQpO1xuXHQgICAgaWYgKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHRndCkpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJleHBlY3RlZCBhIGNoYXJhY3RlciBidWZmZXIgb2JqZWN0XCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKChzdGFydCAhPT0gdW5kZWZpbmVkKSAmJiAhU2suYnVpbHRpbi5jaGVja0ludChzdGFydCkpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgTm9uZSBvciBoYXZlIGFuIF9faW5kZXhfXyBtZXRob2RcIik7XG5cdCAgICB9XG5cdCAgICBpZiAoKGVuZCAhPT0gdW5kZWZpbmVkKSAmJiAhU2suYnVpbHRpbi5jaGVja0ludChlbmQpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic2xpY2UgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIE5vbmUgb3IgaGF2ZSBhbiBfX2luZGV4X18gbWV0aG9kXCIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHN0YXJ0ID0gMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgc3RhcnQgPSBTay5idWlsdGluLmFzbnVtJChzdGFydCk7XG5cdCAgICAgICAgc3RhcnQgPSBzdGFydCA+PSAwID8gc3RhcnQgOiBzZWxmLnYubGVuZ3RoICsgc3RhcnQ7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGVuZCA9IHNlbGYudi5sZW5ndGg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVuZCA9IFNrLmJ1aWx0aW4uYXNudW0kKGVuZCk7XG5cdCAgICAgICAgZW5kID0gZW5kID49IDAgPyBlbmQgOiBzZWxmLnYubGVuZ3RoICsgZW5kO1xuXHQgICAgfVxuXG5cdCAgICBpZHggPSBzZWxmLnYuaW5kZXhPZih0Z3Qudiwgc3RhcnQpO1xuXHQgICAgaWR4ID0gKChpZHggPj0gc3RhcnQpICYmIChpZHggPCBlbmQpKSA/IGlkeCA6IC0xO1xuXG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhpZHgpO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJpbmRleFwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIHRndCwgc3RhcnQsIGVuZCkge1xuXHQgICAgdmFyIGlkeDtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJpbmRleFwiLCBhcmd1bWVudHMsIDIsIDQpO1xuXHQgICAgaWR4ID0gU2subWlzY2V2YWwuY2FsbHNpbShzZWxmW1wiZmluZFwiXSwgc2VsZiwgdGd0LCBzdGFydCwgZW5kKTtcblx0ICAgIGlmIChTay5idWlsdGluLmFzbnVtJChpZHgpID09PSAtMSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzdWJzdHJpbmcgbm90IGZvdW5kXCIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGlkeDtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wicmZpbmRcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCB0Z3QsIHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciBpZHg7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwicmZpbmRcIiwgYXJndW1lbnRzLCAyLCA0KTtcblx0ICAgIGlmICghU2suYnVpbHRpbi5jaGVja1N0cmluZyh0Z3QpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZXhwZWN0ZWQgYSBjaGFyYWN0ZXIgYnVmZmVyIG9iamVjdFwiKTtcblx0ICAgIH1cblx0ICAgIGlmICgoc3RhcnQgIT09IHVuZGVmaW5lZCkgJiYgIVNrLmJ1aWx0aW4uY2hlY2tJbnQoc3RhcnQpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic2xpY2UgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIE5vbmUgb3IgaGF2ZSBhbiBfX2luZGV4X18gbWV0aG9kXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKChlbmQgIT09IHVuZGVmaW5lZCkgJiYgIVNrLmJ1aWx0aW4uY2hlY2tJbnQoZW5kKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNsaWNlIGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBOb25lIG9yIGhhdmUgYW4gX19pbmRleF9fIG1ldGhvZFwiKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBzdGFydCA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN0YXJ0ID0gU2suYnVpbHRpbi5hc251bSQoc3RhcnQpO1xuXHQgICAgICAgIHN0YXJ0ID0gc3RhcnQgPj0gMCA/IHN0YXJ0IDogc2VsZi52Lmxlbmd0aCArIHN0YXJ0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBlbmQgPSBzZWxmLnYubGVuZ3RoO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBlbmQgPSBTay5idWlsdGluLmFzbnVtJChlbmQpO1xuXHQgICAgICAgIGVuZCA9IGVuZCA+PSAwID8gZW5kIDogc2VsZi52Lmxlbmd0aCArIGVuZDtcblx0ICAgIH1cblxuXHQgICAgaWR4ID0gc2VsZi52Lmxhc3RJbmRleE9mKHRndC52LCBlbmQpO1xuXHQgICAgaWR4ID0gKGlkeCAhPT0gZW5kKSA/IGlkeCA6IHNlbGYudi5sYXN0SW5kZXhPZih0Z3QudiwgZW5kIC0gMSk7XG5cdCAgICBpZHggPSAoKGlkeCA+PSBzdGFydCkgJiYgKGlkeCA8IGVuZCkpID8gaWR4IDogLTE7XG5cblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGlkeCk7XG5cdH0pO1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZVtcInJpbmRleFwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIHRndCwgc3RhcnQsIGVuZCkge1xuXHQgICAgdmFyIGlkeDtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJyaW5kZXhcIiwgYXJndW1lbnRzLCAyLCA0KTtcblx0ICAgIGlkeCA9IFNrLm1pc2NldmFsLmNhbGxzaW0oc2VsZltcInJmaW5kXCJdLCBzZWxmLCB0Z3QsIHN0YXJ0LCBlbmQpO1xuXHQgICAgaWYgKFNrLmJ1aWx0aW4uYXNudW0kKGlkeCkgPT09IC0xKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInN1YnN0cmluZyBub3QgZm91bmRcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gaWR4O1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJzdGFydHN3aXRoXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgdGd0KSB7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwic3RhcnRzd2l0aFwiLCBhcmd1bWVudHMsIDIsIDIpO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcInRndFwiLCBcInN0cmluZ1wiLCBTay5idWlsdGluLmNoZWNrU3RyaW5nKHRndCkpO1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woIHNlbGYudi5pbmRleE9mKHRndC52KSA9PT0gMCk7XG5cdH0pO1xuXG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjgwNjM0L2VuZHN3aXRoLWluLWphdmFzY3JpcHRcblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wiZW5kc3dpdGhcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCB0Z3QpIHtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJlbmRzd2l0aFwiLCBhcmd1bWVudHMsIDIsIDIpO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcInRndFwiLCBcInN0cmluZ1wiLCBTay5idWlsdGluLmNoZWNrU3RyaW5nKHRndCkpO1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woIHNlbGYudi5pbmRleE9mKHRndC52LCBzZWxmLnYubGVuZ3RoIC0gdGd0LnYubGVuZ3RoKSAhPT0gLTEpO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJyZXBsYWNlXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgb2xkUywgbmV3UywgY291bnQpIHtcblx0ICAgIHZhciBjO1xuXHQgICAgdmFyIHBhdHQ7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwicmVwbGFjZVwiLCBhcmd1bWVudHMsIDMsIDQpO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcIm9sZFNcIiwgXCJzdHJpbmdcIiwgU2suYnVpbHRpbi5jaGVja1N0cmluZyhvbGRTKSk7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwibmV3U1wiLCBcInN0cmluZ1wiLCBTay5idWlsdGluLmNoZWNrU3RyaW5nKG5ld1MpKTtcblx0ICAgIGlmICgoY291bnQgIT09IHVuZGVmaW5lZCkgJiYgIVNrLmJ1aWx0aW4uY2hlY2tJbnQoY291bnQpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaW50ZWdlciBhcmd1bWVudCBleHBlY3RlZCwgZ290IFwiICtcblx0ICAgICAgICAgICAgU2suYWJzdHIudHlwZU5hbWUoY291bnQpKTtcblx0ICAgIH1cblx0ICAgIGNvdW50ID0gU2suYnVpbHRpbi5hc251bSQoY291bnQpO1xuXHQgICAgcGF0dCA9IG5ldyBSZWdFeHAoU2suYnVpbHRpbi5zdHIucmVfZXNjYXBlXyhvbGRTLnYpLCBcImdcIik7XG5cblx0ICAgIGlmICgoY291bnQgPT09IHVuZGVmaW5lZCkgfHwgKGNvdW50IDwgMCkpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHNlbGYudi5yZXBsYWNlKHBhdHQsIG5ld1MudikpO1xuXHQgICAgfVxuXG5cdCAgICBjID0gMDtcblxuXHQgICAgZnVuY3Rpb24gcmVwbGFjZXIgKG1hdGNoKSB7XG5cdCAgICAgICAgYysrO1xuXHQgICAgICAgIGlmIChjIDw9IGNvdW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdTLnY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBtYXRjaDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihzZWxmLnYucmVwbGFjZShwYXR0LCByZXBsYWNlcikpO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJ6ZmlsbFwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIGxlbikge1xuXHQgICAgdmFyIHN0ciA9IHNlbGYudjtcblx0ICAgIHZhciByZXQ7XG5cdCAgICB2YXIgemVyb2VzO1xuXHQgICAgdmFyIG9mZnNldDtcblx0ICAgIHZhciBwYWQgPSBcIlwiO1xuXG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiemZpbGxcIiwgYXJndW1lbnRzLCAyLCAyKTtcblx0ICAgIGlmICghIFNrLmJ1aWx0aW4uY2hlY2tJbnQobGVuKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImludGVnZXIgYXJndW1lbnQgZXhlcGVjdGVkLCBnb3QgXCIgKyBTay5hYnN0ci50eXBlTmFtZShsZW4pKTtcblx0ICAgIH1cblxuXHQgICAgLy8gZmlndXJlIG91dCBob3cgbWFueSB6ZXJvZXMgYXJlIG5lZWRlZCB0byBtYWtlIHRoZSBwcm9wZXIgbGVuZ3RoXG5cdCAgICB6ZXJvZXMgPSBsZW4udiAtIHN0ci5sZW5ndGg7XG5cdCAgICAvLyBvZmZzZXQgYnkgMSBpZiB0aGVyZSBpcyBhICsvLSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcblx0ICAgIG9mZnNldCA9IChzdHJbMF0gPT09IFwiK1wiIHx8IHN0clswXSA9PT0gXCItXCIpID8gMSA6IDA7XG5cdCAgICBmb3IodmFyIGkgPSAwOyBpIDwgemVyb2VzOyBpKyspe1xuXHQgICAgICAgIHBhZCArPSBcIjBcIjtcblx0ICAgIH1cblx0ICAgIC8vIGNvbWJpbmUgdGhlIHN0cmluZyBhbmQgdGhlIHplcm9lc1xuXHQgICAgcmV0ID0gc3RyLnN1YnN0cigwLCBvZmZzZXQpICsgcGFkICsgc3RyLnN1YnN0cihvZmZzZXQpO1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihyZXQpO1xuXG5cblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wiaXNkaWdpdFwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYpIHtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJpc2RpZ2l0XCIsIGFyZ3VtZW50cywgMSwgMSk7XG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCggL15cXGQrJC8udGVzdChzZWxmLnYpKTtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wiaXNzcGFjZVwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYpIHtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJpc3NwYWNlXCIsIGFyZ3VtZW50cywgMSwgMSk7XG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCggL15cXHMrJC8udGVzdChzZWxmLnYpKTtcblx0fSk7XG5cblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJleHBhbmR0YWJzXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgdGFic2l6ZSkge1xuXHQgICAgLy8gdmFyIGlucHV0ID0gc2VsZi52O1xuXHQgICAgLy8gdmFyIGV4cGFuZGVkID0gXCJcIjtcblx0ICAgIC8vIHZhciBzcGxpdDtcblx0ICAgIC8vIHZhciBzcGFjZXN0ciA9IFwiXCI7XG5cdCAgICAvLyB2YXIgc3BhY2VyZW07XG5cblxuXHQgICAgdmFyIHNwYWNlcztcblx0ICAgIHZhciBleHBhbmRlZDtcblxuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImV4cGFuZHRhYnNcIiwgYXJndW1lbnRzLCAxLCAyKTtcblxuXG5cdCAgICBpZiAoKHRhYnNpemUgIT09IHVuZGVmaW5lZCkgJiYgISBTay5idWlsdGluLmNoZWNrSW50KHRhYnNpemUpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaW50ZWdlciBhcmd1bWVudCBleGVwZWN0ZWQsIGdvdCBcIiArIFNrLmFic3RyLnR5cGVOYW1lKHRhYnNpemUpKTtcblx0ICAgIH1cblx0ICAgIGlmICh0YWJzaXplID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICB0YWJzaXplID0gODtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGFic2l6ZSA9IFNrLmJ1aWx0aW4uYXNudW0kKHRhYnNpemUpO1xuXHQgICAgfVxuXG5cdCAgICBzcGFjZXMgPSAobmV3IEFycmF5KHRhYnNpemUgKyAxKSkuam9pbihcIiBcIik7XG5cdCAgICBleHBhbmRlZCA9IHNlbGYudi5yZXBsYWNlKC8oW15cXHJcXG5cXHRdKilcXHQvZywgZnVuY3Rpb24oYSwgYikge1xuXHQgICAgICAgIHJldHVybiBiICsgc3BhY2VzLnNsaWNlKGIubGVuZ3RoICUgdGFic2l6ZSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoZXhwYW5kZWQpO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJzd2FwY2FzZVwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYpIHtcblx0ICAgIHZhciByZXQ7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwic3dhcGNhc2VcIiwgYXJndW1lbnRzLCAxLCAxKTtcblxuXG5cdCAgICByZXQgPSBzZWxmLnYucmVwbGFjZSgvW2Etel0vZ2ksIGZ1bmN0aW9uKGMpIHtcblx0ICAgICAgICB2YXIgbGMgPSBjLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgcmV0dXJuIGxjID09PSBjID8gYy50b1VwcGVyQ2FzZSgpIDogbGM7XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihyZXQpO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJzcGxpdGxpbmVzXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwga2VlcGVuZHMpIHtcblx0ICAgIHZhciBkYXRhID0gc2VsZi52O1xuXHQgICAgdmFyIGkgPSAwO1xuXHQgICAgdmFyIGogPSBpO1xuXHQgICAgdmFyIHNlbGZsZW4gPSBzZWxmLnYubGVuZ3RoO1xuXHQgICAgdmFyIHN0cnNfdyA9IFtdO1xuXHQgICAgdmFyIGNoO1xuXHQgICAgdmFyIGVvbDtcblx0ICAgIHZhciBzb2wgPSAwO1xuXHQgICAgdmFyIHNsaWNlO1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInNwbGl0bGluZXNcIiwgYXJndW1lbnRzLCAxLCAyKTtcblx0ICAgIGlmICgoa2VlcGVuZHMgIT09IHVuZGVmaW5lZCkgJiYgISBTay5idWlsdGluLmNoZWNrQm9vbChrZWVwZW5kcykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJib29sZWFuIGFyZ3VtZW50IGV4cGVjdGVkLCBnb3QgXCIgKyBTay5hYnN0ci50eXBlTmFtZShrZWVwZW5kcykpO1xuXHQgICAgfVxuXHQgICAgaWYgKGtlZXBlbmRzID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBrZWVwZW5kcyA9IGZhbHNlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBrZWVwZW5kcyA9IGtlZXBlbmRzLnY7XG5cdCAgICB9XG5cblxuXHQgICAgZm9yIChpID0gMDsgaSA8IHNlbGZsZW47IGkgKyspIHtcblx0ICAgICAgICBjaCA9IGRhdGEuY2hhckF0KGkpO1xuXHQgICAgICAgIGlmIChkYXRhLmNoYXJBdChpICsgMSkgPT09IFwiXFxuXCIgJiYgY2ggPT09IFwiXFxyXCIpIHtcblx0ICAgICAgICAgICAgZW9sID0gaSArIDI7XG5cdCAgICAgICAgICAgIHNsaWNlID0gZGF0YS5zbGljZShzb2wsIGVvbCk7XG5cdCAgICAgICAgICAgIGlmICghIGtlZXBlbmRzKSB7XG5cdCAgICAgICAgICAgICAgICBzbGljZSA9IHNsaWNlLnJlcGxhY2UoLyhcXHJ8XFxuKS9nLCBcIlwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBzdHJzX3cucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoc2xpY2UpKTtcblx0ICAgICAgICAgICAgc29sID0gZW9sO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoKGNoID09PSBcIlxcblwiICYmIGRhdGEuY2hhckF0KGkgLSAxKSAhPT0gXCJcXHJcIikgfHwgY2ggPT09IFwiXFxyXCIpIHtcblx0ICAgICAgICAgICAgZW9sID0gaSArIDE7XG5cdCAgICAgICAgICAgIHNsaWNlID0gZGF0YS5zbGljZShzb2wsIGVvbCk7XG5cdCAgICAgICAgICAgIGlmICghIGtlZXBlbmRzKSB7XG5cdCAgICAgICAgICAgICAgICBzbGljZSA9IHNsaWNlLnJlcGxhY2UoLyhcXHJ8XFxuKS9nLCBcIlwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBzdHJzX3cucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoc2xpY2UpKTtcblx0ICAgICAgICAgICAgc29sID0gZW9sO1xuXHQgICAgICAgIH1cblxuXHQgICAgfVxuXHQgICAgaWYgKHNvbCA8IHNlbGZsZW4pIHtcblx0ICAgICAgICBlb2wgPSBzZWxmbGVuO1xuXHQgICAgICAgIHNsaWNlID0gZGF0YS5zbGljZShzb2wsIGVvbCk7XG5cdCAgICAgICAgaWYgKCEga2VlcGVuZHMpIHtcblx0ICAgICAgICAgICAgc2xpY2UgPSBzbGljZS5yZXBsYWNlKC8oXFxyfFxcbikvZywgXCJcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHN0cnNfdy5wdXNoKG5ldyBTay5idWlsdGluLnN0cihzbGljZSkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3Qoc3Ryc193KTtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1widGl0bGVcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmKSB7XG5cdCAgICB2YXIgcmV0O1xuXG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwidGl0bGVcIiwgYXJndW1lbnRzLCAxLCAxKTtcblxuXHQgICAgcmV0ID0gc2VsZi52LnJlcGxhY2UoL1thLXpdW2Etel0qL2dpLCBmdW5jdGlvbihzdHIpIHtcblx0ICAgICAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihyZXQpO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJpc2FscGhhXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZikge1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImlzYWxwaGFcIiwgYXJndW1lbnRzLCAxLCAxKTtcblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKCBzZWxmLnYubGVuZ3RoICYmIGdvb2cuc3RyaW5nLmlzQWxwaGEoc2VsZi52KSk7XG5cdH0pO1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZVtcImlzYWxudW1cIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmKSB7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiaXNhbG51bVwiLCBhcmd1bWVudHMsIDEsIDEpO1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woIHNlbGYudi5sZW5ndGggJiYgZ29vZy5zdHJpbmcuaXNBbHBoYU51bWVyaWMoc2VsZi52KSk7XG5cdH0pO1xuXG5cdC8vIGRvZXMgbm90IGFjY291bnQgZm9yIHVuaWNvZGUgbnVtZXJpYyB2YWx1ZXNcblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wiaXNudW1lcmljXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZikge1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImlzbnVtZXJpY1wiLCBhcmd1bWVudHMsIDEsIDEpO1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woIHNlbGYudi5sZW5ndGggJiYgZ29vZy5zdHJpbmcuaXNOdW1lcmljKHNlbGYudikpO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0ci5wcm90b3R5cGVbXCJpc2xvd2VyXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZikge1xuXHQgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImlzbG93ZXJcIiwgYXJndW1lbnRzLCAxLCAxKTtcblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKCBzZWxmLnYubGVuZ3RoICYmIC9bYS16XS8udGVzdChzZWxmLnYpICYmICEvW0EtWl0vLnRlc3Qoc2VsZi52KSk7XG5cdH0pO1xuXG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZVtcImlzdXBwZXJcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmKSB7XG5cdCAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiaXN1cHBlclwiLCBhcmd1bWVudHMsIDEsIDEpO1xuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woIHNlbGYudi5sZW5ndGggJiYgIS9bYS16XS8udGVzdChzZWxmLnYpICYmIC9bQS1aXS8udGVzdChzZWxmLnYpKTtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlW1wiaXN0aXRsZVwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYpIHtcblx0ICAgIC8vIENvbXBhcmluZyB0byBzdHIudGl0bGUoKSBzZWVtcyB0aGUgbW9zdCBpbnR1aXRpdmUgdGhpbmcsIGJ1dCBpdCBmYWlscyBvbiBcIlwiLFxuXHQgICAgLy8gT3RoZXIgZW1wdHktaXNoIHN0cmluZ3Mgd2l0aCBubyBjaGFuZ2UuXG5cdCAgICB2YXIgaW5wdXQgPSBzZWxmLnY7XG5cdCAgICB2YXIgY2FzZWQgPSBmYWxzZTtcblx0ICAgIHZhciBwcmV2aW91c19pc19jYXNlZCA9IGZhbHNlO1xuXHQgICAgdmFyIHBvcztcblx0ICAgIHZhciBjaDtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJpc3RpdGxlXCIsIGFyZ3VtZW50cywgMSwgMSk7XG5cdCAgICBmb3IgKHBvcyA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDsgcG9zICsrKSB7XG5cdCAgICAgICAgY2ggPSBpbnB1dC5jaGFyQXQocG9zKTtcblx0ICAgICAgICBpZiAoISAvW2Etel0vLnRlc3QoY2gpICYmIC9bQS1aXS8udGVzdChjaCkpIHtcblx0ICAgICAgICAgICAgaWYgKHByZXZpb3VzX2lzX2Nhc2VkKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCggZmFsc2UpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHByZXZpb3VzX2lzX2Nhc2VkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgY2FzZWQgPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoL1thLXpdLy50ZXN0KGNoKSAmJiAhIC9bQS1aXS8udGVzdChjaCkpIHtcblx0ICAgICAgICAgICAgaWYgKCEgcHJldmlvdXNfaXNfY2FzZWQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKCBmYWxzZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2FzZWQgPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHByZXZpb3VzX2lzX2Nhc2VkID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woIGNhc2VkKTtcblx0fSk7XG5cblx0U2suYnVpbHRpbi5zdHIucHJvdG90eXBlLm5iJHJlbWFpbmRlciA9IGZ1bmN0aW9uIChyaHMpIHtcblx0ICAgIC8vICUgZm9ybWF0IG9wLiByaHMgY2FuIGJlIGEgdmFsdWUsIGEgdHVwbGUsIG9yIHNvbWV0aGluZyB3aXRoIF9fZ2V0aXRlbV9fIChkaWN0KVxuXG5cdCAgICAvLyBGcm9tIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9zdGR0eXBlcy5odG1sI3N0cmluZy1mb3JtYXR0aW5nIHRoZVxuXHQgICAgLy8gZm9ybWF0IGxvb2tzIGxpa2U6XG5cdCAgICAvLyAxLiBUaGUgJyUnIGNoYXJhY3Rlciwgd2hpY2ggbWFya3MgdGhlIHN0YXJ0IG9mIHRoZSBzcGVjaWZpZXIuXG5cdCAgICAvLyAyLiBNYXBwaW5nIGtleSAob3B0aW9uYWwpLCBjb25zaXN0aW5nIG9mIGEgcGFyZW50aGVzaXNlZCBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIChmb3IgZXhhbXBsZSwgKHNvbWVuYW1lKSkuXG5cdCAgICAvLyAzLiBDb252ZXJzaW9uIGZsYWdzIChvcHRpb25hbCksIHdoaWNoIGFmZmVjdCB0aGUgcmVzdWx0IG9mIHNvbWUgY29udmVyc2lvbiB0eXBlcy5cblx0ICAgIC8vIDQuIE1pbmltdW0gZmllbGQgd2lkdGggKG9wdGlvbmFsKS4gSWYgc3BlY2lmaWVkIGFzIGFuICcqJyAoYXN0ZXJpc2spLCB0aGUgYWN0dWFsIHdpZHRoIGlzIHJlYWQgZnJvbSB0aGUgbmV4dFxuXHQgICAgLy8gZWxlbWVudCBvZiB0aGUgdHVwbGUgaW4gdmFsdWVzLCBhbmQgdGhlIG9iamVjdCB0byBjb252ZXJ0IGNvbWVzIGFmdGVyIHRoZSBtaW5pbXVtIGZpZWxkIHdpZHRoIGFuZCBvcHRpb25hbFxuXHQgICAgLy8gcHJlY2lzaW9uLiA1LiBQcmVjaXNpb24gKG9wdGlvbmFsKSwgZ2l2ZW4gYXMgYSAnLicgKGRvdCkgZm9sbG93ZWQgYnkgdGhlIHByZWNpc2lvbi4gSWYgc3BlY2lmaWVkIGFzICcqJyAoYW5cblx0ICAgIC8vIGFzdGVyaXNrKSwgdGhlIGFjdHVhbCB3aWR0aCBpcyByZWFkIGZyb20gdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgdHVwbGUgaW4gdmFsdWVzLCBhbmQgdGhlIHZhbHVlIHRvIGNvbnZlcnQgY29tZXNcblx0ICAgIC8vIGFmdGVyIHRoZSBwcmVjaXNpb24uIDYuIExlbmd0aCBtb2RpZmllciAob3B0aW9uYWwpLiA3LiBDb252ZXJzaW9uIHR5cGUuICBsZW5ndGggbW9kaWZpZXIgaXMgaWdub3JlZFxuXG5cdCAgICB2YXIgcmV0O1xuXHQgICAgdmFyIHJlcGxGdW5jO1xuXHQgICAgdmFyIGluZGV4O1xuXHQgICAgdmFyIHJlZ2V4O1xuXHQgICAgaWYgKHJocy5jb25zdHJ1Y3RvciAhPT0gU2suYnVpbHRpbi50dXBsZSAmJiAocmhzLm1wJHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkIHx8IHJocy5jb25zdHJ1Y3RvciA9PT0gU2suYnVpbHRpbi5zdHIpKSB7XG5cdCAgICAgICAgcmhzID0gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW3Joc10pO1xuXHQgICAgfVxuXG5cdCAgICAvLyBnZW5lcmFsIGFwcHJvYWNoIGlzIHRvIHVzZSBhIHJlZ2V4IHRoYXQgbWF0Y2hlcyB0aGUgZm9ybWF0IGFib3ZlLCBhbmRcblx0ICAgIC8vIGRvIGFuIHJlLnN1YiB3aXRoIGEgZnVuY3Rpb24gYXMgcmVwbGFjZW1lbnQgdG8gbWFrZSB0aGUgc3Vicy5cblxuXHQgICAgLy8gICAgICAgICAgIDEgMjIyMjIyMjIyMjIyMjIyMiAgIDMzMzMzMzMzICAgNDQ0NDQ0NDQ0ICAgNTU1NTU1NTU1NTU1NSAgNjY2NjYgIDc3Nzc3Nzc3Nzc3Nzc3Nzc3N1xuXHQgICAgcmVnZXggPSAvJShcXChbYS16QS1aMC05XStcXCkpPyhbIzAgK1xcLV0rKT8oXFwqfFswLTldKyk/KFxcLihcXCp8WzAtOV0rKSk/W2hsTF0/KFtkaW91eFhlRWZGZ0djcnMlXSkvZztcblx0ICAgIGluZGV4ID0gMDtcblx0ICAgIHJlcGxGdW5jID0gZnVuY3Rpb24gKHN1YnN0cmluZywgbWFwcGluZ0tleSwgY29udmVyc2lvbkZsYWdzLCBmaWVsZFdpZHRoLCBwcmVjaXNpb24sIHByZWNib2R5LCBjb252ZXJzaW9uVHlwZSkge1xuXHQgICAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgICAgdmFyIGNvbnZOYW1lO1xuXHQgICAgICAgIHZhciBjb252VmFsdWU7XG5cdCAgICAgICAgdmFyIGJhc2U7XG5cdCAgICAgICAgdmFyIHI7XG5cdCAgICAgICAgdmFyIG1rO1xuXHQgICAgICAgIHZhciB2YWx1ZTtcblx0ICAgICAgICB2YXIgaGFuZGxlV2lkdGg7XG5cdCAgICAgICAgdmFyIGZvcm1hdE51bWJlcjtcblx0ICAgICAgICB2YXIgYWx0ZXJuYXRlRm9ybTtcblx0ICAgICAgICB2YXIgcHJlY2VkZVdpdGhTaWduO1xuXHQgICAgICAgIHZhciBibGFua0JlZm9yZVBvc2l0aXZlO1xuXHQgICAgICAgIHZhciBsZWZ0QWRqdXN0O1xuXHQgICAgICAgIHZhciB6ZXJvUGFkO1xuXHQgICAgICAgIHZhciBpO1xuXHQgICAgICAgIGZpZWxkV2lkdGggPSBTay5idWlsdGluLmFzbnVtJChmaWVsZFdpZHRoKTtcblx0ICAgICAgICBwcmVjaXNpb24gPSBTay5idWlsdGluLmFzbnVtJChwcmVjaXNpb24pO1xuXG5cdCAgICAgICAgaWYgKG1hcHBpbmdLZXkgPT09IHVuZGVmaW5lZCB8fCBtYXBwaW5nS2V5ID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgIGkgPSBpbmRleCsrO1xuXHQgICAgICAgIH0gLy8gZmYgcGFzc2VzICcnIG5vdCB1bmRlZiBmb3Igc29tZSByZWFzb25cblxuXHQgICAgICAgIGlmIChwcmVjaXNpb24gPT09IFwiXCIpIHsgLy8gZmYgcGFzc2VzICcnIGhlcmUgYXN3ZWxsIGNhdXNpbmcgcHJvYmxlbXMgd2l0aCBHLGcsIGV0Yy5cblx0ICAgICAgICAgICAgcHJlY2lzaW9uID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHplcm9QYWQgPSBmYWxzZTtcblx0ICAgICAgICBsZWZ0QWRqdXN0ID0gZmFsc2U7XG5cdCAgICAgICAgYmxhbmtCZWZvcmVQb3NpdGl2ZSA9IGZhbHNlO1xuXHQgICAgICAgIHByZWNlZGVXaXRoU2lnbiA9IGZhbHNlO1xuXHQgICAgICAgIGFsdGVybmF0ZUZvcm0gPSBmYWxzZTtcblx0ICAgICAgICBpZiAoY29udmVyc2lvbkZsYWdzKSB7XG5cdCAgICAgICAgICAgIGlmIChjb252ZXJzaW9uRmxhZ3MuaW5kZXhPZihcIi1cIikgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICBsZWZ0QWRqdXN0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChjb252ZXJzaW9uRmxhZ3MuaW5kZXhPZihcIjBcIikgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB6ZXJvUGFkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChjb252ZXJzaW9uRmxhZ3MuaW5kZXhPZihcIitcIikgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlV2l0aFNpZ24gPSB0cnVlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnZlcnNpb25GbGFncy5pbmRleE9mKFwiIFwiKSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIGJsYW5rQmVmb3JlUG9zaXRpdmUgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYWx0ZXJuYXRlRm9ybSA9IGNvbnZlcnNpb25GbGFncy5pbmRleE9mKFwiI1wiKSAhPT0gLTE7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHByZWNpc2lvbikge1xuXHQgICAgICAgICAgICBwcmVjaXNpb24gPSBwYXJzZUludChwcmVjaXNpb24uc3Vic3RyKDEpLCAxMCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24gKG4sIGJhc2UpIHtcblx0ICAgICAgICAgICAgdmFyIHByZWNaZXJvUGFkZGVkO1xuXHQgICAgICAgICAgICB2YXIgcHJlZml4O1xuXHQgICAgICAgICAgICB2YXIgZGlkU2lnbjtcblx0ICAgICAgICAgICAgdmFyIG5lZztcblx0ICAgICAgICAgICAgdmFyIHI7XG5cdCAgICAgICAgICAgIHZhciBqO1xuXHQgICAgICAgICAgICBiYXNlID0gU2suYnVpbHRpbi5hc251bSQoYmFzZSk7XG5cdCAgICAgICAgICAgIG5lZyA9IGZhbHNlO1xuXHQgICAgICAgICAgICBkaWRTaWduID0gZmFsc2U7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgbiA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICAgICAgaWYgKG4gPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbiA9IC1uO1xuXHQgICAgICAgICAgICAgICAgICAgIG5lZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByID0gbi50b1N0cmluZyhiYXNlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChuIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8pIHtcblx0ICAgICAgICAgICAgICAgIHIgPSBuLnN0ciQoYmFzZSwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHIubGVuZ3RoID4gMiAmJiByLnN1YnN0cigtMikgPT09IFwiLjBcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHIgPSByLnN1YnN0cigwLCByLmxlbmd0aCAtIDIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgbmVnID0gbi5uYiRpc25lZ2F0aXZlKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAobiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50Xykge1xuXHQgICAgICAgICAgICAgICAgciA9IG4uc3RyJChiYXNlLCBmYWxzZSk7XG5cdCAgICAgICAgICAgICAgICBuZWcgPSBuLm5iJGlzbmVnYXRpdmUoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChuIGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmcpIHtcblx0ICAgICAgICAgICAgICAgIHIgPSBuLnN0ciQoYmFzZSwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgbmVnID0gbi5uYiRpc25lZ2F0aXZlKCk7XHQvL1x0bmVnID0gbi5zaXplJCA8IDA7XHRSTkwgbG9uZy5qcyBjaGFuZ2Vcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQociAhPT0gdW5kZWZpbmVkLCBcInVuaGFuZGxlZCBudW1iZXIgZm9ybWF0XCIpO1xuXG5cdCAgICAgICAgICAgIHByZWNaZXJvUGFkZGVkID0gZmFsc2U7XG5cblx0ICAgICAgICAgICAgaWYgKHByZWNpc2lvbikge1xuXHQgICAgICAgICAgICAgICAgLy9wcmludChcInIubGVuZ3RoXCIsci5sZW5ndGgsXCJwcmVjaXNpb25cIixwcmVjaXNpb24pO1xuXHQgICAgICAgICAgICAgICAgZm9yIChqID0gci5sZW5ndGg7IGogPCBwcmVjaXNpb247ICsraikge1xuXHQgICAgICAgICAgICAgICAgICAgIHIgPSBcIjBcIiArIHI7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJlY1plcm9QYWRkZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcHJlZml4ID0gXCJcIjtcblxuXHQgICAgICAgICAgICBpZiAobmVnKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVmaXggPSBcIi1cIjtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVjZWRlV2l0aFNpZ24pIHtcblx0ICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiK1wiICsgcHJlZml4O1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGJsYW5rQmVmb3JlUG9zaXRpdmUpIHtcblx0ICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiIFwiICsgcHJlZml4O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGFsdGVybmF0ZUZvcm0pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIHByZWZpeCArPSBcIjB4XCI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJhc2UgPT09IDggJiYgIXByZWNaZXJvUGFkZGVkICYmIHIgIT09IFwiMFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJlZml4ICs9IFwiMFwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFtwcmVmaXgsIHJdO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBoYW5kbGVXaWR0aCA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdCAgICAgICAgICAgIHZhciB0b3RMZW47XG5cdCAgICAgICAgICAgIHZhciBwcmVmaXggPSBhcmdzWzBdO1xuXHQgICAgICAgICAgICB2YXIgciA9IGFyZ3NbMV07XG5cdCAgICAgICAgICAgIHZhciBqO1xuXHQgICAgICAgICAgICBpZiAoZmllbGRXaWR0aCkge1xuXHQgICAgICAgICAgICAgICAgZmllbGRXaWR0aCA9IHBhcnNlSW50KGZpZWxkV2lkdGgsIDEwKTtcblx0ICAgICAgICAgICAgICAgIHRvdExlbiA9IHIubGVuZ3RoICsgcHJlZml4Lmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIGlmICh6ZXJvUGFkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gdG90TGVuOyBqIDwgZmllbGRXaWR0aDsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBcIjBcIiArIHI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0QWRqdXN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gdG90TGVuOyBqIDwgZmllbGRXaWR0aDsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByICsgXCIgXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSB0b3RMZW47IGogPCBmaWVsZFdpZHRoOyArK2opIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCIgXCIgKyBwcmVmaXg7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyByO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICAvL3ByaW50KFwiUmhzOlwiLHJocywgXCJjdG9yXCIsIHJocy5jb25zdHJ1Y3Rvcik7XG5cdCAgICAgICAgaWYgKHJocy5jb25zdHJ1Y3RvciA9PT0gU2suYnVpbHRpbi50dXBsZSkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHJocy52W2ldO1xuXHQgICAgICAgIH0gZWxzZSBpZiAocmhzLm1wJHN1YnNjcmlwdCAhPT0gdW5kZWZpbmVkICYmIG1hcHBpbmdLZXkgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBtayA9IG1hcHBpbmdLZXkuc3Vic3RyaW5nKDEsIG1hcHBpbmdLZXkubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgICAgIC8vcHJpbnQoXCJta1wiLG1rKTtcblx0ICAgICAgICAgICAgdmFsdWUgPSByaHMubXAkc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cihtaykpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAocmhzLmNvbnN0cnVjdG9yID09PSBTay5idWlsdGluLmRpY3QgfHwgcmhzLmNvbnN0cnVjdG9yID09PSBTay5idWlsdGluLmxpc3QpIHtcblx0ICAgICAgICAgICAgLy8gbmV3IGNhc2Ugd2hlcmUgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWRcblx0ICAgICAgICAgICAgdmFsdWUgPSByaHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IocmhzLnRwJG5hbWUgKyBcIiBpbnN0YW5jZSBoYXMgbm8gYXR0cmlidXRlICdtcCRzdWJzY3JpcHQnXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBiYXNlID0gMTA7XG5cdCAgICAgICAgaWYgKGNvbnZlcnNpb25UeXBlID09PSBcImRcIiB8fCBjb252ZXJzaW9uVHlwZSA9PT0gXCJpXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVdpZHRoKGZvcm1hdE51bWJlcih2YWx1ZSwgMTApKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNvbnZlcnNpb25UeXBlID09PSBcIm9cIikge1xuXHQgICAgICAgICAgICByZXR1cm4gaGFuZGxlV2lkdGgoZm9ybWF0TnVtYmVyKHZhbHVlLCA4KSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjb252ZXJzaW9uVHlwZSA9PT0gXCJ4XCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVdpZHRoKGZvcm1hdE51bWJlcih2YWx1ZSwgMTYpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNvbnZlcnNpb25UeXBlID09PSBcIlhcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gaGFuZGxlV2lkdGgoZm9ybWF0TnVtYmVyKHZhbHVlLCAxNikpLnRvVXBwZXJDYXNlKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjb252ZXJzaW9uVHlwZSA9PT0gXCJmXCIgfHwgY29udmVyc2lvblR5cGUgPT09IFwiRlwiIHx8IGNvbnZlcnNpb25UeXBlID09PSBcImVcIiB8fCBjb252ZXJzaW9uVHlwZSA9PT0gXCJFXCIgfHwgY29udmVyc2lvblR5cGUgPT09IFwiZ1wiIHx8IGNvbnZlcnNpb25UeXBlID09PSBcIkdcIikge1xuXHQgICAgICAgICAgICBjb252VmFsdWUgPSBTay5idWlsdGluLmFzbnVtJCh2YWx1ZSk7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY29udlZhbHVlID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICBjb252VmFsdWUgPSBOdW1iZXIoY29udlZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY29udlZhbHVlID09PSBJbmZpbml0eSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5mXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNvbnZWYWx1ZSA9PT0gLUluZmluaXR5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCItaW5mXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGlzTmFOKGNvbnZWYWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcIm5hblwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNvbnZOYW1lID0gW1widG9FeHBvbmVudGlhbFwiLCBcInRvRml4ZWRcIiwgXCJ0b1ByZWNpc2lvblwiXVtcImVmZ1wiLmluZGV4T2YoY29udmVyc2lvblR5cGUudG9Mb3dlckNhc2UoKSldO1xuXHQgICAgICAgICAgICBpZiAocHJlY2lzaW9uID09PSB1bmRlZmluZWQgfHwgcHJlY2lzaW9uID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY29udmVyc2lvblR5cGUgPT09IFwiZVwiIHx8IGNvbnZlcnNpb25UeXBlID09PSBcIkVcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IDY7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnZlcnNpb25UeXBlID09PSBcImZcIiB8fCBjb252ZXJzaW9uVHlwZSA9PT0gXCJGXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSA3O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IChjb252VmFsdWUpW2NvbnZOYW1lXShwcmVjaXNpb24pOyAvLyBwb3NzaWJsZSBsb29zZSBvZiBuZWdhdGl2ZSB6ZXJvIHNpZ25cblxuXHQgICAgICAgICAgICAvLyBhcHBseSBzaWduIHRvIG5lZ2F0aXZlIHplcm9zLCBmbG9hdHMgb25seSFcblx0ICAgICAgICAgICAgaWYoU2suYnVpbHRpbi5jaGVja0Zsb2F0KHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgaWYoY29udlZhbHVlID09PSAwICYmIDEvY29udlZhbHVlID09PSAtSW5maW5pdHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIi1cIiArIHJlc3VsdDsgLy8gYWRkIHNpZ24gZm9yIHplcm9cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChcIkVGR1wiLmluZGV4T2YoY29udmVyc2lvblR5cGUpICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVdpZHRoKFtcIlwiLCByZXN1bHRdKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNvbnZlcnNpb25UeXBlID09PSBcImNcIikge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlLnYpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlLnYpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlLnN0ciQoMTAsIGZhbHNlKVswXSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFNrLmJ1aWx0aW4uc3RyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudi5zdWJzdHIoMCwgMSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhbiBpbnRlZ2VyIGlzIHJlcXVpcmVkXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmIChjb252ZXJzaW9uVHlwZSA9PT0gXCJyXCIpIHtcblx0ICAgICAgICAgICAgciA9IFNrLmJ1aWx0aW4ucmVwcih2YWx1ZSk7XG5cdCAgICAgICAgICAgIGlmIChwcmVjaXNpb24pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByLnYuc3Vic3RyKDAsIHByZWNpc2lvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHIudjtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNvbnZlcnNpb25UeXBlID09PSBcInNcIikge1xuXHQgICAgICAgICAgICByID0gbmV3IFNrLmJ1aWx0aW4uc3RyKHZhbHVlKTtcblx0ICAgICAgICAgICAgaWYgKHByZWNpc2lvbikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHIudi5zdWJzdHIoMCwgcHJlY2lzaW9uKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZihmaWVsZFdpZHRoKSB7XG5cdCAgICAgICAgICAgICAgICByLnYgPSBoYW5kbGVXaWR0aChbXCIgXCIsIHIudl0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByLnY7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjb252ZXJzaW9uVHlwZSA9PT0gXCIlXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiJVwiO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHJldCA9IHRoaXMudi5yZXBsYWNlKHJlZ2V4LCByZXBsRnVuYyk7XG5cdCAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHJldCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqL1xuXHRTay5idWlsdGluLnN0cl9pdGVyXyA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cl9pdGVyXykpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyX2l0ZXJfKG9iaik7XG5cdCAgICB9XG5cdCAgICB0aGlzLiRpbmRleCA9IDA7XG5cdCAgICB0aGlzLiRvYmogPSBvYmoudi5zbGljZSgpO1xuXHQgICAgdGhpcy5zcSRsZW5ndGggPSB0aGlzLiRvYmoubGVuZ3RoO1xuXHQgICAgdGhpcy50cCRpdGVyID0gdGhpcztcblx0ICAgIHRoaXMudHAkaXRlcm5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuJGluZGV4ID49IHRoaXMuc3EkbGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy4kb2JqLnN1YnN0cih0aGlzLiRpbmRleCsrLCAxKSk7XG5cdCAgICB9O1xuXHQgICAgdGhpcy4kciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiaXRlcmF0b3JcIik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0U2suYWJzdHIuc2V0VXBJbmhlcml0YW5jZShcIml0ZXJhdG9yXCIsIFNrLmJ1aWx0aW4uc3RyX2l0ZXJfLCBTay5idWlsdGluLm9iamVjdCk7XG5cblx0U2suYnVpbHRpbi5zdHJfaXRlcl8ucHJvdG90eXBlLl9fY2xhc3NfXyA9IFNrLmJ1aWx0aW4uc3RyX2l0ZXJfO1xuXG5cdFNrLmJ1aWx0aW4uc3RyX2l0ZXJfLnByb3RvdHlwZS5fX2l0ZXJfXyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYpIHtcblx0ICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2l0ZXJfX1wiLCBhcmd1bWVudHMsIDAsIDAsIHRydWUsIGZhbHNlKTtcblx0ICAgIHJldHVybiBzZWxmO1xuXHR9KTtcblxuXHRTay5idWlsdGluLnN0cl9pdGVyXy5wcm90b3R5cGVbXCJuZXh0XCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZikge1xuXHQgICAgdmFyIHJldCA9IHNlbGYudHAkaXRlcm5leHQoKTtcblx0ICAgIGlmIChyZXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN0b3BJdGVyYXRpb24oKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXQ7XG5cdH0pO1xuXG5cblxuXHQvKiAtLS0tIC9Vc2Vycy9yb2Ivc2t1bHB0eS9saWIvLi4vbm9kZV9tb2R1bGVzL3NrdWxwdC9zcmMvdG9rZW5pemUuanMgLS0tLSAqLyBcblxuXHQvKlxuXHQgKiBUaGlzIGlzIGEgcG9ydCBvZiB0b2tlbml6ZS5weSBieSBLYS1QaW5nIFllZS5cblx0ICpcblx0ICogZWFjaCBjYWxsIHRvIHJlYWRsaW5lIHNob3VsZCByZXR1cm4gb25lIGxpbmUgb2YgaW5wdXQgYXMgYSBzdHJpbmcsIG9yXG5cdCAqIHVuZGVmaW5lZCBpZiBpdCdzIGZpbmlzaGVkLlxuXHQgKlxuXHQgKiBjYWxsYmFjayBpcyBjYWxsZWQgZm9yIGVhY2ggdG9rZW4gd2l0aCA1IGFyZ3M6XG5cdCAqIDEuIHRoZSB0b2tlbiB0eXBlXG5cdCAqIDIuIHRoZSB0b2tlbiBzdHJpbmdcblx0ICogMy4gWyBzdGFydF9yb3csIHN0YXJ0X2NvbCBdXG5cdCAqIDQuIFsgZW5kX3JvdywgZW5kX2NvbCBdXG5cdCAqIDUuIGxvZ2ljYWwgbGluZSB3aGVyZSB0aGUgdG9rZW4gd2FzIGZvdW5kLCBpbmNsdWRpbmcgY29udGludWF0aW9uIGxpbmVzXG5cdCAqXG5cdCAqIGNhbGxiYWNrIGNhbiByZXR1cm4gdHJ1ZSB0byBhYm9ydC5cblx0ICpcblx0ICovXG5cblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0U2suVG9rZW5pemVyID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBpbnRlcmFjdGl2ZSwgY2FsbGJhY2spIHtcblx0ICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcblx0ICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0ICAgIHRoaXMubG51bSA9IDA7XG5cdCAgICB0aGlzLnBhcmVubGV2ID0gMDtcblx0ICAgIHRoaXMucGFyZW5zdGFjayA9IFtdO1xuXHQgICAgdGhpcy5jb250aW51ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMubmFtZWNoYXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaX1wiO1xuXHQgICAgdGhpcy5udW1jaGFycyA9IFwiMDEyMzQ1Njc4OVwiO1xuXHQgICAgdGhpcy5jb250c3RyID0gXCJcIjtcblx0ICAgIHRoaXMubmVlZGNvbnQgPSBmYWxzZTtcblx0ICAgIHRoaXMuY29udGxpbmUgPSB1bmRlZmluZWQ7XG5cdCAgICB0aGlzLmluZGVudHMgPSBbMF07XG5cdCAgICB0aGlzLmVuZHByb2cgPSAvLiovO1xuXHQgICAgdGhpcy5zdHJzdGFydCA9IFstMSwgLTFdO1xuXHQgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGludGVyYWN0aXZlO1xuXHQgICAgdGhpcy5kb25lRnVuYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgaTtcblx0ICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5pbmRlbnRzLmxlbmd0aDsgKytpKSAvLyBwb3AgcmVtYWluaW5nIGluZGVudCBsZXZlbHNcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKFNrLlRva2VuaXplci5Ub2tlbnMuVF9ERURFTlQsIFwiXCIsIFt0aGlzLmxudW0sIDBdLCBbdGhpcy5sbnVtLCAwXSwgXCJcIikpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcImRvbmVcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5jYWxsYmFjayhTay5Ub2tlbml6ZXIuVG9rZW5zLlRfRU5ETUFSS0VSLCBcIlwiLCBbdGhpcy5sbnVtLCAwXSwgW3RoaXMubG51bSwgMF0sIFwiXCIpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcImRvbmVcIjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gXCJmYWlsZWRcIjtcblx0ICAgIH07XG5cblx0fTtcblxuXHQvKipcblx0ICogQGVudW0ge251bWJlcn1cblx0ICovXG5cdFNrLlRva2VuaXplci5Ub2tlbnMgPSB7XG5cdCAgICBUX0VORE1BUktFUiAgICAgICA6IDAsXG5cdCAgICBUX05BTUUgICAgICAgICAgICA6IDEsXG5cdCAgICBUX05VTUJFUiAgICAgICAgICA6IDIsXG5cdCAgICBUX1NUUklORyAgICAgICAgICA6IDMsXG5cdCAgICBUX05FV0xJTkUgICAgICAgICA6IDQsXG5cdCAgICBUX0lOREVOVCAgICAgICAgICA6IDUsXG5cdCAgICBUX0RFREVOVCAgICAgICAgICA6IDYsXG5cdCAgICBUX0xQQVIgICAgICAgICAgICA6IDcsXG5cdCAgICBUX1JQQVIgICAgICAgICAgICA6IDgsXG5cdCAgICBUX0xTUUIgICAgICAgICAgICA6IDksXG5cdCAgICBUX1JTUUIgICAgICAgICAgICA6IDEwLFxuXHQgICAgVF9DT0xPTiAgICAgICAgICAgOiAxMSxcblx0ICAgIFRfQ09NTUEgICAgICAgICAgIDogMTIsXG5cdCAgICBUX1NFTUkgICAgICAgICAgICA6IDEzLFxuXHQgICAgVF9QTFVTICAgICAgICAgICAgOiAxNCxcblx0ICAgIFRfTUlOVVMgICAgICAgICAgIDogMTUsXG5cdCAgICBUX1NUQVIgICAgICAgICAgICA6IDE2LFxuXHQgICAgVF9TTEFTSCAgICAgICAgICAgOiAxNyxcblx0ICAgIFRfVkJBUiAgICAgICAgICAgIDogMTgsXG5cdCAgICBUX0FNUEVSICAgICAgICAgICA6IDE5LFxuXHQgICAgVF9MRVNTICAgICAgICAgICAgOiAyMCxcblx0ICAgIFRfR1JFQVRFUiAgICAgICAgIDogMjEsXG5cdCAgICBUX0VRVUFMICAgICAgICAgICA6IDIyLFxuXHQgICAgVF9ET1QgICAgICAgICAgICAgOiAyMyxcblx0ICAgIFRfUEVSQ0VOVCAgICAgICAgIDogMjQsXG5cdCAgICBUX0JBQ0tRVU9URSAgICAgICA6IDI1LFxuXHQgICAgVF9MQlJBQ0UgICAgICAgICAgOiAyNixcblx0ICAgIFRfUkJSQUNFICAgICAgICAgIDogMjcsXG5cdCAgICBUX0VRRVFVQUwgICAgICAgICA6IDI4LFxuXHQgICAgVF9OT1RFUVVBTCAgICAgICAgOiAyOSxcblx0ICAgIFRfTEVTU0VRVUFMICAgICAgIDogMzAsXG5cdCAgICBUX0dSRUFURVJFUVVBTCAgICA6IDMxLFxuXHQgICAgVF9USUxERSAgICAgICAgICAgOiAzMixcblx0ICAgIFRfQ0lSQ1VNRkxFWCAgICAgIDogMzMsXG5cdCAgICBUX0xFRlRTSElGVCAgICAgICA6IDM0LFxuXHQgICAgVF9SSUdIVFNISUZUICAgICAgOiAzNSxcblx0ICAgIFRfRE9VQkxFU1RBUiAgICAgIDogMzYsXG5cdCAgICBUX1BMVVNFUVVBTCAgICAgICA6IDM3LFxuXHQgICAgVF9NSU5FUVVBTCAgICAgICAgOiAzOCxcblx0ICAgIFRfU1RBUkVRVUFMICAgICAgIDogMzksXG5cdCAgICBUX1NMQVNIRVFVQUwgICAgICA6IDQwLFxuXHQgICAgVF9QRVJDRU5URVFVQUwgICAgOiA0MSxcblx0ICAgIFRfQU1QRVJFUVVBTCAgICAgIDogNDIsXG5cdCAgICBUX1ZCQVJFUVVBTCAgICAgICA6IDQzLFxuXHQgICAgVF9DSVJDVU1GTEVYRVFVQUwgOiA0NCxcblx0ICAgIFRfTEVGVFNISUZURVFVQUwgIDogNDUsXG5cdCAgICBUX1JJR0hUU0hJRlRFUVVBTCA6IDQ2LFxuXHQgICAgVF9ET1VCTEVTVEFSRVFVQUwgOiA0Nyxcblx0ICAgIFRfRE9VQkxFU0xBU0ggICAgIDogNDgsXG5cdCAgICBUX0RPVUJMRVNMQVNIRVFVQUw6IDQ5LFxuXHQgICAgVF9BVCAgICAgICAgICAgICAgOiA1MCxcblx0ICAgIFRfT1AgICAgICAgICAgICAgIDogNTEsXG5cdCAgICBUX0NPTU1FTlQgICAgICAgICA6IDUyLFxuXHQgICAgVF9OTCAgICAgICAgICAgICAgOiA1Myxcblx0ICAgIFRfUkFSUk9XICAgICAgICAgIDogNTQsXG5cdCAgICBUX0VSUk9SVE9LRU4gICAgICA6IDU1LFxuXHQgICAgVF9OX1RPS0VOUyAgICAgICAgOiA1Nixcblx0ICAgIFRfTlRfT0ZGU0VUICAgICAgIDogMjU2XG5cdH07XG5cblx0LyoqIEBwYXJhbSB7Li4uKn0geCAqL1xuXHRmdW5jdGlvbiBncm91cCAoeCkge1xuXHQgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIFwiKFwiICsgYXJncy5qb2luKFwifFwiKSArIFwiKVwiO1xuXHR9XG5cblx0LyoqIEBwYXJhbSB7Li4uKn0geCAqL1xuXHRmdW5jdGlvbiBhbnkgKHgpIHtcblx0ICAgIHJldHVybiBncm91cC5hcHBseShudWxsLCBhcmd1bWVudHMpICsgXCIqXCI7XG5cdH1cblxuXHQvKiogQHBhcmFtIHsuLi4qfSB4ICovXG5cdGZ1bmN0aW9uIG1heWJlICh4KSB7XG5cdCAgICByZXR1cm4gZ3JvdXAuYXBwbHkobnVsbCwgYXJndW1lbnRzKSArIFwiP1wiO1xuXHR9XG5cblx0Lyogd2UgaGF2ZSB0byB1c2Ugc3RyaW5nIGFuZCBjdG9yIHRvIGJlIGFibGUgdG8gYnVpbGQgcGF0dGVybnMgdXAuICsgb24gLy4uLi9cblx0ICogZG9lcyBzb21ldGhpbmcgc3RyYW5nZS4gKi9cblx0dmFyIFdoaXRlc3BhY2UgPSBcIlsgXFxcXGZcXFxcdF0qXCI7XG5cdHZhciBDb21tZW50XyA9IFwiI1teXFxcXHJcXFxcbl0qXCI7XG5cdHZhciBJZGVudCA9IFwiW2EtekEtWl9dXFxcXHcqXCI7XG5cblx0dmFyIEJpbm51bWJlciA9IFwiMFtiQl1bMDFdKlwiO1xuXHR2YXIgSGV4bnVtYmVyID0gXCIwW3hYXVtcXFxcZGEtZkEtRl0qW2xMXT9cIjtcblx0dmFyIE9jdG51bWJlciA9IFwiMFtvT10/WzAtN10qW2xMXT9cIjtcblx0dmFyIERlY251bWJlciA9IFwiWzEtOV1cXFxcZCpbbExdP1wiO1xuXHR2YXIgSW50bnVtYmVyID0gZ3JvdXAoQmlubnVtYmVyLCBIZXhudW1iZXIsIE9jdG51bWJlciwgRGVjbnVtYmVyKTtcblxuXHR2YXIgRXhwb25lbnQgPSBcIltlRV1bLStdP1xcXFxkK1wiO1xuXHR2YXIgUG9pbnRmbG9hdCA9IGdyb3VwKFwiXFxcXGQrXFxcXC5cXFxcZCpcIiwgXCJcXFxcLlxcXFxkK1wiKSArIG1heWJlKEV4cG9uZW50KTtcblx0dmFyIEV4cGZsb2F0ID0gXCJcXFxcZCtcIiArIEV4cG9uZW50O1xuXHR2YXIgRmxvYXRudW1iZXIgPSBncm91cChQb2ludGZsb2F0LCBFeHBmbG9hdCk7XG5cdHZhciBJbWFnbnVtYmVyID0gZ3JvdXAoXCJcXFxcZCtbakpdXCIsIEZsb2F0bnVtYmVyICsgXCJbakpdXCIpO1xuXHR2YXIgTnVtYmVyXyA9IGdyb3VwKEltYWdudW1iZXIsIEZsb2F0bnVtYmVyLCBJbnRudW1iZXIpO1xuXG5cdC8vIHRhaWwgZW5kIG9mICcgc3RyaW5nXG5cdHZhciBTaW5nbGUgPSBcIl5bXidcXFxcXFxcXF0qKD86XFxcXFxcXFwuW14nXFxcXFxcXFxdKikqJ1wiO1xuXHQvLyB0YWlsIGVuZCBvZiBcIiBzdHJpbmdcblx0dmFyIERvdWJsZV8gPSAnXlteXCJcXFxcXFxcXF0qKD86XFxcXFxcXFwuW15cIlxcXFxcXFxcXSopKlwiJztcblx0Ly8gdGFpbCBlbmQgb2YgJycnIHN0cmluZ1xuXHR2YXIgU2luZ2xlMyA9IFwiW14nXFxcXFxcXFxdKig/Oig/OlxcXFxcXFxcLnwnKD8hJycpKVteJ1xcXFxcXFxcXSopKicnJ1wiO1xuXHQvLyB0YWlsIGVuZCBvZiBcIlwiXCIgc3RyaW5nXG5cdHZhciBEb3VibGUzID0gJ1teXCJcXFxcXFxcXF0qKD86KD86XFxcXFxcXFwufFwiKD8hXCJcIikpW15cIlxcXFxcXFxcXSopKlwiXCJcIic7XG5cdHZhciBUcmlwbGUgPSBncm91cChcIlt1YlVCXT9bclJdPycnJ1wiLCAnW3ViVUJdP1tyUl0/XCJcIlwiJyk7XG5cdHZhciBTdHJpbmdfID0gZ3JvdXAoXCJbdVVdP1tyUl0/J1teXFxcXG4nXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXFxcXG4nXFxcXFxcXFxdKikqJ1wiLFxuXHQgICAgJ1t1VV0/W3JSXT9cIlteXFxcXG5cIlxcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXFxuXCJcXFxcXFxcXF0qKSpcIicpO1xuXG5cdC8vIEJlY2F1c2Ugb2YgbGVmdG1vc3QtdGhlbi1sb25nZXN0IG1hdGNoIHNlbWFudGljcywgYmUgc3VyZSB0byBwdXQgdGhlXG5cdC8vIGxvbmdlc3Qgb3BlcmF0b3JzIGZpcnN0IChlLmcuLCBpZiA9IGNhbWUgYmVmb3JlID09LCA9PSB3b3VsZCBnZXRcblx0Ly8gcmVjb2duaXplZCBhcyB0d28gaW5zdGFuY2VzIG9mID0pLlxuXHR2YXIgT3BlcmF0b3IgPSBncm91cChcIlxcXFwqXFxcXCo9P1wiLCBcIj4+PT9cIiwgXCI8PD0/XCIsIFwiPD5cIiwgXCIhPVwiLFxuXHQgICAgXCIvLz0/XCIsIFwiLT5cIixcblx0ICAgIFwiWytcXFxcLSovJSZ8Xj08Pl09P1wiLFxuXHQgICAgXCJ+XCIpO1xuXG5cdHZhciBCcmFja2V0ID0gXCJbXFxcXF1bKCl7fV1cIjtcblx0dmFyIFNwZWNpYWwgPSBncm91cChcIlxcXFxyP1xcXFxuXCIsIFwiWzo7LixgQF1cIik7XG5cdHZhciBGdW5ueSA9IGdyb3VwKE9wZXJhdG9yLCBCcmFja2V0LCBTcGVjaWFsKTtcblxuXHR2YXIgQ29udFN0ciA9IGdyb3VwKFwiW3VVYkJdP1tyUl0/J1teXFxcXG4nXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXFxcXG4nXFxcXFxcXFxdKikqXCIgK1xuXHQgICAgICAgIGdyb3VwKFwiJ1wiLCBcIlxcXFxcXFxcXFxcXHI/XFxcXG5cIiksXG5cdCAgICAgICAgXCJbdVViQl0/W3JSXT9cXFwiW15cXFxcblxcXCJcXFxcXFxcXF0qKD86XFxcXFxcXFwuW15cXFxcblxcXCJcXFxcXFxcXF0qKSpcIiArXG5cdCAgICAgICAgZ3JvdXAoXCJcXFwiXCIsIFwiXFxcXFxcXFxcXFxccj9cXFxcblwiKSk7XG5cdHZhciBQc2V1ZG9FeHRyYXMgPSBncm91cChcIlxcXFxcXFxcXFxcXHI/XFxcXG5cIiwgQ29tbWVudF8sIFRyaXBsZSk7XG5cdC8vIE5lZWQgdG8gcHJlZml4IHdpdGggXCJeXCIgYXMgd2Ugb25seSB3YW50IHRvIG1hdGNoIHdoYXQncyBuZXh0XG5cdHZhciBQc2V1ZG9Ub2tlbiA9IFwiXlwiICsgZ3JvdXAoUHNldWRvRXh0cmFzLCBOdW1iZXJfLCBGdW5ueSwgQ29udFN0ciwgSWRlbnQpO1xuXG5cblx0dmFyIHRyaXBsZV9xdW90ZWQgPSB7XG5cdCAgICBcIicnJ1wiICA6IHRydWUsICdcIlwiXCInOiB0cnVlLFxuXHQgICAgXCJyJycnXCIgOiB0cnVlLCAnclwiXCJcIic6IHRydWUsIFwiUicnJ1wiOiB0cnVlLCAnUlwiXCJcIic6IHRydWUsXG5cdCAgICBcInUnJydcIiA6IHRydWUsICd1XCJcIlwiJzogdHJ1ZSwgXCJVJycnXCI6IHRydWUsICdVXCJcIlwiJzogdHJ1ZSxcblx0ICAgIFwiYicnJ1wiIDogdHJ1ZSwgJ2JcIlwiXCInOiB0cnVlLCBcIkInJydcIjogdHJ1ZSwgJ0JcIlwiXCInOiB0cnVlLFxuXHQgICAgXCJ1cicnJ1wiOiB0cnVlLCAndXJcIlwiXCInOiB0cnVlLCBcIlVyJycnXCI6IHRydWUsICdVclwiXCJcIic6IHRydWUsXG5cdCAgICBcInVSJycnXCI6IHRydWUsICd1UlwiXCJcIic6IHRydWUsIFwiVVInJydcIjogdHJ1ZSwgJ1VSXCJcIlwiJzogdHJ1ZSxcblx0ICAgIFwiYnInJydcIjogdHJ1ZSwgJ2JyXCJcIlwiJzogdHJ1ZSwgXCJCcicnJ1wiOiB0cnVlLCAnQnJcIlwiXCInOiB0cnVlLFxuXHQgICAgXCJiUicnJ1wiOiB0cnVlLCAnYlJcIlwiXCInOiB0cnVlLCBcIkJSJycnXCI6IHRydWUsICdCUlwiXCJcIic6IHRydWVcblx0fTtcblxuXHR2YXIgc2luZ2xlX3F1b3RlZCA9IHtcblx0ICAgIFwiJ1wiICA6IHRydWUsICdcIic6IHRydWUsXG5cdCAgICBcInInXCIgOiB0cnVlLCAnclwiJzogdHJ1ZSwgXCJSJ1wiOiB0cnVlLCAnUlwiJzogdHJ1ZSxcblx0ICAgIFwidSdcIiA6IHRydWUsICd1XCInOiB0cnVlLCBcIlUnXCI6IHRydWUsICdVXCInOiB0cnVlLFxuXHQgICAgXCJiJ1wiIDogdHJ1ZSwgJ2JcIic6IHRydWUsIFwiQidcIjogdHJ1ZSwgJ0JcIic6IHRydWUsXG5cdCAgICBcInVyJ1wiOiB0cnVlLCAndXJcIic6IHRydWUsIFwiVXInXCI6IHRydWUsICdVclwiJzogdHJ1ZSxcblx0ICAgIFwidVInXCI6IHRydWUsICd1UlwiJzogdHJ1ZSwgXCJVUidcIjogdHJ1ZSwgJ1VSXCInOiB0cnVlLFxuXHQgICAgXCJicidcIjogdHJ1ZSwgJ2JyXCInOiB0cnVlLCBcIkJyJ1wiOiB0cnVlLCAnQnJcIic6IHRydWUsXG5cdCAgICBcImJSJ1wiOiB0cnVlLCAnYlJcIic6IHRydWUsIFwiQlInXCI6IHRydWUsICdCUlwiJzogdHJ1ZVxuXHR9O1xuXG5cdC8vIGhhY2sgdG8gbWFrZSBjbG9zdXJlIGtlZXAgdGhvc2Ugb2JqZWN0cy4gbm90IHN1cmUgd2hhdCBhIGJldHRlciB3YXkgaXMuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaztcblx0ICAgIGZvciAoayBpbiB0cmlwbGVfcXVvdGVkKSB7XG5cdCAgICB9XG5cdCAgICBmb3IgKGsgaW4gc2luZ2xlX3F1b3RlZCkge1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0dmFyIHRhYnNpemUgPSA4O1xuXG5cdGZ1bmN0aW9uIGNvbnRhaW5zIChhLCBvYmopIHtcblx0ICAgIHZhciBpID0gYS5sZW5ndGg7XG5cdCAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgICAgaWYgKGFbaV0gPT09IG9iaikge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiByc3RyaXAgKGlucHV0LCB3aGF0KSB7XG5cdCAgICB2YXIgaTtcblx0ICAgIGZvciAoaSA9IGlucHV0Lmxlbmd0aDsgaSA+IDA7IC0taSkge1xuXHQgICAgICAgIGlmICh3aGF0LmluZGV4T2YoaW5wdXQuY2hhckF0KGkgLSAxKSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcoMCwgaSk7XG5cdH1cblxuXHRTay5Ub2tlbml6ZXIucHJvdG90eXBlLmdlbmVyYXRlVG9rZW5zID0gZnVuY3Rpb24gKGxpbmUpIHtcblx0ICAgIHZhciBubF9wb3M7XG5cdCAgICB2YXIgbmV3bDtcblx0ICAgIHZhciBpbml0aWFsO1xuXHQgICAgdmFyIHRva2VuO1xuXHQgICAgdmFyIGVwb3M7XG5cdCAgICB2YXIgc3Bvcztcblx0ICAgIHZhciBzdGFydDtcblx0ICAgIHZhciBwc2V1ZG9tYXRjaDtcblx0ICAgIHZhciBjYXBvcztcblx0ICAgIHZhciBjb21tZW50X3Rva2VuO1xuXHQgICAgdmFyIGVuZG1hdGNoLCBwb3MsIGNvbHVtbiwgZW5kLCBtYXg7XG5cblxuXHQgICAgLy8gYm5tIC0gTW92ZSB0aGVzZSBkZWZpbml0aW9ucyBpbiB0aGlzIGZ1bmN0aW9uIG90aGVyd2lzZSB0ZXN0IHN0YXRlIGlzIHByZXNlcnZlZCBiZXR3ZWVuXG5cdCAgICAvLyBjYWxscyBvbiBzaW5nbGUzcHJvZyBhbmQgZG91YmxlM3Byb2cgY2F1c2luZyB3ZWlyZCBlcnJvcnMgd2l0aCBoYXZpbmcgbXVsdGlwbGUgaW5zdGFuY2VzXG5cdCAgICAvLyBvZiB0cmlwbGUgcXVvdGVkIHN0cmluZ3MgaW4gdGhlIHNhbWUgcHJvZ3JhbS5cblxuXHQgICAgdmFyIHBzZXVkb3Byb2cgPSBuZXcgUmVnRXhwKFBzZXVkb1Rva2VuKTtcblx0ICAgIHZhciBzaW5nbGUzcHJvZyA9IG5ldyBSZWdFeHAoU2luZ2xlMywgXCJnXCIpO1xuXHQgICAgdmFyIGRvdWJsZTNwcm9nID0gbmV3IFJlZ0V4cChEb3VibGUzLCBcImdcIik7XG5cblx0ICAgIHZhciBlbmRwcm9ncyA9IHsgICAgIFwiJ1wiOiBuZXcgUmVnRXhwKFNpbmdsZSwgXCJnXCIpLCBcIlxcXCJcIjogbmV3IFJlZ0V4cChEb3VibGVfLCBcImdcIiksXG5cdCAgICAgICAgXCInJydcIiAgICAgICAgICAgICAgIDogc2luZ2xlM3Byb2csICdcIlwiXCInOiBkb3VibGUzcHJvZyxcblx0ICAgICAgICBcInInJydcIiAgICAgICAgICAgICAgOiBzaW5nbGUzcHJvZywgJ3JcIlwiXCInOiBkb3VibGUzcHJvZyxcblx0ICAgICAgICBcInUnJydcIiAgICAgICAgICAgICAgOiBzaW5nbGUzcHJvZywgJ3VcIlwiXCInOiBkb3VibGUzcHJvZyxcblx0ICAgICAgICBcImInJydcIiAgICAgICAgICAgICAgOiBzaW5nbGUzcHJvZywgJ2JcIlwiXCInOiBkb3VibGUzcHJvZyxcblx0ICAgICAgICBcInVyJycnXCIgICAgICAgICAgICAgOiBzaW5nbGUzcHJvZywgJ3VyXCJcIlwiJzogZG91YmxlM3Byb2csXG5cdCAgICAgICAgXCJicicnJ1wiICAgICAgICAgICAgIDogc2luZ2xlM3Byb2csICdiclwiXCJcIic6IGRvdWJsZTNwcm9nLFxuXHQgICAgICAgIFwiUicnJ1wiICAgICAgICAgICAgICA6IHNpbmdsZTNwcm9nLCAnUlwiXCJcIic6IGRvdWJsZTNwcm9nLFxuXHQgICAgICAgIFwiVScnJ1wiICAgICAgICAgICAgICA6IHNpbmdsZTNwcm9nLCAnVVwiXCJcIic6IGRvdWJsZTNwcm9nLFxuXHQgICAgICAgIFwiQicnJ1wiICAgICAgICAgICAgICA6IHNpbmdsZTNwcm9nLCAnQlwiXCJcIic6IGRvdWJsZTNwcm9nLFxuXHQgICAgICAgIFwidVInJydcIiAgICAgICAgICAgICA6IHNpbmdsZTNwcm9nLCAndVJcIlwiXCInOiBkb3VibGUzcHJvZyxcblx0ICAgICAgICBcIlVyJycnXCIgICAgICAgICAgICAgOiBzaW5nbGUzcHJvZywgJ1VyXCJcIlwiJzogZG91YmxlM3Byb2csXG5cdCAgICAgICAgXCJVUicnJ1wiICAgICAgICAgICAgIDogc2luZ2xlM3Byb2csICdVUlwiXCJcIic6IGRvdWJsZTNwcm9nLFxuXHQgICAgICAgIFwiYlInJydcIiAgICAgICAgICAgICA6IHNpbmdsZTNwcm9nLCAnYlJcIlwiXCInOiBkb3VibGUzcHJvZyxcblx0ICAgICAgICBcIkJyJycnXCIgICAgICAgICAgICAgOiBzaW5nbGUzcHJvZywgJ0JyXCJcIlwiJzogZG91YmxlM3Byb2csXG5cdCAgICAgICAgXCJCUicnJ1wiICAgICAgICAgICAgIDogc2luZ2xlM3Byb2csICdCUlwiXCJcIic6IGRvdWJsZTNwcm9nLFxuXHQgICAgICAgICdyJyAgICAgICAgICAgICAgICAgOiBudWxsLCAnUic6IG51bGwsXG5cdCAgICAgICAgJ3UnICAgICAgICAgICAgICAgICA6IG51bGwsICdVJzogbnVsbCxcblx0ICAgICAgICAnYicgICAgICAgICAgICAgICAgIDogbnVsbCwgJ0InOiBudWxsXG5cdCAgICB9O1xuXG5cblx0ICAgIGlmICghbGluZSkge1xuXHQgICAgICAgIGxpbmUgPSAnJztcblx0ICAgIH1cblx0ICAgIC8vcHJpbnQoXCJMSU5FOidcIitsaW5lK1wiJ1wiKTtcblxuXHQgICAgdGhpcy5sbnVtICs9IDE7XG5cdCAgICBwb3MgPSAwO1xuXHQgICAgbWF4ID0gbGluZS5sZW5ndGg7XG5cblx0ICAgIGlmICh0aGlzLmNvbnRzdHIubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIGlmICghbGluZSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIkVPRiBpbiBtdWx0aS1saW5lIHN0cmluZ1wiLCB0aGlzLmZpbGVuYW1lLCB0aGlzLnN0cnN0YXJ0WzBdLCB0aGlzLnN0cnN0YXJ0WzFdLCB7XG5cdCAgICAgICAgICAgICAgICBraW5kOiBcIlNUUklOR19FT0ZcIixcblx0ICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuY29udGxpbmVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuZW5kcHJvZy5sYXN0SW5kZXggPSAwO1xuXHQgICAgICAgIGVuZG1hdGNoID0gdGhpcy5lbmRwcm9nLnRlc3QobGluZSk7XG5cdCAgICAgICAgaWYgKGVuZG1hdGNoKSB7XG5cdCAgICAgICAgICAgIHBvcyA9IGVuZCA9IHRoaXMuZW5kcHJvZy5sYXN0SW5kZXg7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKFNrLlRva2VuaXplci5Ub2tlbnMuVF9TVFJJTkcsIHRoaXMuY29udHN0ciArIGxpbmUuc3Vic3RyaW5nKDAsIGVuZCksXG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0cnN0YXJ0LCBbdGhpcy5sbnVtLCBlbmRdLCB0aGlzLmNvbnRsaW5lICsgbGluZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnZG9uZSc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5jb250c3RyID0gJyc7XG5cdCAgICAgICAgICAgIHRoaXMubmVlZGNvbnQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdGhpcy5jb250bGluZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5uZWVkY29udCAmJiBsaW5lLnN1YnN0cmluZyhsaW5lLmxlbmd0aCAtIDIpICE9PSBcIlxcXFxcXG5cIiAmJiBsaW5lLnN1YnN0cmluZyhsaW5lLmxlbmd0aCAtIDMpICE9PSBcIlxcXFxcXHJcXG5cIikge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjayhTay5Ub2tlbml6ZXIuVG9rZW5zLlRfRVJST1JUT0tFTiwgdGhpcy5jb250c3RyICsgbGluZSxcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3Ryc3RhcnQsIFt0aGlzLmxudW0sIGxpbmUubGVuZ3RoXSwgdGhpcy5jb250bGluZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnZG9uZSc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5jb250c3RyID0gJyc7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGxpbmUgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29udHN0ciArPSBsaW5lO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRsaW5lID0gdGhpcy5jb250bGluZSArIGxpbmU7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0aGlzLnBhcmVubGV2ID09PSAwICYmICF0aGlzLmNvbnRpbnVlZCkge1xuXHQgICAgICAgIGlmICghbGluZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5kb25lRnVuYygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb2x1bW4gPSAwO1xuXHQgICAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcblx0ICAgICAgICAgICAgaWYgKGxpbmUuY2hhckF0KHBvcykgPT09ICcgJykge1xuXHQgICAgICAgICAgICAgICAgY29sdW1uICs9IDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAobGluZS5jaGFyQXQocG9zKSA9PT0gJ1xcdCcpIHtcblx0ICAgICAgICAgICAgICAgIGNvbHVtbiA9IChjb2x1bW4gLyB0YWJzaXplICsgMSkgKiB0YWJzaXplO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUuY2hhckF0KHBvcykgPT09ICdcXGYnKSB7XG5cdCAgICAgICAgICAgICAgICBjb2x1bW4gPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcG9zID0gcG9zICsgMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHBvcyA9PT0gbWF4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbmVGdW5jKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKFwiI1xcclxcblwiLmluZGV4T2YobGluZS5jaGFyQXQocG9zKSkgIT09IC0xKSAvLyBza2lwIGNvbW1lbnRzIG9yIGJsYW5rIGxpbmVzXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICBpZiAobGluZS5jaGFyQXQocG9zKSA9PT0gJyMnKSB7XG5cdCAgICAgICAgICAgICAgICBjb21tZW50X3Rva2VuID0gcnN0cmlwKGxpbmUuc3Vic3RyaW5nKHBvcyksICdcXHJcXG4nKTtcblx0ICAgICAgICAgICAgICAgIG5sX3BvcyA9IHBvcyArIGNvbW1lbnRfdG9rZW4ubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2soU2suVG9rZW5pemVyLlRva2Vucy5UX0NPTU1FTlQsIGNvbW1lbnRfdG9rZW4sXG5cdCAgICAgICAgICAgICAgICAgICAgW3RoaXMubG51bSwgcG9zXSwgW3RoaXMubG51bSwgcG9zICsgY29tbWVudF90b2tlbi5sZW5ndGhdLCBsaW5lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZG9uZSc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvL3ByaW50KFwiSEVSRToxXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2soU2suVG9rZW5pemVyLlRva2Vucy5UX05MLCBsaW5lLnN1YnN0cmluZyhubF9wb3MpLFxuXHQgICAgICAgICAgICAgICAgICAgIFt0aGlzLmxudW0sIG5sX3Bvc10sIFt0aGlzLmxudW0sIGxpbmUubGVuZ3RoXSwgbGluZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RvbmUnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy9wcmludChcIkhFUkU6MlwiKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKFNrLlRva2VuaXplci5Ub2tlbnMuVF9OTCwgbGluZS5zdWJzdHJpbmcocG9zKSxcblx0ICAgICAgICAgICAgICAgICAgICBbdGhpcy5sbnVtLCBwb3NdLCBbdGhpcy5sbnVtLCBsaW5lLmxlbmd0aF0sIGxpbmUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkb25lJztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbnRlcmFjdGl2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjb2x1bW4gPiB0aGlzLmluZGVudHNbdGhpcy5pbmRlbnRzLmxlbmd0aCAtIDFdKSAvLyBjb3VudCBpbmRlbnRzIG9yIGRlZGVudHNcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZW50cy5wdXNoKGNvbHVtbik7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKFNrLlRva2VuaXplci5Ub2tlbnMuVF9JTkRFTlQsIGxpbmUuc3Vic3RyaW5nKDAsIHBvcyksIFt0aGlzLmxudW0sIDBdLCBbdGhpcy5sbnVtLCBwb3NdLCBsaW5lKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdkb25lJztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB3aGlsZSAoY29sdW1uIDwgdGhpcy5pbmRlbnRzW3RoaXMuaW5kZW50cy5sZW5ndGggLSAxXSkge1xuXHQgICAgICAgICAgICBpZiAoIWNvbnRhaW5zKHRoaXMuaW5kZW50cywgY29sdW1uKSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZW50YXRpb25FcnJvcihcInVuaW5kZW50IGRvZXMgbm90IG1hdGNoIGFueSBvdXRlciBpbmRlbnRhdGlvbiBsZXZlbFwiLFxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZW5hbWUsIHRoaXMubG51bSwgcG9zLCBsaW5lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLmluZGVudHMuc3BsaWNlKHRoaXMuaW5kZW50cy5sZW5ndGggLSAxLCAxKTtcblx0ICAgICAgICAgICAgLy9wcmludChcImRlZGVudCBoZXJlXCIpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjayhTay5Ub2tlbml6ZXIuVG9rZW5zLlRfREVERU5ULCAnJywgW3RoaXMubG51bSwgcG9zXSwgW3RoaXMubG51bSwgcG9zXSwgbGluZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnZG9uZSc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIC8vIGNvbnRpbnVlZCBzdGF0ZW1lbnRcblx0ICAgIHtcblx0ICAgICAgICBpZiAoIWxpbmUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJFT0YgaW4gbXVsdGktbGluZSBzdGF0ZW1lbnRcIiwgdGhpcy5maWxlbmFtZSwgdGhpcy5sbnVtLCAwLCB7XG5cdCAgICAgICAgICAgICAgICBraW5kOiAnU1RBVEVNRU5UX0VPRicsXG5cdCAgICAgICAgICAgICAgICBwYXJlbmxldjogdGhpcy5wYXJlbmxldixcblx0ICAgICAgICAgICAgICAgIHBhcmVuc3RhY2s6IHRoaXMucGFyZW5zdGFja1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5jb250aW51ZWQgPSBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuXHQgICAgICAgIC8vcHJpbnQoXCJwb3M6XCIrcG9zK1wiOlwiK21heCk7XG5cdCAgICAgICAgLy8ganMgcmVnZXhlcyBkb24ndCByZXR1cm4gYW55IGluZm8gYWJvdXQgbWF0Y2hlcywgb3RoZXIgdGhhbiB0aGVcblx0ICAgICAgICAvLyBjb250ZW50LiB3ZSdkIGxpa2UgdG8gcHV0IGEgXFx3KyBiZWZvcmUgcHNldWRvbWF0Y2gsIGJ1dCB0aGVuIHdlXG5cdCAgICAgICAgLy8gY2FuJ3QgZ2V0IGFueSBkYXRhXG5cdCAgICAgICAgY2Fwb3MgPSBsaW5lLmNoYXJBdChwb3MpO1xuXHQgICAgICAgIHdoaWxlIChjYXBvcyA9PT0gJyAnIHx8IGNhcG9zID09PSAnXFxmJyB8fCBjYXBvcyA9PT0gJ1xcdCcpIHtcblx0ICAgICAgICAgICAgcG9zICs9IDE7XG5cdCAgICAgICAgICAgIGNhcG9zID0gbGluZS5jaGFyQXQocG9zKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcHNldWRvcHJvZy5sYXN0SW5kZXggPSAwO1xuXHQgICAgICAgIHBzZXVkb21hdGNoID0gcHNldWRvcHJvZy5leGVjKGxpbmUuc3Vic3RyaW5nKHBvcykpO1xuXHQgICAgICAgIGlmIChwc2V1ZG9tYXRjaCkge1xuXHQgICAgICAgICAgICBzdGFydCA9IHBvcztcblx0ICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBwc2V1ZG9tYXRjaFsxXS5sZW5ndGg7XG5cdCAgICAgICAgICAgIHNwb3MgPSBbdGhpcy5sbnVtLCBzdGFydF07XG5cdCAgICAgICAgICAgIGVwb3MgPSBbdGhpcy5sbnVtLCBlbmRdO1xuXHQgICAgICAgICAgICBwb3MgPSBlbmQ7XG5cdCAgICAgICAgICAgIHRva2VuID0gbGluZS5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG5cdCAgICAgICAgICAgIGluaXRpYWwgPSBsaW5lLmNoYXJBdChzdGFydCk7XG5cdCAgICAgICAgICAgIC8vU2suZGVidWdvdXQoXCJ0b2tlbjpcIix0b2tlbiwgXCJpbml0aWFsOlwiLGluaXRpYWwsIHN0YXJ0LCBlbmQpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5udW1jaGFycy5pbmRleE9mKGluaXRpYWwpICE9PSAtMSB8fCAoaW5pdGlhbCA9PT0gJy4nICYmIHRva2VuICE9PSAnLicpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjayhTay5Ub2tlbml6ZXIuVG9rZW5zLlRfTlVNQkVSLCB0b2tlbiwgc3BvcywgZXBvcywgbGluZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RvbmUnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGluaXRpYWwgPT09ICdcXHInIHx8IGluaXRpYWwgPT09ICdcXG4nKSB7XG5cdCAgICAgICAgICAgICAgICBuZXdsID0gU2suVG9rZW5pemVyLlRva2Vucy5UX05FV0xJTkU7XG5cdCAgICAgICAgICAgICAgICAvL3ByaW50KFwiSEVSRTozXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW5sZXYgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmV3bCA9IFNrLlRva2VuaXplci5Ub2tlbnMuVF9OTDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKG5ld2wsIHRva2VuLCBzcG9zLCBlcG9zLCBsaW5lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZG9uZSc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoaW5pdGlhbCA9PT0gJyMnKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjayhTay5Ub2tlbml6ZXIuVG9rZW5zLlRfQ09NTUVOVCwgdG9rZW4sIHNwb3MsIGVwb3MsIGxpbmUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkb25lJztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0cmlwbGVfcXVvdGVkLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbmRwcm9nID0gZW5kcHJvZ3NbdG9rZW5dO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbmRwcm9nLmxhc3RJbmRleCA9IDA7XG5cdCAgICAgICAgICAgICAgICBlbmRtYXRjaCA9IHRoaXMuZW5kcHJvZy50ZXN0KGxpbmUuc3Vic3RyaW5nKHBvcykpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGVuZG1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5lbmRwcm9nLmxhc3RJbmRleCArIHBvcztcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGxpbmUuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKFNrLlRva2VuaXplci5Ub2tlbnMuVF9TVFJJTkcsIHRva2VuLCBzcG9zLCBbdGhpcy5sbnVtLCBwb3NdLCBsaW5lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RvbmUnO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Ryc3RhcnQgPSBbdGhpcy5sbnVtLCBzdGFydF07XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250c3RyID0gbGluZS5zdWJzdHJpbmcoc3RhcnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGxpbmUgPSBsaW5lO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChzaW5nbGVfcXVvdGVkLmhhc093blByb3BlcnR5KGluaXRpYWwpIHx8XG5cdCAgICAgICAgICAgICAgICBzaW5nbGVfcXVvdGVkLmhhc093blByb3BlcnR5KHRva2VuLnN1YnN0cmluZygwLCAyKSkgfHxcblx0ICAgICAgICAgICAgICAgIHNpbmdsZV9xdW90ZWQuaGFzT3duUHJvcGVydHkodG9rZW4uc3Vic3RyaW5nKDAsIDMpKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuW3Rva2VuLmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Ryc3RhcnQgPSBbdGhpcy5sbnVtLCBzdGFydF07XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRwcm9nID0gZW5kcHJvZ3NbaW5pdGlhbF0gfHwgZW5kcHJvZ3NbdG9rZW5bMV1dIHx8IGVuZHByb2dzW3Rva2VuWzJdXTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRzdHIgPSBsaW5lLnN1YnN0cmluZyhzdGFydCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkY29udCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250bGluZSA9IGxpbmU7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9wcmludChcImksIHQxLCB0MlwiLCBpbml0aWFsLCB0b2tlblsxXSwgdG9rZW5bMl0pO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vcHJpbnQoXCJlcCwgY3NcIiwgdGhpcy5lbmRwcm9nLCB0aGlzLmNvbnRzdHIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrKFNrLlRva2VuaXplci5Ub2tlbnMuVF9TVFJJTkcsIHRva2VuLCBzcG9zLCBlcG9zLCBsaW5lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RvbmUnO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm5hbWVjaGFycy5pbmRleE9mKGluaXRpYWwpICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2soU2suVG9rZW5pemVyLlRva2Vucy5UX05BTUUsIHRva2VuLCBzcG9zLCBlcG9zLCBsaW5lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZG9uZSc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoaW5pdGlhbCA9PT0gJ1xcXFwnKSB7XG5cdCAgICAgICAgICAgICAgICAvL3ByaW50KFwiSEVSRTo0XCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2soU2suVG9rZW5pemVyLlRva2Vucy5UX05MLCB0b2tlbiwgc3BvcywgW3RoaXMubG51bSwgcG9zXSwgbGluZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RvbmUnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaWYgKCcoW3snLmluZGV4T2YoaW5pdGlhbCkgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbmxldiArPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW5zdGFjay5wdXNoKFtpbml0aWFsLCB0aGlzLmxudW0sIHBvc10pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoJyldfScuaW5kZXhPZihpbml0aWFsKSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVubGV2IC09IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2soU2suVG9rZW5pemVyLlRva2Vucy5UX09QLCB0b2tlbiwgc3BvcywgZXBvcywgbGluZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RvbmUnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjayhTay5Ub2tlbml6ZXIuVG9rZW5zLlRfRVJST1JUT0tFTiwgbGluZS5jaGFyQXQocG9zKSxcblx0ICAgICAgICAgICAgICAgIFt0aGlzLmxudW0sIHBvc10sIFt0aGlzLmxudW0sIHBvcyArIDFdLCBsaW5lKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICdkb25lJztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBwb3MgKz0gMTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRTay5Ub2tlbml6ZXIudG9rZW5OYW1lcyA9IHtcblx0ICAgIDAgIDogJ1RfRU5ETUFSS0VSJywgMTogJ1RfTkFNRScsIDI6ICdUX05VTUJFUicsIDM6ICdUX1NUUklORycsIDQ6ICdUX05FV0xJTkUnLFxuXHQgICAgNSAgOiAnVF9JTkRFTlQnLCA2OiAnVF9ERURFTlQnLCA3OiAnVF9MUEFSJywgODogJ1RfUlBBUicsIDk6ICdUX0xTUUInLFxuXHQgICAgMTAgOiAnVF9SU1FCJywgMTE6ICdUX0NPTE9OJywgMTI6ICdUX0NPTU1BJywgMTM6ICdUX1NFTUknLCAxNDogJ1RfUExVUycsXG5cdCAgICAxNSA6ICdUX01JTlVTJywgMTY6ICdUX1NUQVInLCAxNzogJ1RfU0xBU0gnLCAxODogJ1RfVkJBUicsIDE5OiAnVF9BTVBFUicsXG5cdCAgICAyMCA6ICdUX0xFU1MnLCAyMTogJ1RfR1JFQVRFUicsIDIyOiAnVF9FUVVBTCcsIDIzOiAnVF9ET1QnLCAyNDogJ1RfUEVSQ0VOVCcsXG5cdCAgICAyNSA6ICdUX0JBQ0tRVU9URScsIDI2OiAnVF9MQlJBQ0UnLCAyNzogJ1RfUkJSQUNFJywgMjg6ICdUX0VRRVFVQUwnLCAyOTogJ1RfTk9URVFVQUwnLFxuXHQgICAgMzAgOiAnVF9MRVNTRVFVQUwnLCAzMTogJ1RfR1JFQVRFUkVRVUFMJywgMzI6ICdUX1RJTERFJywgMzM6ICdUX0NJUkNVTUZMRVgnLCAzNDogJ1RfTEVGVFNISUZUJyxcblx0ICAgIDM1IDogJ1RfUklHSFRTSElGVCcsIDM2OiAnVF9ET1VCTEVTVEFSJywgMzc6ICdUX1BMVVNFUVVBTCcsIDM4OiAnVF9NSU5FUVVBTCcsIDM5OiAnVF9TVEFSRVFVQUwnLFxuXHQgICAgNDAgOiAnVF9TTEFTSEVRVUFMJywgNDE6ICdUX1BFUkNFTlRFUVVBTCcsIDQyOiAnVF9BTVBFUkVRVUFMJywgNDM6ICdUX1ZCQVJFUVVBTCcsIDQ0OiAnVF9DSVJDVU1GTEVYRVFVQUwnLFxuXHQgICAgNDUgOiAnVF9MRUZUU0hJRlRFUVVBTCcsIDQ2OiAnVF9SSUdIVFNISUZURVFVQUwnLCA0NzogJ1RfRE9VQkxFU1RBUkVRVUFMJywgNDg6ICdUX0RPVUJMRVNMQVNIJywgNDk6ICdUX0RPVUJMRVNMQVNIRVFVQUwnLFxuXHQgICAgNTAgOiAnVF9BVCcsIDUxOiAnVF9PUCcsIDUyOiAnVF9DT01NRU5UJywgNTM6ICdUX05MJywgNTQ6ICdUX1JBUlJPVycsXG5cdCAgICA1NSA6ICdUX0VSUk9SVE9LRU4nLCA1NjogJ1RfTl9UT0tFTlMnLFxuXHQgICAgMjU2OiAnVF9OVF9PRkZTRVQnXG5cdH07XG5cblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5Ub2tlbml6ZXJcIiwgU2suVG9rZW5pemVyKTtcblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5Ub2tlbml6ZXIucHJvdG90eXBlLmdlbmVyYXRlVG9rZW5zXCIsIFNrLlRva2VuaXplci5wcm90b3R5cGUuZ2VuZXJhdGVUb2tlbnMpO1xuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLlRva2VuaXplci50b2tlbk5hbWVzXCIsIFNrLlRva2VuaXplci50b2tlbk5hbWVzKTtcblxuXG5cblx0LyogLS0tLSAvVXNlcnMvcm9iL3NrdWxwdHkvbGliLy4uL25vZGVfbW9kdWxlcy9za3VscHQvZ2VuL3BhcnNlX3RhYmxlcy5qcyAtLS0tICovIFxuXG5cdC8vIGdlbmVyYXRlZCBieSBwZ2VuL21haW4ucHlcblx0U2suT3BNYXAgPSB7XG5cdFwiKFwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfTFBBUixcblx0XCIpXCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9SUEFSLFxuXHRcIltcIjogU2suVG9rZW5pemVyLlRva2Vucy5UX0xTUUIsXG5cdFwiXVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfUlNRQixcblx0XCI6XCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9DT0xPTixcblx0XCIsXCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9DT01NQSxcblx0XCI7XCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9TRU1JLFxuXHRcIitcIjogU2suVG9rZW5pemVyLlRva2Vucy5UX1BMVVMsXG5cdFwiLVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfTUlOVVMsXG5cdFwiKlwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfU1RBUixcblx0XCIvXCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9TTEFTSCxcblx0XCJ8XCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9WQkFSLFxuXHRcIiZcIjogU2suVG9rZW5pemVyLlRva2Vucy5UX0FNUEVSLFxuXHRcIjxcIjogU2suVG9rZW5pemVyLlRva2Vucy5UX0xFU1MsXG5cdFwiPlwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfR1JFQVRFUixcblx0XCI9XCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9FUVVBTCxcblx0XCIuXCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9ET1QsXG5cdFwiJVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfUEVSQ0VOVCxcblx0XCJgXCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9CQUNLUVVPVEUsXG5cdFwie1wiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfTEJSQUNFLFxuXHRcIn1cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX1JCUkFDRSxcblx0XCJAXCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9BVCxcblx0XCI9PVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfRVFFUVVBTCxcblx0XCIhPVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfTk9URVFVQUwsXG5cdFwiPD5cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX05PVEVRVUFMLFxuXHRcIjw9XCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9MRVNTRVFVQUwsXG5cdFwiPj1cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX0dSRUFURVJFUVVBTCxcblx0XCJ+XCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9USUxERSxcblx0XCJeXCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9DSVJDVU1GTEVYLFxuXHRcIjw8XCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9MRUZUU0hJRlQsXG5cdFwiPj5cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX1JJR0hUU0hJRlQsXG5cdFwiKipcIjogU2suVG9rZW5pemVyLlRva2Vucy5UX0RPVUJMRVNUQVIsXG5cdFwiKz1cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX1BMVVNFUVVBTCxcblx0XCItPVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfTUlORVFVQUwsXG5cdFwiKj1cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX1NUQVJFUVVBTCxcblx0XCIvPVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfU0xBU0hFUVVBTCxcblx0XCIlPVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfUEVSQ0VOVEVRVUFMLFxuXHRcIiY9XCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9BTVBFUkVRVUFMLFxuXHRcInw9XCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9WQkFSRVFVQUwsXG5cdFwiXj1cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX0NJUkNVTUZMRVhFUVVBTCxcblx0XCI8PD1cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX0xFRlRTSElGVEVRVUFMLFxuXHRcIj4+PVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfUklHSFRTSElGVEVRVUFMLFxuXHRcIioqPVwiOiBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfRE9VQkxFU1RBUkVRVUFMLFxuXHRcIi8vXCI6IFNrLlRva2VuaXplci5Ub2tlbnMuVF9ET1VCTEVTTEFTSCxcblx0XCIvLz1cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX0RPVUJMRVNMQVNIRVFVQUwsXG5cdFwiLT5cIjogU2suVG9rZW5pemVyLlRva2Vucy5UX1JBUlJPV1xuXHR9O1xuXHRTay5QYXJzZVRhYmxlcyA9IHtcblx0c3ltOlxuXHR7YW5kX2V4cHI6IDI1Nyxcblx0IGFuZF90ZXN0OiAyNTgsXG5cdCBhcmdsaXN0OiAyNTksXG5cdCBhcmd1bWVudDogMjYwLFxuXHQgYXJpdGhfZXhwcjogMjYxLFxuXHQgYXNzZXJ0X3N0bXQ6IDI2Mixcblx0IGF0b206IDI2Myxcblx0IGF1Z2Fzc2lnbjogMjY0LFxuXHQgYnJlYWtfc3RtdDogMjY1LFxuXHQgY2xhc3NkZWY6IDI2Nixcblx0IGNvbXBfZm9yOiAyNjcsXG5cdCBjb21wX2lmOiAyNjgsXG5cdCBjb21wX2l0ZXI6IDI2OSxcblx0IGNvbXBfb3A6IDI3MCxcblx0IGNvbXBhcmlzb246IDI3MSxcblx0IGNvbXBvdW5kX3N0bXQ6IDI3Mixcblx0IGNvbnRpbnVlX3N0bXQ6IDI3Myxcblx0IGRlYnVnZ2VyX3N0bXQ6IDI3NCxcblx0IGRlY29yYXRlZDogMjc1LFxuXHQgZGVjb3JhdG9yOiAyNzYsXG5cdCBkZWNvcmF0b3JzOiAyNzcsXG5cdCBkZWxfc3RtdDogMjc4LFxuXHQgZGljdG9yc2V0bWFrZXI6IDI3OSxcblx0IGRvdHRlZF9hc19uYW1lOiAyODAsXG5cdCBkb3R0ZWRfYXNfbmFtZXM6IDI4MSxcblx0IGRvdHRlZF9uYW1lOiAyODIsXG5cdCBlbmNvZGluZ19kZWNsOiAyODMsXG5cdCBldmFsX2lucHV0OiAyODQsXG5cdCBleGNlcHRfY2xhdXNlOiAyODUsXG5cdCBleGVjX3N0bXQ6IDI4Nixcblx0IGV4cHI6IDI4Nyxcblx0IGV4cHJfc3RtdDogMjg4LFxuXHQgZXhwcmxpc3Q6IDI4OSxcblx0IGZhY3RvcjogMjkwLFxuXHQgZmlsZV9pbnB1dDogMjkxLFxuXHQgZmxvd19zdG10OiAyOTIsXG5cdCBmb3Jfc3RtdDogMjkzLFxuXHQgZnBkZWY6IDI5NCxcblx0IGZwbGlzdDogMjk1LFxuXHQgZnVuY2RlZjogMjk2LFxuXHQgZ2xvYmFsX3N0bXQ6IDI5Nyxcblx0IGlmX3N0bXQ6IDI5OCxcblx0IGltcG9ydF9hc19uYW1lOiAyOTksXG5cdCBpbXBvcnRfYXNfbmFtZXM6IDMwMCxcblx0IGltcG9ydF9mcm9tOiAzMDEsXG5cdCBpbXBvcnRfbmFtZTogMzAyLFxuXHQgaW1wb3J0X3N0bXQ6IDMwMyxcblx0IGxhbWJkZWY6IDMwNCxcblx0IGxpc3RfZm9yOiAzMDUsXG5cdCBsaXN0X2lmOiAzMDYsXG5cdCBsaXN0X2l0ZXI6IDMwNyxcblx0IGxpc3RtYWtlcjogMzA4LFxuXHQgbm90X3Rlc3Q6IDMwOSxcblx0IG9sZF9sYW1iZGVmOiAzMTAsXG5cdCBvbGRfdGVzdDogMzExLFxuXHQgb3JfdGVzdDogMzEyLFxuXHQgcGFyYW1ldGVyczogMzEzLFxuXHQgcGFzc19zdG10OiAzMTQsXG5cdCBwb3dlcjogMzE1LFxuXHQgcHJpbnRfc3RtdDogMzE2LFxuXHQgcmFpc2Vfc3RtdDogMzE3LFxuXHQgcmV0dXJuX3N0bXQ6IDMxOCxcblx0IHNoaWZ0X2V4cHI6IDMxOSxcblx0IHNpbXBsZV9zdG10OiAzMjAsXG5cdCBzaW5nbGVfaW5wdXQ6IDI1Nixcblx0IHNsaWNlb3A6IDMyMSxcblx0IHNtYWxsX3N0bXQ6IDMyMixcblx0IHN0bXQ6IDMyMyxcblx0IHN1YnNjcmlwdDogMzI0LFxuXHQgc3Vic2NyaXB0bGlzdDogMzI1LFxuXHQgc3VpdGU6IDMyNixcblx0IHRlcm06IDMyNyxcblx0IHRlc3Q6IDMyOCxcblx0IHRlc3RsaXN0OiAzMjksXG5cdCB0ZXN0bGlzdDE6IDMzMCxcblx0IHRlc3RsaXN0X2NvbXA6IDMzMSxcblx0IHRlc3RsaXN0X3NhZmU6IDMzMixcblx0IHRyYWlsZXI6IDMzMyxcblx0IHRyeV9zdG10OiAzMzQsXG5cdCB2YXJhcmdzbGlzdDogMzM1LFxuXHQgd2hpbGVfc3RtdDogMzM2LFxuXHQgd2l0aF9pdGVtOiAzMzcsXG5cdCB3aXRoX3N0bXQ6IDMzOCxcblx0IHhvcl9leHByOiAzMzksXG5cdCB5aWVsZF9leHByOiAzNDAsXG5cdCB5aWVsZF9zdG10OiAzNDF9LFxuXHRudW1iZXIyc3ltYm9sOlxuXHR7MjU2OiAnc2luZ2xlX2lucHV0Jyxcblx0IDI1NzogJ2FuZF9leHByJyxcblx0IDI1ODogJ2FuZF90ZXN0Jyxcblx0IDI1OTogJ2FyZ2xpc3QnLFxuXHQgMjYwOiAnYXJndW1lbnQnLFxuXHQgMjYxOiAnYXJpdGhfZXhwcicsXG5cdCAyNjI6ICdhc3NlcnRfc3RtdCcsXG5cdCAyNjM6ICdhdG9tJyxcblx0IDI2NDogJ2F1Z2Fzc2lnbicsXG5cdCAyNjU6ICdicmVha19zdG10Jyxcblx0IDI2NjogJ2NsYXNzZGVmJyxcblx0IDI2NzogJ2NvbXBfZm9yJyxcblx0IDI2ODogJ2NvbXBfaWYnLFxuXHQgMjY5OiAnY29tcF9pdGVyJyxcblx0IDI3MDogJ2NvbXBfb3AnLFxuXHQgMjcxOiAnY29tcGFyaXNvbicsXG5cdCAyNzI6ICdjb21wb3VuZF9zdG10Jyxcblx0IDI3MzogJ2NvbnRpbnVlX3N0bXQnLFxuXHQgMjc0OiAnZGVidWdnZXJfc3RtdCcsXG5cdCAyNzU6ICdkZWNvcmF0ZWQnLFxuXHQgMjc2OiAnZGVjb3JhdG9yJyxcblx0IDI3NzogJ2RlY29yYXRvcnMnLFxuXHQgMjc4OiAnZGVsX3N0bXQnLFxuXHQgMjc5OiAnZGljdG9yc2V0bWFrZXInLFxuXHQgMjgwOiAnZG90dGVkX2FzX25hbWUnLFxuXHQgMjgxOiAnZG90dGVkX2FzX25hbWVzJyxcblx0IDI4MjogJ2RvdHRlZF9uYW1lJyxcblx0IDI4MzogJ2VuY29kaW5nX2RlY2wnLFxuXHQgMjg0OiAnZXZhbF9pbnB1dCcsXG5cdCAyODU6ICdleGNlcHRfY2xhdXNlJyxcblx0IDI4NjogJ2V4ZWNfc3RtdCcsXG5cdCAyODc6ICdleHByJyxcblx0IDI4ODogJ2V4cHJfc3RtdCcsXG5cdCAyODk6ICdleHBybGlzdCcsXG5cdCAyOTA6ICdmYWN0b3InLFxuXHQgMjkxOiAnZmlsZV9pbnB1dCcsXG5cdCAyOTI6ICdmbG93X3N0bXQnLFxuXHQgMjkzOiAnZm9yX3N0bXQnLFxuXHQgMjk0OiAnZnBkZWYnLFxuXHQgMjk1OiAnZnBsaXN0Jyxcblx0IDI5NjogJ2Z1bmNkZWYnLFxuXHQgMjk3OiAnZ2xvYmFsX3N0bXQnLFxuXHQgMjk4OiAnaWZfc3RtdCcsXG5cdCAyOTk6ICdpbXBvcnRfYXNfbmFtZScsXG5cdCAzMDA6ICdpbXBvcnRfYXNfbmFtZXMnLFxuXHQgMzAxOiAnaW1wb3J0X2Zyb20nLFxuXHQgMzAyOiAnaW1wb3J0X25hbWUnLFxuXHQgMzAzOiAnaW1wb3J0X3N0bXQnLFxuXHQgMzA0OiAnbGFtYmRlZicsXG5cdCAzMDU6ICdsaXN0X2ZvcicsXG5cdCAzMDY6ICdsaXN0X2lmJyxcblx0IDMwNzogJ2xpc3RfaXRlcicsXG5cdCAzMDg6ICdsaXN0bWFrZXInLFxuXHQgMzA5OiAnbm90X3Rlc3QnLFxuXHQgMzEwOiAnb2xkX2xhbWJkZWYnLFxuXHQgMzExOiAnb2xkX3Rlc3QnLFxuXHQgMzEyOiAnb3JfdGVzdCcsXG5cdCAzMTM6ICdwYXJhbWV0ZXJzJyxcblx0IDMxNDogJ3Bhc3Nfc3RtdCcsXG5cdCAzMTU6ICdwb3dlcicsXG5cdCAzMTY6ICdwcmludF9zdG10Jyxcblx0IDMxNzogJ3JhaXNlX3N0bXQnLFxuXHQgMzE4OiAncmV0dXJuX3N0bXQnLFxuXHQgMzE5OiAnc2hpZnRfZXhwcicsXG5cdCAzMjA6ICdzaW1wbGVfc3RtdCcsXG5cdCAzMjE6ICdzbGljZW9wJyxcblx0IDMyMjogJ3NtYWxsX3N0bXQnLFxuXHQgMzIzOiAnc3RtdCcsXG5cdCAzMjQ6ICdzdWJzY3JpcHQnLFxuXHQgMzI1OiAnc3Vic2NyaXB0bGlzdCcsXG5cdCAzMjY6ICdzdWl0ZScsXG5cdCAzMjc6ICd0ZXJtJyxcblx0IDMyODogJ3Rlc3QnLFxuXHQgMzI5OiAndGVzdGxpc3QnLFxuXHQgMzMwOiAndGVzdGxpc3QxJyxcblx0IDMzMTogJ3Rlc3RsaXN0X2NvbXAnLFxuXHQgMzMyOiAndGVzdGxpc3Rfc2FmZScsXG5cdCAzMzM6ICd0cmFpbGVyJyxcblx0IDMzNDogJ3RyeV9zdG10Jyxcblx0IDMzNTogJ3ZhcmFyZ3NsaXN0Jyxcblx0IDMzNjogJ3doaWxlX3N0bXQnLFxuXHQgMzM3OiAnd2l0aF9pdGVtJyxcblx0IDMzODogJ3dpdGhfc3RtdCcsXG5cdCAzMzk6ICd4b3JfZXhwcicsXG5cdCAzNDA6ICd5aWVsZF9leHByJyxcblx0IDM0MTogJ3lpZWxkX3N0bXQnfSxcblx0ZGZhczpcblx0ezI1NjogW1tbWzEsIDFdLCBbMiwgMV0sIFszLCAyXV0sIFtbMCwgMV1dLCBbWzIsIDFdXV0sXG5cdCAgICAgICB7MjogMSxcblx0ICAgICAgICA0OiAxLFxuXHQgICAgICAgIDU6IDEsXG5cdCAgICAgICAgNjogMSxcblx0ICAgICAgICA3OiAxLFxuXHQgICAgICAgIDg6IDEsXG5cdCAgICAgICAgOTogMSxcblx0ICAgICAgICAxMDogMSxcblx0ICAgICAgICAxMTogMSxcblx0ICAgICAgICAxMjogMSxcblx0ICAgICAgICAxMzogMSxcblx0ICAgICAgICAxNDogMSxcblx0ICAgICAgICAxNTogMSxcblx0ICAgICAgICAxNjogMSxcblx0ICAgICAgICAxNzogMSxcblx0ICAgICAgICAxODogMSxcblx0ICAgICAgICAxOTogMSxcblx0ICAgICAgICAyMDogMSxcblx0ICAgICAgICAyMTogMSxcblx0ICAgICAgICAyMjogMSxcblx0ICAgICAgICAyMzogMSxcblx0ICAgICAgICAyNDogMSxcblx0ICAgICAgICAyNTogMSxcblx0ICAgICAgICAyNjogMSxcblx0ICAgICAgICAyNzogMSxcblx0ICAgICAgICAyODogMSxcblx0ICAgICAgICAyOTogMSxcblx0ICAgICAgICAzMDogMSxcblx0ICAgICAgICAzMTogMSxcblx0ICAgICAgICAzMjogMSxcblx0ICAgICAgICAzMzogMSxcblx0ICAgICAgICAzNDogMSxcblx0ICAgICAgICAzNTogMSxcblx0ICAgICAgICAzNjogMSxcblx0ICAgICAgICAzNzogMX1dLFxuXHQgMjU3OiBbW1tbMzgsIDFdXSwgW1szOSwgMF0sIFswLCAxXV1dLFxuXHQgICAgICAgezY6IDEsIDg6IDEsIDk6IDEsIDE0OiAxLCAxNTogMSwgMTk6IDEsIDIyOiAxLCAyNjogMSwgMzA6IDEsIDM3OiAxfV0sXG5cdCAyNTg6IFtbW1s0MCwgMV1dLCBbWzQxLCAwXSwgWzAsIDFdXV0sXG5cdCAgICAgICB7NjogMSxcblx0ICAgICAgICA3OiAxLFxuXHQgICAgICAgIDg6IDEsXG5cdCAgICAgICAgOTogMSxcblx0ICAgICAgICAxNDogMSxcblx0ICAgICAgICAxNTogMSxcblx0ICAgICAgICAxOTogMSxcblx0ICAgICAgICAyMjogMSxcblx0ICAgICAgICAyNjogMSxcblx0ICAgICAgICAzMDogMSxcblx0ICAgICAgICAzNzogMX1dLFxuXHQgMjU5OiBbW1tbNDIsIDFdLCBbNDMsIDJdLCBbNDQsIDNdXSxcblx0ICAgICAgICBbWzQ1LCA0XV0sXG5cdCAgICAgICAgW1s0NiwgNV0sIFswLCAyXV0sXG5cdCAgICAgICAgW1s0NSwgNl1dLFxuXHQgICAgICAgIFtbNDYsIDddLCBbMCwgNF1dLFxuXHQgICAgICAgIFtbNDIsIDFdLCBbNDMsIDJdLCBbNDQsIDNdLCBbMCwgNV1dLFxuXHQgICAgICAgIFtbMCwgNl1dLFxuXHQgICAgICAgIFtbNDMsIDRdLCBbNDQsIDNdXV0sXG5cdCAgICAgICB7NjogMSxcblx0ICAgICAgICA3OiAxLFxuXHQgICAgICAgIDg6IDEsXG5cdCAgICAgICAgOTogMSxcblx0ICAgICAgICAxMTogMSxcblx0ICAgICAgICAxNDogMSxcblx0ICAgICAgICAxNTogMSxcblx0ICAgICAgICAxOTogMSxcblx0ICAgICAgICAyMjogMSxcblx0ICAgICAgICAyNjogMSxcblx0ICAgICAgICAzMDogMSxcblx0ICAgICAgICAzNzogMSxcblx0ICAgICAgICA0MjogMSxcblx0ICAgICAgICA0NDogMX1dLFxuXHQgMjYwOiBbW1tbNDUsIDFdXSwgW1s0NywgMl0sIFs0OCwgM10sIFswLCAxXV0sIFtbNDUsIDNdXSwgW1swLCAzXV1dLFxuXHQgICAgICAgezY6IDEsXG5cdCAgICAgICAgNzogMSxcblx0ICAgICAgICA4OiAxLFxuXHQgICAgICAgIDk6IDEsXG5cdCAgICAgICAgMTE6IDEsXG5cdCAgICAgICAgMTQ6IDEsXG5cdCAgICAgICAgMTU6IDEsXG5cdCAgICAgICAgMTk6IDEsXG5cdCAgICAgICAgMjI6IDEsXG5cdCAgICAgICAgMjY6IDEsXG5cdCAgICAgICAgMzA6IDEsXG5cdCAgICAgICAgMzc6IDF9XSxcblx0IDI2MTogW1tbWzQ5LCAxXV0sIFtbMjYsIDBdLCBbMzcsIDBdLCBbMCwgMV1dXSxcblx0ICAgICAgIHs2OiAxLCA4OiAxLCA5OiAxLCAxNDogMSwgMTU6IDEsIDE5OiAxLCAyMjogMSwgMjY6IDEsIDMwOiAxLCAzNzogMX1dLFxuXHQgMjYyOiBbW1tbMjEsIDFdXSwgW1s0NSwgMl1dLCBbWzQ2LCAzXSwgWzAsIDJdXSwgW1s0NSwgNF1dLCBbWzAsIDRdXV0sXG5cdCAgICAgICB7MjE6IDF9XSxcblx0IDI2MzogW1tbWzE5LCAxXSwgWzgsIDJdLCBbOSwgNV0sIFszMCwgNF0sIFsxNCwgM10sIFsxNSwgNl0sIFsyMiwgMl1dLFxuXHQgICAgICAgIFtbMTksIDFdLCBbMCwgMV1dLFxuXHQgICAgICAgIFtbMCwgMl1dLFxuXHQgICAgICAgIFtbNTAsIDddLCBbNTEsIDJdXSxcblx0ICAgICAgICBbWzUyLCAyXSwgWzUzLCA4XSwgWzU0LCA4XV0sXG5cdCAgICAgICAgW1s1NSwgMl0sIFs1NiwgOV1dLFxuXHQgICAgICAgIFtbNTcsIDEwXV0sXG5cdCAgICAgICAgW1s1MSwgMl1dLFxuXHQgICAgICAgIFtbNTIsIDJdXSxcblx0ICAgICAgICBbWzU1LCAyXV0sXG5cdCAgICAgICAgW1sxNSwgMl1dXSxcblx0ICAgICAgIHs4OiAxLCA5OiAxLCAxNDogMSwgMTU6IDEsIDE5OiAxLCAyMjogMSwgMzA6IDF9XSxcblx0IDI2NDogW1tbWzU4LCAxXSxcblx0ICAgICAgICAgWzU5LCAxXSxcblx0ICAgICAgICAgWzYwLCAxXSxcblx0ICAgICAgICAgWzYxLCAxXSxcblx0ICAgICAgICAgWzYyLCAxXSxcblx0ICAgICAgICAgWzYzLCAxXSxcblx0ICAgICAgICAgWzY0LCAxXSxcblx0ICAgICAgICAgWzY1LCAxXSxcblx0ICAgICAgICAgWzY2LCAxXSxcblx0ICAgICAgICAgWzY3LCAxXSxcblx0ICAgICAgICAgWzY4LCAxXSxcblx0ICAgICAgICAgWzY5LCAxXV0sXG5cdCAgICAgICAgW1swLCAxXV1dLFxuXHQgICAgICAgezU4OiAxLFxuXHQgICAgICAgIDU5OiAxLFxuXHQgICAgICAgIDYwOiAxLFxuXHQgICAgICAgIDYxOiAxLFxuXHQgICAgICAgIDYyOiAxLFxuXHQgICAgICAgIDYzOiAxLFxuXHQgICAgICAgIDY0OiAxLFxuXHQgICAgICAgIDY1OiAxLFxuXHQgICAgICAgIDY2OiAxLFxuXHQgICAgICAgIDY3OiAxLFxuXHQgICAgICAgIDY4OiAxLFxuXHQgICAgICAgIDY5OiAxfV0sXG5cdCAyNjU6IFtbW1szMywgMV1dLCBbWzAsIDFdXV0sIHszMzogMX1dLFxuXHQgMjY2OiBbW1tbMTAsIDFdXSxcblx0ICAgICAgICBbWzIyLCAyXV0sXG5cdCAgICAgICAgW1s3MCwgM10sIFszMCwgNF1dLFxuXHQgICAgICAgIFtbNzEsIDVdXSxcblx0ICAgICAgICBbWzUyLCA2XSwgWzcyLCA3XV0sXG5cdCAgICAgICAgW1swLCA1XV0sXG5cdCAgICAgICAgW1s3MCwgM11dLFxuXHQgICAgICAgIFtbNTIsIDZdXV0sXG5cdCAgICAgICB7MTA6IDF9XSxcblx0IDI2NzogW1tbWzI5LCAxXV0sXG5cdCAgICAgICAgW1s3MywgMl1dLFxuXHQgICAgICAgIFtbNzQsIDNdXSxcblx0ICAgICAgICBbWzc1LCA0XV0sXG5cdCAgICAgICAgW1s3NiwgNV0sIFswLCA0XV0sXG5cdCAgICAgICAgW1swLCA1XV1dLFxuXHQgICAgICAgezI5OiAxfV0sXG5cdCAyNjg6IFtbW1szMiwgMV1dLCBbWzc3LCAyXV0sIFtbNzYsIDNdLCBbMCwgMl1dLCBbWzAsIDNdXV0sIHszMjogMX1dLFxuXHQgMjY5OiBbW1tbNzgsIDFdLCBbNDgsIDFdXSwgW1swLCAxXV1dLCB7Mjk6IDEsIDMyOiAxfV0sXG5cdCAyNzA6IFtbW1s3OSwgMV0sXG5cdCAgICAgICAgIFs4MCwgMV0sXG5cdCAgICAgICAgIFs3LCAyXSxcblx0ICAgICAgICAgWzgxLCAxXSxcblx0ICAgICAgICAgWzc5LCAxXSxcblx0ICAgICAgICAgWzc0LCAxXSxcblx0ICAgICAgICAgWzgyLCAxXSxcblx0ICAgICAgICAgWzgzLCAzXSxcblx0ICAgICAgICAgWzg0LCAxXSxcblx0ICAgICAgICAgWzg1LCAxXV0sXG5cdCAgICAgICAgW1swLCAxXV0sXG5cdCAgICAgICAgW1s3NCwgMV1dLFxuXHQgICAgICAgIFtbNywgMV0sIFswLCAzXV1dLFxuXHQgICAgICAgezc6IDEsIDc0OiAxLCA3OTogMSwgODA6IDEsIDgxOiAxLCA4MjogMSwgODM6IDEsIDg0OiAxLCA4NTogMX1dLFxuXHQgMjcxOiBbW1tbODYsIDFdXSwgW1s4NywgMF0sIFswLCAxXV1dLFxuXHQgICAgICAgezY6IDEsIDg6IDEsIDk6IDEsIDE0OiAxLCAxNTogMSwgMTk6IDEsIDIyOiAxLCAyNjogMSwgMzA6IDEsIDM3OiAxfV0sXG5cdCAyNzI6IFtbW1s4OCwgMV0sXG5cdCAgICAgICAgIFs4OSwgMV0sXG5cdCAgICAgICAgIFs5MCwgMV0sXG5cdCAgICAgICAgIFs5MSwgMV0sXG5cdCAgICAgICAgIFs5MiwgMV0sXG5cdCAgICAgICAgIFs5MywgMV0sXG5cdCAgICAgICAgIFs5NCwgMV0sXG5cdCAgICAgICAgIFs5NSwgMV1dLFxuXHQgICAgICAgIFtbMCwgMV1dXSxcblx0ICAgICAgIHs0OiAxLCAxMDogMSwgMTY6IDEsIDE4OiAxLCAyOTogMSwgMzI6IDEsIDM1OiAxLCAzNjogMX1dLFxuXHQgMjczOiBbW1tbMzQsIDFdXSwgW1swLCAxXV1dLCB7MzQ6IDF9XSxcblx0IDI3NDogW1tbWzEzLCAxXV0sIFtbMCwgMV1dXSwgezEzOiAxfV0sXG5cdCAyNzU6IFtbW1s5NiwgMV1dLCBbWzk0LCAyXSwgWzkxLCAyXV0sIFtbMCwgMl1dXSwgezM1OiAxfV0sXG5cdCAyNzY6IFtbW1szNSwgMV1dLFxuXHQgICAgICAgIFtbOTcsIDJdXSxcblx0ICAgICAgICBbWzIsIDRdLCBbMzAsIDNdXSxcblx0ICAgICAgICBbWzUyLCA1XSwgWzk4LCA2XV0sXG5cdCAgICAgICAgW1swLCA0XV0sXG5cdCAgICAgICAgW1syLCA0XV0sXG5cdCAgICAgICAgW1s1MiwgNV1dXSxcblx0ICAgICAgIHszNTogMX1dLFxuXHQgMjc3OiBbW1tbOTksIDFdXSwgW1s5OSwgMV0sIFswLCAxXV1dLCB7MzU6IDF9XSxcblx0IDI3ODogW1tbWzIzLCAxXV0sIFtbNzMsIDJdXSwgW1swLCAyXV1dLCB7MjM6IDF9XSxcblx0IDI3OTogW1tbWzQ1LCAxXV0sXG5cdCAgICAgICAgW1s3MCwgMl0sIFs0OCwgM10sIFs0NiwgNF0sIFswLCAxXV0sXG5cdCAgICAgICAgW1s0NSwgNV1dLFxuXHQgICAgICAgIFtbMCwgM11dLFxuXHQgICAgICAgIFtbNDUsIDZdLCBbMCwgNF1dLFxuXHQgICAgICAgIFtbNDgsIDNdLCBbNDYsIDddLCBbMCwgNV1dLFxuXHQgICAgICAgIFtbNDYsIDRdLCBbMCwgNl1dLFxuXHQgICAgICAgIFtbNDUsIDhdLCBbMCwgN11dLFxuXHQgICAgICAgIFtbNzAsIDldXSxcblx0ICAgICAgICBbWzQ1LCAxMF1dLFxuXHQgICAgICAgIFtbNDYsIDddLCBbMCwgMTBdXV0sXG5cdCAgICAgICB7NjogMSxcblx0ICAgICAgICA3OiAxLFxuXHQgICAgICAgIDg6IDEsXG5cdCAgICAgICAgOTogMSxcblx0ICAgICAgICAxMTogMSxcblx0ICAgICAgICAxNDogMSxcblx0ICAgICAgICAxNTogMSxcblx0ICAgICAgICAxOTogMSxcblx0ICAgICAgICAyMjogMSxcblx0ICAgICAgICAyNjogMSxcblx0ICAgICAgICAzMDogMSxcblx0ICAgICAgICAzNzogMX1dLFxuXHQgMjgwOiBbW1tbOTcsIDFdXSwgW1sxMDAsIDJdLCBbMCwgMV1dLCBbWzIyLCAzXV0sIFtbMCwgM11dXSwgezIyOiAxfV0sXG5cdCAyODE6IFtbW1sxMDEsIDFdXSwgW1s0NiwgMF0sIFswLCAxXV1dLCB7MjI6IDF9XSxcblx0IDI4MjogW1tbWzIyLCAxXV0sIFtbMTAyLCAwXSwgWzAsIDFdXV0sIHsyMjogMX1dLFxuXHQgMjgzOiBbW1tbMjIsIDFdXSwgW1swLCAxXV1dLCB7MjI6IDF9XSxcblx0IDI4NDogW1tbWzcyLCAxXV0sIFtbMiwgMV0sIFsxMDMsIDJdXSwgW1swLCAyXV1dLFxuXHQgICAgICAgezY6IDEsXG5cdCAgICAgICAgNzogMSxcblx0ICAgICAgICA4OiAxLFxuXHQgICAgICAgIDk6IDEsXG5cdCAgICAgICAgMTE6IDEsXG5cdCAgICAgICAgMTQ6IDEsXG5cdCAgICAgICAgMTU6IDEsXG5cdCAgICAgICAgMTk6IDEsXG5cdCAgICAgICAgMjI6IDEsXG5cdCAgICAgICAgMjY6IDEsXG5cdCAgICAgICAgMzA6IDEsXG5cdCAgICAgICAgMzc6IDF9XSxcblx0IDI4NTogW1tbWzEwNCwgMV1dLFxuXHQgICAgICAgIFtbNDUsIDJdLCBbMCwgMV1dLFxuXHQgICAgICAgIFtbMTAwLCAzXSwgWzQ2LCAzXSwgWzAsIDJdXSxcblx0ICAgICAgICBbWzQ1LCA0XV0sXG5cdCAgICAgICAgW1swLCA0XV1dLFxuXHQgICAgICAgezEwNDogMX1dLFxuXHQgMjg2OiBbW1tbMTcsIDFdXSxcblx0ICAgICAgICBbWzg2LCAyXV0sXG5cdCAgICAgICAgW1s3NCwgM10sIFswLCAyXV0sXG5cdCAgICAgICAgW1s0NSwgNF1dLFxuXHQgICAgICAgIFtbNDYsIDVdLCBbMCwgNF1dLFxuXHQgICAgICAgIFtbNDUsIDZdXSxcblx0ICAgICAgICBbWzAsIDZdXV0sXG5cdCAgICAgICB7MTc6IDF9XSxcblx0IDI4NzogW1tbWzEwNSwgMV1dLCBbWzEwNiwgMF0sIFswLCAxXV1dLFxuXHQgICAgICAgezY6IDEsIDg6IDEsIDk6IDEsIDE0OiAxLCAxNTogMSwgMTk6IDEsIDIyOiAxLCAyNjogMSwgMzA6IDEsIDM3OiAxfV0sXG5cdCAyODg6IFtbW1s3MiwgMV1dLFxuXHQgICAgICAgIFtbMTA3LCAyXSwgWzQ3LCAzXSwgWzAsIDFdXSxcblx0ICAgICAgICBbWzcyLCA0XSwgWzUzLCA0XV0sXG5cdCAgICAgICAgW1s3MiwgNV0sIFs1MywgNV1dLFxuXHQgICAgICAgIFtbMCwgNF1dLFxuXHQgICAgICAgIFtbNDcsIDNdLCBbMCwgNV1dXSxcblx0ICAgICAgIHs2OiAxLFxuXHQgICAgICAgIDc6IDEsXG5cdCAgICAgICAgODogMSxcblx0ICAgICAgICA5OiAxLFxuXHQgICAgICAgIDExOiAxLFxuXHQgICAgICAgIDE0OiAxLFxuXHQgICAgICAgIDE1OiAxLFxuXHQgICAgICAgIDE5OiAxLFxuXHQgICAgICAgIDIyOiAxLFxuXHQgICAgICAgIDI2OiAxLFxuXHQgICAgICAgIDMwOiAxLFxuXHQgICAgICAgIDM3OiAxfV0sXG5cdCAyODk6IFtbW1s4NiwgMV1dLCBbWzQ2LCAyXSwgWzAsIDFdXSwgW1s4NiwgMV0sIFswLCAyXV1dLFxuXHQgICAgICAgezY6IDEsIDg6IDEsIDk6IDEsIDE0OiAxLCAxNTogMSwgMTk6IDEsIDIyOiAxLCAyNjogMSwgMzA6IDEsIDM3OiAxfV0sXG5cdCAyOTA6IFtbW1szNywgMl0sIFsyNiwgMl0sIFs2LCAyXSwgWzEwOCwgMV1dLCBbWzAsIDFdXSwgW1sxMDksIDFdXV0sXG5cdCAgICAgICB7NjogMSwgODogMSwgOTogMSwgMTQ6IDEsIDE1OiAxLCAxOTogMSwgMjI6IDEsIDI2OiAxLCAzMDogMSwgMzc6IDF9XSxcblx0IDI5MTogW1tbWzIsIDBdLCBbMTAzLCAxXSwgWzExMCwgMF1dLCBbWzAsIDFdXV0sXG5cdCAgICAgICB7MjogMSxcblx0ICAgICAgICA0OiAxLFxuXHQgICAgICAgIDU6IDEsXG5cdCAgICAgICAgNjogMSxcblx0ICAgICAgICA3OiAxLFxuXHQgICAgICAgIDg6IDEsXG5cdCAgICAgICAgOTogMSxcblx0ICAgICAgICAxMDogMSxcblx0ICAgICAgICAxMTogMSxcblx0ICAgICAgICAxMjogMSxcblx0ICAgICAgICAxMzogMSxcblx0ICAgICAgICAxNDogMSxcblx0ICAgICAgICAxNTogMSxcblx0ICAgICAgICAxNjogMSxcblx0ICAgICAgICAxNzogMSxcblx0ICAgICAgICAxODogMSxcblx0ICAgICAgICAxOTogMSxcblx0ICAgICAgICAyMDogMSxcblx0ICAgICAgICAyMTogMSxcblx0ICAgICAgICAyMjogMSxcblx0ICAgICAgICAyMzogMSxcblx0ICAgICAgICAyNDogMSxcblx0ICAgICAgICAyNTogMSxcblx0ICAgICAgICAyNjogMSxcblx0ICAgICAgICAyNzogMSxcblx0ICAgICAgICAyODogMSxcblx0ICAgICAgICAyOTogMSxcblx0ICAgICAgICAzMDogMSxcblx0ICAgICAgICAzMTogMSxcblx0ICAgICAgICAzMjogMSxcblx0ICAgICAgICAzMzogMSxcblx0ICAgICAgICAzNDogMSxcblx0ICAgICAgICAzNTogMSxcblx0ICAgICAgICAzNjogMSxcblx0ICAgICAgICAzNzogMSxcblx0ICAgICAgICAxMDM6IDF9XSxcblx0IDI5MjogW1tbWzExMSwgMV0sIFsxMTIsIDFdLCBbMTEzLCAxXSwgWzExNCwgMV0sIFsxMTUsIDFdXSwgW1swLCAxXV1dLFxuXHQgICAgICAgezU6IDEsIDIwOiAxLCAyNzogMSwgMzM6IDEsIDM0OiAxfV0sXG5cdCAyOTM6IFtbW1syOSwgMV1dLFxuXHQgICAgICAgIFtbNzMsIDJdXSxcblx0ICAgICAgICBbWzc0LCAzXV0sXG5cdCAgICAgICAgW1s3MiwgNF1dLFxuXHQgICAgICAgIFtbNzAsIDVdXSxcblx0ICAgICAgICBbWzcxLCA2XV0sXG5cdCAgICAgICAgW1sxMTYsIDddLCBbMCwgNl1dLFxuXHQgICAgICAgIFtbNzAsIDhdXSxcblx0ICAgICAgICBbWzcxLCA5XV0sXG5cdCAgICAgICAgW1swLCA5XV1dLFxuXHQgICAgICAgezI5OiAxfV0sXG5cdCAyOTQ6IFtbW1szMCwgMV0sIFsyMiwgMl1dLCBbWzExNywgM11dLCBbWzAsIDJdXSwgW1s1MiwgMl1dXSwgezIyOiAxLCAzMDogMX1dLFxuXHQgMjk1OiBbW1tbMTE4LCAxXV0sIFtbNDYsIDJdLCBbMCwgMV1dLCBbWzExOCwgMV0sIFswLCAyXV1dLCB7MjI6IDEsIDMwOiAxfV0sXG5cdCAyOTY6IFtbW1s0LCAxXV0sIFtbMjIsIDJdXSwgW1sxMTksIDNdXSwgW1s3MCwgNF1dLCBbWzcxLCA1XV0sIFtbMCwgNV1dXSxcblx0ICAgICAgIHs0OiAxfV0sXG5cdCAyOTc6IFtbW1syOCwgMV1dLCBbWzIyLCAyXV0sIFtbNDYsIDFdLCBbMCwgMl1dXSwgezI4OiAxfV0sXG5cdCAyOTg6IFtbW1szMiwgMV1dLFxuXHQgICAgICAgIFtbNDUsIDJdXSxcblx0ICAgICAgICBbWzcwLCAzXV0sXG5cdCAgICAgICAgW1s3MSwgNF1dLFxuXHQgICAgICAgIFtbMTE2LCA1XSwgWzEyMCwgMV0sIFswLCA0XV0sXG5cdCAgICAgICAgW1s3MCwgNl1dLFxuXHQgICAgICAgIFtbNzEsIDddXSxcblx0ICAgICAgICBbWzAsIDddXV0sXG5cdCAgICAgICB7MzI6IDF9XSxcblx0IDI5OTogW1tbWzIyLCAxXV0sIFtbMTAwLCAyXSwgWzAsIDFdXSwgW1syMiwgM11dLCBbWzAsIDNdXV0sIHsyMjogMX1dLFxuXHQgMzAwOiBbW1tbMTIxLCAxXV0sIFtbNDYsIDJdLCBbMCwgMV1dLCBbWzEyMSwgMV0sIFswLCAyXV1dLCB7MjI6IDF9XSxcblx0IDMwMTogW1tbWzMxLCAxXV0sXG5cdCAgICAgICAgW1s5NywgMl0sIFsxMDIsIDNdXSxcblx0ICAgICAgICBbWzI1LCA0XV0sXG5cdCAgICAgICAgW1s5NywgMl0sIFsyNSwgNF0sIFsxMDIsIDNdXSxcblx0ICAgICAgICBbWzEyMiwgNV0sIFs0MiwgNV0sIFszMCwgNl1dLFxuXHQgICAgICAgIFtbMCwgNV1dLFxuXHQgICAgICAgIFtbMTIyLCA3XV0sXG5cdCAgICAgICAgW1s1MiwgNV1dXSxcblx0ICAgICAgIHszMTogMX1dLFxuXHQgMzAyOiBbW1tbMjUsIDFdXSwgW1sxMjMsIDJdXSwgW1swLCAyXV1dLCB7MjU6IDF9XSxcblx0IDMwMzogW1tbWzEyNCwgMV0sIFsxMjUsIDFdXSwgW1swLCAxXV1dLCB7MjU6IDEsIDMxOiAxfV0sXG5cdCAzMDQ6IFtbW1sxMSwgMV1dLCBbWzcwLCAyXSwgWzEyNiwgM11dLCBbWzQ1LCA0XV0sIFtbNzAsIDJdXSwgW1swLCA0XV1dLFxuXHQgICAgICAgezExOiAxfV0sXG5cdCAzMDU6IFtbW1syOSwgMV1dLFxuXHQgICAgICAgIFtbNzMsIDJdXSxcblx0ICAgICAgICBbWzc0LCAzXV0sXG5cdCAgICAgICAgW1sxMjcsIDRdXSxcblx0ICAgICAgICBbWzEyOCwgNV0sIFswLCA0XV0sXG5cdCAgICAgICAgW1swLCA1XV1dLFxuXHQgICAgICAgezI5OiAxfV0sXG5cdCAzMDY6IFtbW1szMiwgMV1dLCBbWzc3LCAyXV0sIFtbMTI4LCAzXSwgWzAsIDJdXSwgW1swLCAzXV1dLCB7MzI6IDF9XSxcblx0IDMwNzogW1tbWzEyOSwgMV0sIFsxMzAsIDFdXSwgW1swLCAxXV1dLCB7Mjk6IDEsIDMyOiAxfV0sXG5cdCAzMDg6IFtbW1s0NSwgMV1dLFxuXHQgICAgICAgIFtbMTI5LCAyXSwgWzQ2LCAzXSwgWzAsIDFdXSxcblx0ICAgICAgICBbWzAsIDJdXSxcblx0ICAgICAgICBbWzQ1LCA0XSwgWzAsIDNdXSxcblx0ICAgICAgICBbWzQ2LCAzXSwgWzAsIDRdXV0sXG5cdCAgICAgICB7NjogMSxcblx0ICAgICAgICA3OiAxLFxuXHQgICAgICAgIDg6IDEsXG5cdCAgICAgICAgOTogMSxcblx0ICAgICAgICAxMTogMSxcblx0ICAgICAgICAxNDogMSxcblx0ICAgICAgICAxNTogMSxcblx0ICAgICAgICAxOTogMSxcblx0ICAgICAgICAyMjogMSxcblx0ICAgICAgICAyNjogMSxcblx0ICAgICAgICAzMDogMSxcblx0ICAgICAgICAzNzogMX1dLFxuXHQgMzA5OiBbW1tbNywgMV0sIFsxMzEsIDJdXSwgW1s0MCwgMl1dLCBbWzAsIDJdXV0sXG5cdCAgICAgICB7NjogMSxcblx0ICAgICAgICA3OiAxLFxuXHQgICAgICAgIDg6IDEsXG5cdCAgICAgICAgOTogMSxcblx0ICAgICAgICAxNDogMSxcblx0ICAgICAgICAxNTogMSxcblx0ICAgICAgICAxOTogMSxcblx0ICAgICAgICAyMjogMSxcblx0ICAgICAgICAyNjogMSxcblx0ICAgICAgICAzMDogMSxcblx0ICAgICAgICAzNzogMX1dLFxuXHQgMzEwOiBbW1tbMTEsIDFdXSwgW1s3MCwgMl0sIFsxMjYsIDNdXSwgW1s3NywgNF1dLCBbWzcwLCAyXV0sIFtbMCwgNF1dXSxcblx0ICAgICAgIHsxMTogMX1dLFxuXHQgMzExOiBbW1tbMTMyLCAxXSwgWzc1LCAxXV0sIFtbMCwgMV1dXSxcblx0ICAgICAgIHs2OiAxLFxuXHQgICAgICAgIDc6IDEsXG5cdCAgICAgICAgODogMSxcblx0ICAgICAgICA5OiAxLFxuXHQgICAgICAgIDExOiAxLFxuXHQgICAgICAgIDE0OiAxLFxuXHQgICAgICAgIDE1OiAxLFxuXHQgICAgICAgIDE5OiAxLFxuXHQgICAgICAgIDIyOiAxLFxuXHQgICAgICAgIDI2OiAxLFxuXHQgICAgICAgIDMwOiAxLFxuXHQgICAgICAgIDM3OiAxfV0sXG5cdCAzMTI6IFtbW1sxMzMsIDFdXSwgW1sxMzQsIDBdLCBbMCwgMV1dXSxcblx0ICAgICAgIHs2OiAxLFxuXHQgICAgICAgIDc6IDEsXG5cdCAgICAgICAgODogMSxcblx0ICAgICAgICA5OiAxLFxuXHQgICAgICAgIDE0OiAxLFxuXHQgICAgICAgIDE1OiAxLFxuXHQgICAgICAgIDE5OiAxLFxuXHQgICAgICAgIDIyOiAxLFxuXHQgICAgICAgIDI2OiAxLFxuXHQgICAgICAgIDMwOiAxLFxuXHQgICAgICAgIDM3OiAxfV0sXG5cdCAzMTM6IFtbW1szMCwgMV1dLCBbWzUyLCAyXSwgWzEyNiwgM11dLCBbWzAsIDJdXSwgW1s1MiwgMl1dXSwgezMwOiAxfV0sXG5cdCAzMTQ6IFtbW1syNCwgMV1dLCBbWzAsIDFdXV0sIHsyNDogMX1dLFxuXHQgMzE1OiBbW1tbMTM1LCAxXV0sIFtbNDQsIDJdLCBbMTM2LCAxXSwgWzAsIDFdXSwgW1sxMDksIDNdXSwgW1swLCAzXV1dLFxuXHQgICAgICAgezg6IDEsIDk6IDEsIDE0OiAxLCAxNTogMSwgMTk6IDEsIDIyOiAxLCAzMDogMX1dLFxuXHQgMzE2OiBbW1tbMTIsIDFdXSxcblx0ICAgICAgICBbWzQ1LCAyXSwgWzEzNywgM10sIFswLCAxXV0sXG5cdCAgICAgICAgW1s0NiwgNF0sIFswLCAyXV0sXG5cdCAgICAgICAgW1s0NSwgNV1dLFxuXHQgICAgICAgIFtbNDUsIDJdLCBbMCwgNF1dLFxuXHQgICAgICAgIFtbNDYsIDZdLCBbMCwgNV1dLFxuXHQgICAgICAgIFtbNDUsIDddXSxcblx0ICAgICAgICBbWzQ2LCA4XSwgWzAsIDddXSxcblx0ICAgICAgICBbWzQ1LCA3XSwgWzAsIDhdXV0sXG5cdCAgICAgICB7MTI6IDF9XSxcblx0IDMxNzogW1tbWzUsIDFdXSxcblx0ICAgICAgICBbWzQ1LCAyXSwgWzAsIDFdXSxcblx0ICAgICAgICBbWzQ2LCAzXSwgWzAsIDJdXSxcblx0ICAgICAgICBbWzQ1LCA0XV0sXG5cdCAgICAgICAgW1s0NiwgNV0sIFswLCA0XV0sXG5cdCAgICAgICAgW1s0NSwgNl1dLFxuXHQgICAgICAgIFtbMCwgNl1dXSxcblx0ICAgICAgIHs1OiAxfV0sXG5cdCAzMTg6IFtbW1syMCwgMV1dLCBbWzcyLCAyXSwgWzAsIDFdXSwgW1swLCAyXV1dLCB7MjA6IDF9XSxcblx0IDMxOTogW1tbWzEzOCwgMV1dLCBbWzEzOSwgMF0sIFsxMzcsIDBdLCBbMCwgMV1dXSxcblx0ICAgICAgIHs2OiAxLCA4OiAxLCA5OiAxLCAxNDogMSwgMTU6IDEsIDE5OiAxLCAyMjogMSwgMjY6IDEsIDMwOiAxLCAzNzogMX1dLFxuXHQgMzIwOiBbW1tbMTQwLCAxXV0sIFtbMiwgMl0sIFsxNDEsIDNdXSwgW1swLCAyXV0sIFtbMTQwLCAxXSwgWzIsIDJdXV0sXG5cdCAgICAgICB7NTogMSxcblx0ICAgICAgICA2OiAxLFxuXHQgICAgICAgIDc6IDEsXG5cdCAgICAgICAgODogMSxcblx0ICAgICAgICA5OiAxLFxuXHQgICAgICAgIDExOiAxLFxuXHQgICAgICAgIDEyOiAxLFxuXHQgICAgICAgIDEzOiAxLFxuXHQgICAgICAgIDE0OiAxLFxuXHQgICAgICAgIDE1OiAxLFxuXHQgICAgICAgIDE3OiAxLFxuXHQgICAgICAgIDE5OiAxLFxuXHQgICAgICAgIDIwOiAxLFxuXHQgICAgICAgIDIxOiAxLFxuXHQgICAgICAgIDIyOiAxLFxuXHQgICAgICAgIDIzOiAxLFxuXHQgICAgICAgIDI0OiAxLFxuXHQgICAgICAgIDI1OiAxLFxuXHQgICAgICAgIDI2OiAxLFxuXHQgICAgICAgIDI3OiAxLFxuXHQgICAgICAgIDI4OiAxLFxuXHQgICAgICAgIDMwOiAxLFxuXHQgICAgICAgIDMxOiAxLFxuXHQgICAgICAgIDMzOiAxLFxuXHQgICAgICAgIDM0OiAxLFxuXHQgICAgICAgIDM3OiAxfV0sXG5cdCAzMjE6IFtbW1s3MCwgMV1dLCBbWzQ1LCAyXSwgWzAsIDFdXSwgW1swLCAyXV1dLCB7NzA6IDF9XSxcblx0IDMyMjogW1tbWzE0MiwgMV0sXG5cdCAgICAgICAgIFsxNDMsIDFdLFxuXHQgICAgICAgICBbMTQ0LCAxXSxcblx0ICAgICAgICAgWzE0NSwgMV0sXG5cdCAgICAgICAgIFsxNDYsIDFdLFxuXHQgICAgICAgICBbMTQ3LCAxXSxcblx0ICAgICAgICAgWzE0OCwgMV0sXG5cdCAgICAgICAgIFsxNDksIDFdLFxuXHQgICAgICAgICBbMTUwLCAxXSxcblx0ICAgICAgICAgWzE1MSwgMV1dLFxuXHQgICAgICAgIFtbMCwgMV1dXSxcblx0ICAgICAgIHs1OiAxLFxuXHQgICAgICAgIDY6IDEsXG5cdCAgICAgICAgNzogMSxcblx0ICAgICAgICA4OiAxLFxuXHQgICAgICAgIDk6IDEsXG5cdCAgICAgICAgMTE6IDEsXG5cdCAgICAgICAgMTI6IDEsXG5cdCAgICAgICAgMTM6IDEsXG5cdCAgICAgICAgMTQ6IDEsXG5cdCAgICAgICAgMTU6IDEsXG5cdCAgICAgICAgMTc6IDEsXG5cdCAgICAgICAgMTk6IDEsXG5cdCAgICAgICAgMjA6IDEsXG5cdCAgICAgICAgMjE6IDEsXG5cdCAgICAgICAgMjI6IDEsXG5cdCAgICAgICAgMjM6IDEsXG5cdCAgICAgICAgMjQ6IDEsXG5cdCAgICAgICAgMjU6IDEsXG5cdCAgICAgICAgMjY6IDEsXG5cdCAgICAgICAgMjc6IDEsXG5cdCAgICAgICAgMjg6IDEsXG5cdCAgICAgICAgMzA6IDEsXG5cdCAgICAgICAgMzE6IDEsXG5cdCAgICAgICAgMzM6IDEsXG5cdCAgICAgICAgMzQ6IDEsXG5cdCAgICAgICAgMzc6IDF9XSxcblx0IDMyMzogW1tbWzEsIDFdLCBbMywgMV1dLCBbWzAsIDFdXV0sXG5cdCAgICAgICB7NDogMSxcblx0ICAgICAgICA1OiAxLFxuXHQgICAgICAgIDY6IDEsXG5cdCAgICAgICAgNzogMSxcblx0ICAgICAgICA4OiAxLFxuXHQgICAgICAgIDk6IDEsXG5cdCAgICAgICAgMTA6IDEsXG5cdCAgICAgICAgMTE6IDEsXG5cdCAgICAgICAgMTI6IDEsXG5cdCAgICAgICAgMTM6IDEsXG5cdCAgICAgICAgMTQ6IDEsXG5cdCAgICAgICAgMTU6IDEsXG5cdCAgICAgICAgMTY6IDEsXG5cdCAgICAgICAgMTc6IDEsXG5cdCAgICAgICAgMTg6IDEsXG5cdCAgICAgICAgMTk6IDEsXG5cdCAgICAgICAgMjA6IDEsXG5cdCAgICAgICAgMjE6IDEsXG5cdCAgICAgICAgMjI6IDEsXG5cdCAgICAgICAgMjM6IDEsXG5cdCAgICAgICAgMjQ6IDEsXG5cdCAgICAgICAgMjU6IDEsXG5cdCAgICAgICAgMjY6IDEsXG5cdCAgICAgICAgMjc6IDEsXG5cdCAgICAgICAgMjg6IDEsXG5cdCAgICAgICAgMjk6IDEsXG5cdCAgICAgICAgMzA6IDEsXG5cdCAgICAgICAgMzE6IDEsXG5cdCAgICAgICAgMzI6IDEsXG5cdCAgICAgICAgMzM6IDEsXG5cdCAgICAgICAgMzQ6IDEsXG5cdCAgICAgICAgMzU6IDEsXG5cdCAgICAgICAgMzY6IDEsXG5cdCAgICAgICAgMzc6IDF9XSxcblx0IDMyNDogW1tbWzQ1LCAxXSwgWzcwLCAyXSwgWzEwMiwgM11dLFxuXHQgICAgICAgIFtbNzAsIDJdLCBbMCwgMV1dLFxuXHQgICAgICAgIFtbNDUsIDRdLCBbMTUyLCA1XSwgWzAsIDJdXSxcblx0ICAgICAgICBbWzEwMiwgNl1dLFxuXHQgICAgICAgIFtbMTUyLCA1XSwgWzAsIDRdXSxcblx0ICAgICAgICBbWzAsIDVdXSxcblx0ICAgICAgICBbWzEwMiwgNV1dXSxcblx0ICAgICAgIHs2OiAxLFxuXHQgICAgICAgIDc6IDEsXG5cdCAgICAgICAgODogMSxcblx0ICAgICAgICA5OiAxLFxuXHQgICAgICAgIDExOiAxLFxuXHQgICAgICAgIDE0OiAxLFxuXHQgICAgICAgIDE1OiAxLFxuXHQgICAgICAgIDE5OiAxLFxuXHQgICAgICAgIDIyOiAxLFxuXHQgICAgICAgIDI2OiAxLFxuXHQgICAgICAgIDMwOiAxLFxuXHQgICAgICAgIDM3OiAxLFxuXHQgICAgICAgIDcwOiAxLFxuXHQgICAgICAgIDEwMjogMX1dLFxuXHQgMzI1OiBbW1tbMTUzLCAxXV0sIFtbNDYsIDJdLCBbMCwgMV1dLCBbWzE1MywgMV0sIFswLCAyXV1dLFxuXHQgICAgICAgezY6IDEsXG5cdCAgICAgICAgNzogMSxcblx0ICAgICAgICA4OiAxLFxuXHQgICAgICAgIDk6IDEsXG5cdCAgICAgICAgMTE6IDEsXG5cdCAgICAgICAgMTQ6IDEsXG5cdCAgICAgICAgMTU6IDEsXG5cdCAgICAgICAgMTk6IDEsXG5cdCAgICAgICAgMjI6IDEsXG5cdCAgICAgICAgMjY6IDEsXG5cdCAgICAgICAgMzA6IDEsXG5cdCAgICAgICAgMzc6IDEsXG5cdCAgICAgICAgNzA6IDEsXG5cdCAgICAgICAgMTAyOiAxfV0sXG5cdCAzMjY6IFtbW1sxLCAxXSwgWzIsIDJdXSxcblx0ICAgICAgICBbWzAsIDFdXSxcblx0ICAgICAgICBbWzE1NCwgM11dLFxuXHQgICAgICAgIFtbMTEwLCA0XV0sXG5cdCAgICAgICAgW1sxNTUsIDFdLCBbMTEwLCA0XV1dLFxuXHQgICAgICAgezI6IDEsXG5cdCAgICAgICAgNTogMSxcblx0ICAgICAgICA2OiAxLFxuXHQgICAgICAgIDc6IDEsXG5cdCAgICAgICAgODogMSxcblx0ICAgICAgICA5OiAxLFxuXHQgICAgICAgIDExOiAxLFxuXHQgICAgICAgIDEyOiAxLFxuXHQgICAgICAgIDEzOiAxLFxuXHQgICAgICAgIDE0OiAxLFxuXHQgICAgICAgIDE1OiAxLFxuXHQgICAgICAgIDE3OiAxLFxuXHQgICAgICAgIDE5OiAxLFxuXHQgICAgICAgIDIwOiAxLFxuXHQgICAgICAgIDIxOiAxLFxuXHQgICAgICAgIDIyOiAxLFxuXHQgICAgICAgIDIzOiAxLFxuXHQgICAgICAgIDI0OiAxLFxuXHQgICAgICAgIDI1OiAxLFxuXHQgICAgICAgIDI2OiAxLFxuXHQgICAgICAgIDI3OiAxLFxuXHQgICAgICAgIDI4OiAxLFxuXHQgICAgICAgIDMwOiAxLFxuXHQgICAgICAgIDMxOiAxLFxuXHQgICAgICAgIDMzOiAxLFxuXHQgICAgICAgIDM0OiAxLFxuXHQgICAgICAgIDM3OiAxfV0sXG5cdCAzMjc6IFtbW1sxMDksIDFdXSwgW1sxNTYsIDBdLCBbNDIsIDBdLCBbMTU3LCAwXSwgWzE1OCwgMF0sIFswLCAxXV1dLFxuXHQgICAgICAgezY6IDEsIDg6IDEsIDk6IDEsIDE0OiAxLCAxNTogMSwgMTk6IDEsIDIyOiAxLCAyNjogMSwgMzA6IDEsIDM3OiAxfV0sXG5cdCAzMjg6IFtbW1s3NSwgMV0sIFsxNTksIDJdXSxcblx0ICAgICAgICBbWzMyLCAzXSwgWzAsIDFdXSxcblx0ICAgICAgICBbWzAsIDJdXSxcblx0ICAgICAgICBbWzc1LCA0XV0sXG5cdCAgICAgICAgW1sxMTYsIDVdXSxcblx0ICAgICAgICBbWzQ1LCAyXV1dLFxuXHQgICAgICAgezY6IDEsXG5cdCAgICAgICAgNzogMSxcblx0ICAgICAgICA4OiAxLFxuXHQgICAgICAgIDk6IDEsXG5cdCAgICAgICAgMTE6IDEsXG5cdCAgICAgICAgMTQ6IDEsXG5cdCAgICAgICAgMTU6IDEsXG5cdCAgICAgICAgMTk6IDEsXG5cdCAgICAgICAgMjI6IDEsXG5cdCAgICAgICAgMjY6IDEsXG5cdCAgICAgICAgMzA6IDEsXG5cdCAgICAgICAgMzc6IDF9XSxcblx0IDMyOTogW1tbWzQ1LCAxXV0sIFtbNDYsIDJdLCBbMCwgMV1dLCBbWzQ1LCAxXSwgWzAsIDJdXV0sXG5cdCAgICAgICB7NjogMSxcblx0ICAgICAgICA3OiAxLFxuXHQgICAgICAgIDg6IDEsXG5cdCAgICAgICAgOTogMSxcblx0ICAgICAgICAxMTogMSxcblx0ICAgICAgICAxNDogMSxcblx0ICAgICAgICAxNTogMSxcblx0ICAgICAgICAxOTogMSxcblx0ICAgICAgICAyMjogMSxcblx0ICAgICAgICAyNjogMSxcblx0ICAgICAgICAzMDogMSxcblx0ICAgICAgICAzNzogMX1dLFxuXHQgMzMwOiBbW1tbNDUsIDFdXSwgW1s0NiwgMF0sIFswLCAxXV1dLFxuXHQgICAgICAgezY6IDEsXG5cdCAgICAgICAgNzogMSxcblx0ICAgICAgICA4OiAxLFxuXHQgICAgICAgIDk6IDEsXG5cdCAgICAgICAgMTE6IDEsXG5cdCAgICAgICAgMTQ6IDEsXG5cdCAgICAgICAgMTU6IDEsXG5cdCAgICAgICAgMTk6IDEsXG5cdCAgICAgICAgMjI6IDEsXG5cdCAgICAgICAgMjY6IDEsXG5cdCAgICAgICAgMzA6IDEsXG5cdCAgICAgICAgMzc6IDF9XSxcblx0IDMzMTogW1tbWzQ1LCAxXV0sXG5cdCAgICAgICAgW1s0OCwgMl0sIFs0NiwgM10sIFswLCAxXV0sXG5cdCAgICAgICAgW1swLCAyXV0sXG5cdCAgICAgICAgW1s0NSwgNF0sIFswLCAzXV0sXG5cdCAgICAgICAgW1s0NiwgM10sIFswLCA0XV1dLFxuXHQgICAgICAgezY6IDEsXG5cdCAgICAgICAgNzogMSxcblx0ICAgICAgICA4OiAxLFxuXHQgICAgICAgIDk6IDEsXG5cdCAgICAgICAgMTE6IDEsXG5cdCAgICAgICAgMTQ6IDEsXG5cdCAgICAgICAgMTU6IDEsXG5cdCAgICAgICAgMTk6IDEsXG5cdCAgICAgICAgMjI6IDEsXG5cdCAgICAgICAgMjY6IDEsXG5cdCAgICAgICAgMzA6IDEsXG5cdCAgICAgICAgMzc6IDF9XSxcblx0IDMzMjogW1tbWzc3LCAxXV0sXG5cdCAgICAgICAgW1s0NiwgMl0sIFswLCAxXV0sXG5cdCAgICAgICAgW1s3NywgM11dLFxuXHQgICAgICAgIFtbNDYsIDRdLCBbMCwgM11dLFxuXHQgICAgICAgIFtbNzcsIDNdLCBbMCwgNF1dXSxcblx0ICAgICAgIHs2OiAxLFxuXHQgICAgICAgIDc6IDEsXG5cdCAgICAgICAgODogMSxcblx0ICAgICAgICA5OiAxLFxuXHQgICAgICAgIDExOiAxLFxuXHQgICAgICAgIDE0OiAxLFxuXHQgICAgICAgIDE1OiAxLFxuXHQgICAgICAgIDE5OiAxLFxuXHQgICAgICAgIDIyOiAxLFxuXHQgICAgICAgIDI2OiAxLFxuXHQgICAgICAgIDMwOiAxLFxuXHQgICAgICAgIDM3OiAxfV0sXG5cdCAzMzM6IFtbW1szMCwgMV0sIFsxMDIsIDJdLCBbMTQsIDNdXSxcblx0ICAgICAgICBbWzUyLCA0XSwgWzk4LCA1XV0sXG5cdCAgICAgICAgW1syMiwgNF1dLFxuXHQgICAgICAgIFtbMTYwLCA2XV0sXG5cdCAgICAgICAgW1swLCA0XV0sXG5cdCAgICAgICAgW1s1MiwgNF1dLFxuXHQgICAgICAgIFtbNTEsIDRdXV0sXG5cdCAgICAgICB7MTQ6IDEsIDMwOiAxLCAxMDI6IDF9XSxcblx0IDMzNDogW1tbWzE2LCAxXV0sXG5cdCAgICAgICAgW1s3MCwgMl1dLFxuXHQgICAgICAgIFtbNzEsIDNdXSxcblx0ICAgICAgICBbWzE2MSwgNF0sIFsxNjIsIDVdXSxcblx0ICAgICAgICBbWzcwLCA2XV0sXG5cdCAgICAgICAgW1s3MCwgN11dLFxuXHQgICAgICAgIFtbNzEsIDhdXSxcblx0ICAgICAgICBbWzcxLCA5XV0sXG5cdCAgICAgICAgW1sxNjEsIDRdLCBbMTE2LCAxMF0sIFsxNjIsIDVdLCBbMCwgOF1dLFxuXHQgICAgICAgIFtbMCwgOV1dLFxuXHQgICAgICAgIFtbNzAsIDExXV0sXG5cdCAgICAgICAgW1s3MSwgMTJdXSxcblx0ICAgICAgICBbWzE2MiwgNV0sIFswLCAxMl1dXSxcblx0ICAgICAgIHsxNjogMX1dLFxuXHQgMzM1OiBbW1tbNDIsIDFdLCBbMTE4LCAyXSwgWzQ0LCAzXV0sXG5cdCAgICAgICAgW1syMiwgNF1dLFxuXHQgICAgICAgIFtbNDcsIDVdLCBbNDYsIDZdLCBbMCwgMl1dLFxuXHQgICAgICAgIFtbMjIsIDddXSxcblx0ICAgICAgICBbWzQ2LCA4XSwgWzAsIDRdXSxcblx0ICAgICAgICBbWzQ1LCA5XV0sXG5cdCAgICAgICAgW1s0MiwgMV0sIFsxMTgsIDJdLCBbNDQsIDNdLCBbMCwgNl1dLFxuXHQgICAgICAgIFtbMCwgN11dLFxuXHQgICAgICAgIFtbNDQsIDNdXSxcblx0ICAgICAgICBbWzQ2LCA2XSwgWzAsIDldXV0sXG5cdCAgICAgICB7MjI6IDEsIDMwOiAxLCA0MjogMSwgNDQ6IDF9XSxcblx0IDMzNjogW1tbWzE4LCAxXV0sXG5cdCAgICAgICAgW1s0NSwgMl1dLFxuXHQgICAgICAgIFtbNzAsIDNdXSxcblx0ICAgICAgICBbWzcxLCA0XV0sXG5cdCAgICAgICAgW1sxMTYsIDVdLCBbMCwgNF1dLFxuXHQgICAgICAgIFtbNzAsIDZdXSxcblx0ICAgICAgICBbWzcxLCA3XV0sXG5cdCAgICAgICAgW1swLCA3XV1dLFxuXHQgICAgICAgezE4OiAxfV0sXG5cdCAzMzc6IFtbW1s0NSwgMV1dLCBbWzEwMCwgMl0sIFswLCAxXV0sIFtbODYsIDNdXSwgW1swLCAzXV1dLFxuXHQgICAgICAgezY6IDEsXG5cdCAgICAgICAgNzogMSxcblx0ICAgICAgICA4OiAxLFxuXHQgICAgICAgIDk6IDEsXG5cdCAgICAgICAgMTE6IDEsXG5cdCAgICAgICAgMTQ6IDEsXG5cdCAgICAgICAgMTU6IDEsXG5cdCAgICAgICAgMTk6IDEsXG5cdCAgICAgICAgMjI6IDEsXG5cdCAgICAgICAgMjY6IDEsXG5cdCAgICAgICAgMzA6IDEsXG5cdCAgICAgICAgMzc6IDF9XSxcblx0IDMzODogW1tbWzM2LCAxXV0sIFtbMTYzLCAyXV0sIFtbNzAsIDNdLCBbNDYsIDFdXSwgW1s3MSwgNF1dLCBbWzAsIDRdXV0sXG5cdCAgICAgICB7MzY6IDF9XSxcblx0IDMzOTogW1tbWzE2NCwgMV1dLCBbWzE2NSwgMF0sIFswLCAxXV1dLFxuXHQgICAgICAgezY6IDEsIDg6IDEsIDk6IDEsIDE0OiAxLCAxNTogMSwgMTk6IDEsIDIyOiAxLCAyNjogMSwgMzA6IDEsIDM3OiAxfV0sXG5cdCAzNDA6IFtbW1syNywgMV1dLCBbWzcyLCAyXSwgWzAsIDFdXSwgW1swLCAyXV1dLCB7Mjc6IDF9XSxcblx0IDM0MTogW1tbWzUzLCAxXV0sIFtbMCwgMV1dXSwgezI3OiAxfV19LFxuXHRzdGF0ZXM6XG5cdFtbW1sxLCAxXSwgWzIsIDFdLCBbMywgMl1dLCBbWzAsIDFdXSwgW1syLCAxXV1dLFxuXHQgW1tbMzgsIDFdXSwgW1szOSwgMF0sIFswLCAxXV1dLFxuXHQgW1tbNDAsIDFdXSwgW1s0MSwgMF0sIFswLCAxXV1dLFxuXHQgW1tbNDIsIDFdLCBbNDMsIDJdLCBbNDQsIDNdXSxcblx0ICBbWzQ1LCA0XV0sXG5cdCAgW1s0NiwgNV0sIFswLCAyXV0sXG5cdCAgW1s0NSwgNl1dLFxuXHQgIFtbNDYsIDddLCBbMCwgNF1dLFxuXHQgIFtbNDIsIDFdLCBbNDMsIDJdLCBbNDQsIDNdLCBbMCwgNV1dLFxuXHQgIFtbMCwgNl1dLFxuXHQgIFtbNDMsIDRdLCBbNDQsIDNdXV0sXG5cdCBbW1s0NSwgMV1dLCBbWzQ3LCAyXSwgWzQ4LCAzXSwgWzAsIDFdXSwgW1s0NSwgM11dLCBbWzAsIDNdXV0sXG5cdCBbW1s0OSwgMV1dLCBbWzI2LCAwXSwgWzM3LCAwXSwgWzAsIDFdXV0sXG5cdCBbW1syMSwgMV1dLCBbWzQ1LCAyXV0sIFtbNDYsIDNdLCBbMCwgMl1dLCBbWzQ1LCA0XV0sIFtbMCwgNF1dXSxcblx0IFtbWzE5LCAxXSwgWzgsIDJdLCBbOSwgNV0sIFszMCwgNF0sIFsxNCwgM10sIFsxNSwgNl0sIFsyMiwgMl1dLFxuXHQgIFtbMTksIDFdLCBbMCwgMV1dLFxuXHQgIFtbMCwgMl1dLFxuXHQgIFtbNTAsIDddLCBbNTEsIDJdXSxcblx0ICBbWzUyLCAyXSwgWzUzLCA4XSwgWzU0LCA4XV0sXG5cdCAgW1s1NSwgMl0sIFs1NiwgOV1dLFxuXHQgIFtbNTcsIDEwXV0sXG5cdCAgW1s1MSwgMl1dLFxuXHQgIFtbNTIsIDJdXSxcblx0ICBbWzU1LCAyXV0sXG5cdCAgW1sxNSwgMl1dXSxcblx0IFtbWzU4LCAxXSxcblx0ICAgWzU5LCAxXSxcblx0ICAgWzYwLCAxXSxcblx0ICAgWzYxLCAxXSxcblx0ICAgWzYyLCAxXSxcblx0ICAgWzYzLCAxXSxcblx0ICAgWzY0LCAxXSxcblx0ICAgWzY1LCAxXSxcblx0ICAgWzY2LCAxXSxcblx0ICAgWzY3LCAxXSxcblx0ICAgWzY4LCAxXSxcblx0ICAgWzY5LCAxXV0sXG5cdCAgW1swLCAxXV1dLFxuXHQgW1tbMzMsIDFdXSwgW1swLCAxXV1dLFxuXHQgW1tbMTAsIDFdXSxcblx0ICBbWzIyLCAyXV0sXG5cdCAgW1s3MCwgM10sIFszMCwgNF1dLFxuXHQgIFtbNzEsIDVdXSxcblx0ICBbWzUyLCA2XSwgWzcyLCA3XV0sXG5cdCAgW1swLCA1XV0sXG5cdCAgW1s3MCwgM11dLFxuXHQgIFtbNTIsIDZdXV0sXG5cdCBbW1syOSwgMV1dLCBbWzczLCAyXV0sIFtbNzQsIDNdXSwgW1s3NSwgNF1dLCBbWzc2LCA1XSwgWzAsIDRdXSwgW1swLCA1XV1dLFxuXHQgW1tbMzIsIDFdXSwgW1s3NywgMl1dLCBbWzc2LCAzXSwgWzAsIDJdXSwgW1swLCAzXV1dLFxuXHQgW1tbNzgsIDFdLCBbNDgsIDFdXSwgW1swLCAxXV1dLFxuXHQgW1tbNzksIDFdLFxuXHQgICBbODAsIDFdLFxuXHQgICBbNywgMl0sXG5cdCAgIFs4MSwgMV0sXG5cdCAgIFs3OSwgMV0sXG5cdCAgIFs3NCwgMV0sXG5cdCAgIFs4MiwgMV0sXG5cdCAgIFs4MywgM10sXG5cdCAgIFs4NCwgMV0sXG5cdCAgIFs4NSwgMV1dLFxuXHQgIFtbMCwgMV1dLFxuXHQgIFtbNzQsIDFdXSxcblx0ICBbWzcsIDFdLCBbMCwgM11dXSxcblx0IFtbWzg2LCAxXV0sIFtbODcsIDBdLCBbMCwgMV1dXSxcblx0IFtbWzg4LCAxXSwgWzg5LCAxXSwgWzkwLCAxXSwgWzkxLCAxXSwgWzkyLCAxXSwgWzkzLCAxXSwgWzk0LCAxXSwgWzk1LCAxXV0sXG5cdCAgW1swLCAxXV1dLFxuXHQgW1tbMzQsIDFdXSwgW1swLCAxXV1dLFxuXHQgW1tbMTMsIDFdXSwgW1swLCAxXV1dLFxuXHQgW1tbOTYsIDFdXSwgW1s5NCwgMl0sIFs5MSwgMl1dLCBbWzAsIDJdXV0sXG5cdCBbW1szNSwgMV1dLFxuXHQgIFtbOTcsIDJdXSxcblx0ICBbWzIsIDRdLCBbMzAsIDNdXSxcblx0ICBbWzUyLCA1XSwgWzk4LCA2XV0sXG5cdCAgW1swLCA0XV0sXG5cdCAgW1syLCA0XV0sXG5cdCAgW1s1MiwgNV1dXSxcblx0IFtbWzk5LCAxXV0sIFtbOTksIDFdLCBbMCwgMV1dXSxcblx0IFtbWzIzLCAxXV0sIFtbNzMsIDJdXSwgW1swLCAyXV1dLFxuXHQgW1tbNDUsIDFdXSxcblx0ICBbWzcwLCAyXSwgWzQ4LCAzXSwgWzQ2LCA0XSwgWzAsIDFdXSxcblx0ICBbWzQ1LCA1XV0sXG5cdCAgW1swLCAzXV0sXG5cdCAgW1s0NSwgNl0sIFswLCA0XV0sXG5cdCAgW1s0OCwgM10sIFs0NiwgN10sIFswLCA1XV0sXG5cdCAgW1s0NiwgNF0sIFswLCA2XV0sXG5cdCAgW1s0NSwgOF0sIFswLCA3XV0sXG5cdCAgW1s3MCwgOV1dLFxuXHQgIFtbNDUsIDEwXV0sXG5cdCAgW1s0NiwgN10sIFswLCAxMF1dXSxcblx0IFtbWzk3LCAxXV0sIFtbMTAwLCAyXSwgWzAsIDFdXSwgW1syMiwgM11dLCBbWzAsIDNdXV0sXG5cdCBbW1sxMDEsIDFdXSwgW1s0NiwgMF0sIFswLCAxXV1dLFxuXHQgW1tbMjIsIDFdXSwgW1sxMDIsIDBdLCBbMCwgMV1dXSxcblx0IFtbWzIyLCAxXV0sIFtbMCwgMV1dXSxcblx0IFtbWzcyLCAxXV0sIFtbMiwgMV0sIFsxMDMsIDJdXSwgW1swLCAyXV1dLFxuXHQgW1tbMTA0LCAxXV0sXG5cdCAgW1s0NSwgMl0sIFswLCAxXV0sXG5cdCAgW1sxMDAsIDNdLCBbNDYsIDNdLCBbMCwgMl1dLFxuXHQgIFtbNDUsIDRdXSxcblx0ICBbWzAsIDRdXV0sXG5cdCBbW1sxNywgMV1dLFxuXHQgIFtbODYsIDJdXSxcblx0ICBbWzc0LCAzXSwgWzAsIDJdXSxcblx0ICBbWzQ1LCA0XV0sXG5cdCAgW1s0NiwgNV0sIFswLCA0XV0sXG5cdCAgW1s0NSwgNl1dLFxuXHQgIFtbMCwgNl1dXSxcblx0IFtbWzEwNSwgMV1dLCBbWzEwNiwgMF0sIFswLCAxXV1dLFxuXHQgW1tbNzIsIDFdXSxcblx0ICBbWzEwNywgMl0sIFs0NywgM10sIFswLCAxXV0sXG5cdCAgW1s3MiwgNF0sIFs1MywgNF1dLFxuXHQgIFtbNzIsIDVdLCBbNTMsIDVdXSxcblx0ICBbWzAsIDRdXSxcblx0ICBbWzQ3LCAzXSwgWzAsIDVdXV0sXG5cdCBbW1s4NiwgMV1dLCBbWzQ2LCAyXSwgWzAsIDFdXSwgW1s4NiwgMV0sIFswLCAyXV1dLFxuXHQgW1tbMzcsIDJdLCBbMjYsIDJdLCBbNiwgMl0sIFsxMDgsIDFdXSwgW1swLCAxXV0sIFtbMTA5LCAxXV1dLFxuXHQgW1tbMiwgMF0sIFsxMDMsIDFdLCBbMTEwLCAwXV0sIFtbMCwgMV1dXSxcblx0IFtbWzExMSwgMV0sIFsxMTIsIDFdLCBbMTEzLCAxXSwgWzExNCwgMV0sIFsxMTUsIDFdXSwgW1swLCAxXV1dLFxuXHQgW1tbMjksIDFdXSxcblx0ICBbWzczLCAyXV0sXG5cdCAgW1s3NCwgM11dLFxuXHQgIFtbNzIsIDRdXSxcblx0ICBbWzcwLCA1XV0sXG5cdCAgW1s3MSwgNl1dLFxuXHQgIFtbMTE2LCA3XSwgWzAsIDZdXSxcblx0ICBbWzcwLCA4XV0sXG5cdCAgW1s3MSwgOV1dLFxuXHQgIFtbMCwgOV1dXSxcblx0IFtbWzMwLCAxXSwgWzIyLCAyXV0sIFtbMTE3LCAzXV0sIFtbMCwgMl1dLCBbWzUyLCAyXV1dLFxuXHQgW1tbMTE4LCAxXV0sIFtbNDYsIDJdLCBbMCwgMV1dLCBbWzExOCwgMV0sIFswLCAyXV1dLFxuXHQgW1tbNCwgMV1dLCBbWzIyLCAyXV0sIFtbMTE5LCAzXV0sIFtbNzAsIDRdXSwgW1s3MSwgNV1dLCBbWzAsIDVdXV0sXG5cdCBbW1syOCwgMV1dLCBbWzIyLCAyXV0sIFtbNDYsIDFdLCBbMCwgMl1dXSxcblx0IFtbWzMyLCAxXV0sXG5cdCAgW1s0NSwgMl1dLFxuXHQgIFtbNzAsIDNdXSxcblx0ICBbWzcxLCA0XV0sXG5cdCAgW1sxMTYsIDVdLCBbMTIwLCAxXSwgWzAsIDRdXSxcblx0ICBbWzcwLCA2XV0sXG5cdCAgW1s3MSwgN11dLFxuXHQgIFtbMCwgN11dXSxcblx0IFtbWzIyLCAxXV0sIFtbMTAwLCAyXSwgWzAsIDFdXSwgW1syMiwgM11dLCBbWzAsIDNdXV0sXG5cdCBbW1sxMjEsIDFdXSwgW1s0NiwgMl0sIFswLCAxXV0sIFtbMTIxLCAxXSwgWzAsIDJdXV0sXG5cdCBbW1szMSwgMV1dLFxuXHQgIFtbOTcsIDJdLCBbMTAyLCAzXV0sXG5cdCAgW1syNSwgNF1dLFxuXHQgIFtbOTcsIDJdLCBbMjUsIDRdLCBbMTAyLCAzXV0sXG5cdCAgW1sxMjIsIDVdLCBbNDIsIDVdLCBbMzAsIDZdXSxcblx0ICBbWzAsIDVdXSxcblx0ICBbWzEyMiwgN11dLFxuXHQgIFtbNTIsIDVdXV0sXG5cdCBbW1syNSwgMV1dLCBbWzEyMywgMl1dLCBbWzAsIDJdXV0sXG5cdCBbW1sxMjQsIDFdLCBbMTI1LCAxXV0sIFtbMCwgMV1dXSxcblx0IFtbWzExLCAxXV0sIFtbNzAsIDJdLCBbMTI2LCAzXV0sIFtbNDUsIDRdXSwgW1s3MCwgMl1dLCBbWzAsIDRdXV0sXG5cdCBbW1syOSwgMV1dLCBbWzczLCAyXV0sIFtbNzQsIDNdXSwgW1sxMjcsIDRdXSwgW1sxMjgsIDVdLCBbMCwgNF1dLCBbWzAsIDVdXV0sXG5cdCBbW1szMiwgMV1dLCBbWzc3LCAyXV0sIFtbMTI4LCAzXSwgWzAsIDJdXSwgW1swLCAzXV1dLFxuXHQgW1tbMTI5LCAxXSwgWzEzMCwgMV1dLCBbWzAsIDFdXV0sXG5cdCBbW1s0NSwgMV1dLFxuXHQgIFtbMTI5LCAyXSwgWzQ2LCAzXSwgWzAsIDFdXSxcblx0ICBbWzAsIDJdXSxcblx0ICBbWzQ1LCA0XSwgWzAsIDNdXSxcblx0ICBbWzQ2LCAzXSwgWzAsIDRdXV0sXG5cdCBbW1s3LCAxXSwgWzEzMSwgMl1dLCBbWzQwLCAyXV0sIFtbMCwgMl1dXSxcblx0IFtbWzExLCAxXV0sIFtbNzAsIDJdLCBbMTI2LCAzXV0sIFtbNzcsIDRdXSwgW1s3MCwgMl1dLCBbWzAsIDRdXV0sXG5cdCBbW1sxMzIsIDFdLCBbNzUsIDFdXSwgW1swLCAxXV1dLFxuXHQgW1tbMTMzLCAxXV0sIFtbMTM0LCAwXSwgWzAsIDFdXV0sXG5cdCBbW1szMCwgMV1dLCBbWzUyLCAyXSwgWzEyNiwgM11dLCBbWzAsIDJdXSwgW1s1MiwgMl1dXSxcblx0IFtbWzI0LCAxXV0sIFtbMCwgMV1dXSxcblx0IFtbWzEzNSwgMV1dLCBbWzQ0LCAyXSwgWzEzNiwgMV0sIFswLCAxXV0sIFtbMTA5LCAzXV0sIFtbMCwgM11dXSxcblx0IFtbWzEyLCAxXV0sXG5cdCAgW1s0NSwgMl0sIFsxMzcsIDNdLCBbMCwgMV1dLFxuXHQgIFtbNDYsIDRdLCBbMCwgMl1dLFxuXHQgIFtbNDUsIDVdXSxcblx0ICBbWzQ1LCAyXSwgWzAsIDRdXSxcblx0ICBbWzQ2LCA2XSwgWzAsIDVdXSxcblx0ICBbWzQ1LCA3XV0sXG5cdCAgW1s0NiwgOF0sIFswLCA3XV0sXG5cdCAgW1s0NSwgN10sIFswLCA4XV1dLFxuXHQgW1tbNSwgMV1dLFxuXHQgIFtbNDUsIDJdLCBbMCwgMV1dLFxuXHQgIFtbNDYsIDNdLCBbMCwgMl1dLFxuXHQgIFtbNDUsIDRdXSxcblx0ICBbWzQ2LCA1XSwgWzAsIDRdXSxcblx0ICBbWzQ1LCA2XV0sXG5cdCAgW1swLCA2XV1dLFxuXHQgW1tbMjAsIDFdXSwgW1s3MiwgMl0sIFswLCAxXV0sIFtbMCwgMl1dXSxcblx0IFtbWzEzOCwgMV1dLCBbWzEzOSwgMF0sIFsxMzcsIDBdLCBbMCwgMV1dXSxcblx0IFtbWzE0MCwgMV1dLCBbWzIsIDJdLCBbMTQxLCAzXV0sIFtbMCwgMl1dLCBbWzE0MCwgMV0sIFsyLCAyXV1dLFxuXHQgW1tbNzAsIDFdXSwgW1s0NSwgMl0sIFswLCAxXV0sIFtbMCwgMl1dXSxcblx0IFtbWzE0MiwgMV0sXG5cdCAgIFsxNDMsIDFdLFxuXHQgICBbMTQ0LCAxXSxcblx0ICAgWzE0NSwgMV0sXG5cdCAgIFsxNDYsIDFdLFxuXHQgICBbMTQ3LCAxXSxcblx0ICAgWzE0OCwgMV0sXG5cdCAgIFsxNDksIDFdLFxuXHQgICBbMTUwLCAxXSxcblx0ICAgWzE1MSwgMV1dLFxuXHQgIFtbMCwgMV1dXSxcblx0IFtbWzEsIDFdLCBbMywgMV1dLCBbWzAsIDFdXV0sXG5cdCBbW1s0NSwgMV0sIFs3MCwgMl0sIFsxMDIsIDNdXSxcblx0ICBbWzcwLCAyXSwgWzAsIDFdXSxcblx0ICBbWzQ1LCA0XSwgWzE1MiwgNV0sIFswLCAyXV0sXG5cdCAgW1sxMDIsIDZdXSxcblx0ICBbWzE1MiwgNV0sIFswLCA0XV0sXG5cdCAgW1swLCA1XV0sXG5cdCAgW1sxMDIsIDVdXV0sXG5cdCBbW1sxNTMsIDFdXSwgW1s0NiwgMl0sIFswLCAxXV0sIFtbMTUzLCAxXSwgWzAsIDJdXV0sXG5cdCBbW1sxLCAxXSwgWzIsIDJdXSwgW1swLCAxXV0sIFtbMTU0LCAzXV0sIFtbMTEwLCA0XV0sIFtbMTU1LCAxXSwgWzExMCwgNF1dXSxcblx0IFtbWzEwOSwgMV1dLCBbWzE1NiwgMF0sIFs0MiwgMF0sIFsxNTcsIDBdLCBbMTU4LCAwXSwgWzAsIDFdXV0sXG5cdCBbW1s3NSwgMV0sIFsxNTksIDJdXSxcblx0ICBbWzMyLCAzXSwgWzAsIDFdXSxcblx0ICBbWzAsIDJdXSxcblx0ICBbWzc1LCA0XV0sXG5cdCAgW1sxMTYsIDVdXSxcblx0ICBbWzQ1LCAyXV1dLFxuXHQgW1tbNDUsIDFdXSwgW1s0NiwgMl0sIFswLCAxXV0sIFtbNDUsIDFdLCBbMCwgMl1dXSxcblx0IFtbWzQ1LCAxXV0sIFtbNDYsIDBdLCBbMCwgMV1dXSxcblx0IFtbWzQ1LCAxXV0sXG5cdCAgW1s0OCwgMl0sIFs0NiwgM10sIFswLCAxXV0sXG5cdCAgW1swLCAyXV0sXG5cdCAgW1s0NSwgNF0sIFswLCAzXV0sXG5cdCAgW1s0NiwgM10sIFswLCA0XV1dLFxuXHQgW1tbNzcsIDFdXSxcblx0ICBbWzQ2LCAyXSwgWzAsIDFdXSxcblx0ICBbWzc3LCAzXV0sXG5cdCAgW1s0NiwgNF0sIFswLCAzXV0sXG5cdCAgW1s3NywgM10sIFswLCA0XV1dLFxuXHQgW1tbMzAsIDFdLCBbMTAyLCAyXSwgWzE0LCAzXV0sXG5cdCAgW1s1MiwgNF0sIFs5OCwgNV1dLFxuXHQgIFtbMjIsIDRdXSxcblx0ICBbWzE2MCwgNl1dLFxuXHQgIFtbMCwgNF1dLFxuXHQgIFtbNTIsIDRdXSxcblx0ICBbWzUxLCA0XV1dLFxuXHQgW1tbMTYsIDFdXSxcblx0ICBbWzcwLCAyXV0sXG5cdCAgW1s3MSwgM11dLFxuXHQgIFtbMTYxLCA0XSwgWzE2MiwgNV1dLFxuXHQgIFtbNzAsIDZdXSxcblx0ICBbWzcwLCA3XV0sXG5cdCAgW1s3MSwgOF1dLFxuXHQgIFtbNzEsIDldXSxcblx0ICBbWzE2MSwgNF0sIFsxMTYsIDEwXSwgWzE2MiwgNV0sIFswLCA4XV0sXG5cdCAgW1swLCA5XV0sXG5cdCAgW1s3MCwgMTFdXSxcblx0ICBbWzcxLCAxMl1dLFxuXHQgIFtbMTYyLCA1XSwgWzAsIDEyXV1dLFxuXHQgW1tbNDIsIDFdLCBbMTE4LCAyXSwgWzQ0LCAzXV0sXG5cdCAgW1syMiwgNF1dLFxuXHQgIFtbNDcsIDVdLCBbNDYsIDZdLCBbMCwgMl1dLFxuXHQgIFtbMjIsIDddXSxcblx0ICBbWzQ2LCA4XSwgWzAsIDRdXSxcblx0ICBbWzQ1LCA5XV0sXG5cdCAgW1s0MiwgMV0sIFsxMTgsIDJdLCBbNDQsIDNdLCBbMCwgNl1dLFxuXHQgIFtbMCwgN11dLFxuXHQgIFtbNDQsIDNdXSxcblx0ICBbWzQ2LCA2XSwgWzAsIDldXV0sXG5cdCBbW1sxOCwgMV1dLFxuXHQgIFtbNDUsIDJdXSxcblx0ICBbWzcwLCAzXV0sXG5cdCAgW1s3MSwgNF1dLFxuXHQgIFtbMTE2LCA1XSwgWzAsIDRdXSxcblx0ICBbWzcwLCA2XV0sXG5cdCAgW1s3MSwgN11dLFxuXHQgIFtbMCwgN11dXSxcblx0IFtbWzQ1LCAxXV0sIFtbMTAwLCAyXSwgWzAsIDFdXSwgW1s4NiwgM11dLCBbWzAsIDNdXV0sXG5cdCBbW1szNiwgMV1dLCBbWzE2MywgMl1dLCBbWzcwLCAzXSwgWzQ2LCAxXV0sIFtbNzEsIDRdXSwgW1swLCA0XV1dLFxuXHQgW1tbMTY0LCAxXV0sIFtbMTY1LCAwXSwgWzAsIDFdXV0sXG5cdCBbW1syNywgMV1dLCBbWzcyLCAyXSwgWzAsIDFdXSwgW1swLCAyXV1dLFxuXHQgW1tbNTMsIDFdXSwgW1swLCAxXV1dXSxcblx0bGFiZWxzOlxuXHRbWzAsICdFTVBUWSddLFxuXHQgWzMyMCwgbnVsbF0sXG5cdCBbNCwgbnVsbF0sXG5cdCBbMjcyLCBudWxsXSxcblx0IFsxLCAnZGVmJ10sXG5cdCBbMSwgJ3JhaXNlJ10sXG5cdCBbMzIsIG51bGxdLFxuXHQgWzEsICdub3QnXSxcblx0IFsyLCBudWxsXSxcblx0IFsyNiwgbnVsbF0sXG5cdCBbMSwgJ2NsYXNzJ10sXG5cdCBbMSwgJ2xhbWJkYSddLFxuXHQgWzEsICdwcmludCddLFxuXHQgWzEsICdkZWJ1Z2dlciddLFxuXHQgWzksIG51bGxdLFxuXHQgWzI1LCBudWxsXSxcblx0IFsxLCAndHJ5J10sXG5cdCBbMSwgJ2V4ZWMnXSxcblx0IFsxLCAnd2hpbGUnXSxcblx0IFszLCBudWxsXSxcblx0IFsxLCAncmV0dXJuJ10sXG5cdCBbMSwgJ2Fzc2VydCddLFxuXHQgWzEsIG51bGxdLFxuXHQgWzEsICdkZWwnXSxcblx0IFsxLCAncGFzcyddLFxuXHQgWzEsICdpbXBvcnQnXSxcblx0IFsxNSwgbnVsbF0sXG5cdCBbMSwgJ3lpZWxkJ10sXG5cdCBbMSwgJ2dsb2JhbCddLFxuXHQgWzEsICdmb3InXSxcblx0IFs3LCBudWxsXSxcblx0IFsxLCAnZnJvbSddLFxuXHQgWzEsICdpZiddLFxuXHQgWzEsICdicmVhayddLFxuXHQgWzEsICdjb250aW51ZSddLFxuXHQgWzUwLCBudWxsXSxcblx0IFsxLCAnd2l0aCddLFxuXHQgWzE0LCBudWxsXSxcblx0IFszMTksIG51bGxdLFxuXHQgWzE5LCBudWxsXSxcblx0IFszMDksIG51bGxdLFxuXHQgWzEsICdhbmQnXSxcblx0IFsxNiwgbnVsbF0sXG5cdCBbMjYwLCBudWxsXSxcblx0IFszNiwgbnVsbF0sXG5cdCBbMzI4LCBudWxsXSxcblx0IFsxMiwgbnVsbF0sXG5cdCBbMjIsIG51bGxdLFxuXHQgWzI2NywgbnVsbF0sXG5cdCBbMzI3LCBudWxsXSxcblx0IFszMDgsIG51bGxdLFxuXHQgWzEwLCBudWxsXSxcblx0IFs4LCBudWxsXSxcblx0IFszNDAsIG51bGxdLFxuXHQgWzMzMSwgbnVsbF0sXG5cdCBbMjcsIG51bGxdLFxuXHQgWzI3OSwgbnVsbF0sXG5cdCBbMzMwLCBudWxsXSxcblx0IFs0NiwgbnVsbF0sXG5cdCBbMzksIG51bGxdLFxuXHQgWzQxLCBudWxsXSxcblx0IFs0NywgbnVsbF0sXG5cdCBbNDIsIG51bGxdLFxuXHQgWzQzLCBudWxsXSxcblx0IFszNywgbnVsbF0sXG5cdCBbNDQsIG51bGxdLFxuXHQgWzQ5LCBudWxsXSxcblx0IFs0NSwgbnVsbF0sXG5cdCBbMzgsIG51bGxdLFxuXHQgWzQwLCBudWxsXSxcblx0IFsxMSwgbnVsbF0sXG5cdCBbMzI2LCBudWxsXSxcblx0IFszMjksIG51bGxdLFxuXHQgWzI4OSwgbnVsbF0sXG5cdCBbMSwgJ2luJ10sXG5cdCBbMzEyLCBudWxsXSxcblx0IFsyNjksIG51bGxdLFxuXHQgWzMxMSwgbnVsbF0sXG5cdCBbMjY4LCBudWxsXSxcblx0IFsyOSwgbnVsbF0sXG5cdCBbMjEsIG51bGxdLFxuXHQgWzI4LCBudWxsXSxcblx0IFszMCwgbnVsbF0sXG5cdCBbMSwgJ2lzJ10sXG5cdCBbMzEsIG51bGxdLFxuXHQgWzIwLCBudWxsXSxcblx0IFsyODcsIG51bGxdLFxuXHQgWzI3MCwgbnVsbF0sXG5cdCBbMzM0LCBudWxsXSxcblx0IFsyOTgsIG51bGxdLFxuXHQgWzI5MywgbnVsbF0sXG5cdCBbMjY2LCBudWxsXSxcblx0IFszMzgsIG51bGxdLFxuXHQgWzMzNiwgbnVsbF0sXG5cdCBbMjk2LCBudWxsXSxcblx0IFsyNzUsIG51bGxdLFxuXHQgWzI3NywgbnVsbF0sXG5cdCBbMjgyLCBudWxsXSxcblx0IFsyNTksIG51bGxdLFxuXHQgWzI3NiwgbnVsbF0sXG5cdCBbMSwgJ2FzJ10sXG5cdCBbMjgwLCBudWxsXSxcblx0IFsyMywgbnVsbF0sXG5cdCBbMCwgbnVsbF0sXG5cdCBbMSwgJ2V4Y2VwdCddLFxuXHQgWzMzOSwgbnVsbF0sXG5cdCBbMTgsIG51bGxdLFxuXHQgWzI2NCwgbnVsbF0sXG5cdCBbMzE1LCBudWxsXSxcblx0IFsyOTAsIG51bGxdLFxuXHQgWzMyMywgbnVsbF0sXG5cdCBbMjY1LCBudWxsXSxcblx0IFsyNzMsIG51bGxdLFxuXHQgWzMxNywgbnVsbF0sXG5cdCBbMzE4LCBudWxsXSxcblx0IFszNDEsIG51bGxdLFxuXHQgWzEsICdlbHNlJ10sXG5cdCBbMjk1LCBudWxsXSxcblx0IFsyOTQsIG51bGxdLFxuXHQgWzMxMywgbnVsbF0sXG5cdCBbMSwgJ2VsaWYnXSxcblx0IFsyOTksIG51bGxdLFxuXHQgWzMwMCwgbnVsbF0sXG5cdCBbMjgxLCBudWxsXSxcblx0IFszMDIsIG51bGxdLFxuXHQgWzMwMSwgbnVsbF0sXG5cdCBbMzM1LCBudWxsXSxcblx0IFszMzIsIG51bGxdLFxuXHQgWzMwNywgbnVsbF0sXG5cdCBbMzA1LCBudWxsXSxcblx0IFszMDYsIG51bGxdLFxuXHQgWzI3MSwgbnVsbF0sXG5cdCBbMzEwLCBudWxsXSxcblx0IFsyNTgsIG51bGxdLFxuXHQgWzEsICdvciddLFxuXHQgWzI2MywgbnVsbF0sXG5cdCBbMzMzLCBudWxsXSxcblx0IFszNSwgbnVsbF0sXG5cdCBbMjYxLCBudWxsXSxcblx0IFszNCwgbnVsbF0sXG5cdCBbMzIyLCBudWxsXSxcblx0IFsxMywgbnVsbF0sXG5cdCBbMjkyLCBudWxsXSxcblx0IFsyNzgsIG51bGxdLFxuXHQgWzI4OCwgbnVsbF0sXG5cdCBbMzE0LCBudWxsXSxcblx0IFszMTYsIG51bGxdLFxuXHQgWzI2MiwgbnVsbF0sXG5cdCBbMjg2LCBudWxsXSxcblx0IFsyOTcsIG51bGxdLFxuXHQgWzMwMywgbnVsbF0sXG5cdCBbMjc0LCBudWxsXSxcblx0IFszMjEsIG51bGxdLFxuXHQgWzMyNCwgbnVsbF0sXG5cdCBbNSwgbnVsbF0sXG5cdCBbNiwgbnVsbF0sXG5cdCBbNDgsIG51bGxdLFxuXHQgWzE3LCBudWxsXSxcblx0IFsyNCwgbnVsbF0sXG5cdCBbMzA0LCBudWxsXSxcblx0IFszMjUsIG51bGxdLFxuXHQgWzI4NSwgbnVsbF0sXG5cdCBbMSwgJ2ZpbmFsbHknXSxcblx0IFszMzcsIG51bGxdLFxuXHQgWzI1NywgbnVsbF0sXG5cdCBbMzMsIG51bGxdXSxcblx0a2V5d29yZHM6XG5cdHsnYW5kJzogNDEsXG5cdCAnYXMnOiAxMDAsXG5cdCAnYXNzZXJ0JzogMjEsXG5cdCAnYnJlYWsnOiAzMyxcblx0ICdjbGFzcyc6IDEwLFxuXHQgJ2NvbnRpbnVlJzogMzQsXG5cdCAnZGVidWdnZXInOiAxMyxcblx0ICdkZWYnOiA0LFxuXHQgJ2RlbCc6IDIzLFxuXHQgJ2VsaWYnOiAxMjAsXG5cdCAnZWxzZSc6IDExNixcblx0ICdleGNlcHQnOiAxMDQsXG5cdCAnZXhlYyc6IDE3LFxuXHQgJ2ZpbmFsbHknOiAxNjIsXG5cdCAnZm9yJzogMjksXG5cdCAnZnJvbSc6IDMxLFxuXHQgJ2dsb2JhbCc6IDI4LFxuXHQgJ2lmJzogMzIsXG5cdCAnaW1wb3J0JzogMjUsXG5cdCAnaW4nOiA3NCxcblx0ICdpcyc6IDgzLFxuXHQgJ2xhbWJkYSc6IDExLFxuXHQgJ25vdCc6IDcsXG5cdCAnb3InOiAxMzQsXG5cdCAncGFzcyc6IDI0LFxuXHQgJ3ByaW50JzogMTIsXG5cdCAncmFpc2UnOiA1LFxuXHQgJ3JldHVybic6IDIwLFxuXHQgJ3RyeSc6IDE2LFxuXHQgJ3doaWxlJzogMTgsXG5cdCAnd2l0aCc6IDM2LFxuXHQgJ3lpZWxkJzogMjd9LFxuXHR0b2tlbnM6XG5cdHswOiAxMDMsXG5cdCAxOiAyMixcblx0IDI6IDgsXG5cdCAzOiAxOSxcblx0IDQ6IDIsXG5cdCA1OiAxNTQsXG5cdCA2OiAxNTUsXG5cdCA3OiAzMCxcblx0IDg6IDUyLFxuXHQgOTogMTQsXG5cdCAxMDogNTEsXG5cdCAxMTogNzAsXG5cdCAxMjogNDYsXG5cdCAxMzogMTQxLFxuXHQgMTQ6IDM3LFxuXHQgMTU6IDI2LFxuXHQgMTY6IDQyLFxuXHQgMTc6IDE1Nyxcblx0IDE4OiAxMDYsXG5cdCAxOTogMzksXG5cdCAyMDogODUsXG5cdCAyMTogODAsXG5cdCAyMjogNDcsXG5cdCAyMzogMTAyLFxuXHQgMjQ6IDE1OCxcblx0IDI1OiAxNSxcblx0IDI2OiA5LFxuXHQgMjc6IDU1LFxuXHQgMjg6IDgxLFxuXHQgMjk6IDc5LFxuXHQgMzA6IDgyLFxuXHQgMzE6IDg0LFxuXHQgMzI6IDYsXG5cdCAzMzogMTY1LFxuXHQgMzQ6IDEzOSxcblx0IDM1OiAxMzcsXG5cdCAzNjogNDQsXG5cdCAzNzogNjQsXG5cdCAzODogNjgsXG5cdCAzOTogNTksXG5cdCA0MDogNjksXG5cdCA0MTogNjAsXG5cdCA0MjogNjIsXG5cdCA0MzogNjMsXG5cdCA0NDogNjUsXG5cdCA0NTogNjcsXG5cdCA0NjogNTgsXG5cdCA0NzogNjEsXG5cdCA0ODogMTU2LFxuXHQgNDk6IDY2LFxuXHQgNTA6IDM1fSxcblx0c3RhcnQ6IDI1NlxuXHR9O1xuXG5cblxuXHQvKiAtLS0tIC9Vc2Vycy9yb2Ivc2t1bHB0eS9saWIvLi4vbm9kZV9tb2R1bGVzL3NrdWxwdC9zcmMvcGFyc2VyLmpzIC0tLS0gKi8gXG5cblx0Ly8gbG93IGxldmVsIHBhcnNlciB0byBhIGNvbmNyZXRlIHN5bnRheCB0cmVlLCBkZXJpdmVkIGZyb20gY3B5dGhvbidzIGxpYjJ0bzNcblxuXHQvKipcblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBncmFtbWFyXG5cdCAqXG5cdCAqIHAgPSBuZXcgUGFyc2VyKGdyYW1tYXIpO1xuXHQgKiBwLnNldHVwKFtzdGFydF0pO1xuXHQgKiBmb3JlYWNoIGlucHV0IHRva2VuOlxuXHQgKiAgICAgaWYgcC5hZGR0b2tlbiguLi4pOlxuXHQgKiAgICAgICAgIGJyZWFrXG5cdCAqIHJvb3QgPSBwLnJvb3Rub2RlXG5cdCAqXG5cdCAqIGNhbiB0aHJvdyBTeW50YXhFcnJvclxuXHQgKi9cblx0ZnVuY3Rpb24gUGFyc2VyIChmaWxlbmFtZSwgZ3JhbW1hcikge1xuXHQgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuXHQgICAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcblx0ICAgIHRoaXMucF9mbGFncyA9IDA7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIGFsbCBwb3NzaWJsZSBwYXJzZXIgZmxhZ3Ncblx0UGFyc2VyLkZVVFVSRV9QUklOVF9GVU5DVElPTiA9IFwicHJpbnRfZnVuY3Rpb25cIjtcblx0UGFyc2VyLkZVVFVSRV9VTklDT0RFX0xJVEVSQUxTID0gXCJ1bmljb2RlX2xpdGVyYWxzXCI7XG5cdFBhcnNlci5GVVRVUkVfRElWSVNJT04gPSBcImRpdmlzaW9uXCI7XG5cdFBhcnNlci5GVVRVUkVfQUJTT0xVVEVfSU1QT1JUID0gXCJhYnNvbHV0ZV9pbXBvcnRcIjtcblx0UGFyc2VyLkZVVFVSRV9XSVRIX1NUQVRFTUVOVCA9IFwid2l0aF9zdGF0ZW1lbnRcIjtcblx0UGFyc2VyLkZVVFVSRV9ORVNURURfU0NPUEVTID0gXCJuZXN0ZWRfc2NvcGVzXCI7XG5cdFBhcnNlci5GVVRVUkVfR0VORVJBVE9SUyA9IFwiZ2VuZXJhdG9yc1wiO1xuXHRQYXJzZXIuQ09fRlVUVVJFX1BSSU5UX0ZVTkNUSU9OID0gMHgxMDAwMDtcblx0UGFyc2VyLkNPX0ZVVFVSRV9VTklDT0RFX0xJVEVSQUxTID0gMHgyMDAwMDtcblx0UGFyc2VyLkNPX0ZVVFVSRV9ESVZJU09OID0gMHgyMDAwO1xuXHRQYXJzZXIuQ09fRlVUVVJFX0FCU09MVVRFX0lNUE9SVCA9IDB4NDAwMDtcblx0UGFyc2VyLkNPX0ZVVFVSRV9XSVRIX1NUQVRFTUVOVCA9IDB4ODAwMDtcblxuXHRQYXJzZXIucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG5cdCAgICB2YXIgc3RhY2tlbnRyeTtcblx0ICAgIHZhciBuZXdub2RlO1xuXHQgICAgc3RhcnQgPSBzdGFydCB8fCB0aGlzLmdyYW1tYXIuc3RhcnQ7XG5cdCAgICAvL3ByaW50KFwiU1RBUlQ6XCIrc3RhcnQpO1xuXG5cdCAgICBuZXdub2RlID1cblx0ICAgIHtcblx0ICAgICAgICB0eXBlICAgIDogc3RhcnQsXG5cdCAgICAgICAgdmFsdWUgICA6IG51bGwsXG5cdCAgICAgICAgY29udGV4dCA6IG51bGwsXG5cdCAgICAgICAgY2hpbGRyZW46IFtdXG5cdCAgICB9O1xuXHQgICAgc3RhY2tlbnRyeSA9XG5cdCAgICB7XG5cdCAgICAgICAgZGZhICA6IHRoaXMuZ3JhbW1hci5kZmFzW3N0YXJ0XSxcblx0ICAgICAgICBzdGF0ZTogMCxcblx0ICAgICAgICBub2RlIDogbmV3bm9kZVxuXHQgICAgfTtcblx0ICAgIHRoaXMuc3RhY2sgPSBbc3RhY2tlbnRyeV07XG5cdCAgICB0aGlzLnVzZWRfbmFtZXMgPSB7fTtcblx0fTtcblxuXHRmdW5jdGlvbiBmaW5kSW5EZmEgKGEsIG9iaikge1xuXHQgICAgdmFyIGkgPSBhLmxlbmd0aDtcblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgICBpZiAoYVtpXVswXSA9PT0gb2JqWzBdICYmIGFbaV1bMV0gPT09IG9ialsxXSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXG5cdC8vIEFkZCBhIHRva2VuOyByZXR1cm4gdHJ1ZSBpZiB3ZSdyZSBkb25lXG5cdFBhcnNlci5wcm90b3R5cGUuYWRkdG9rZW4gPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUsIGNvbnRleHQpIHtcblx0ICAgIHZhciBlcnJsaW5lO1xuXHQgICAgdmFyIGl0c2ZpcnN0O1xuXHQgICAgdmFyIGl0c2RmYTtcblx0ICAgIHZhciBzdGF0ZTtcblx0ICAgIHZhciB2O1xuXHQgICAgdmFyIHQ7XG5cdCAgICB2YXIgbmV3c3RhdGU7XG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciBhO1xuXHQgICAgdmFyIGFyY3M7XG5cdCAgICB2YXIgZmlyc3Q7XG5cdCAgICB2YXIgc3RhdGVzO1xuXHQgICAgdmFyIHRwO1xuXHQgICAgdmFyIGlsYWJlbCA9IHRoaXMuY2xhc3NpZnkodHlwZSwgdmFsdWUsIGNvbnRleHQpO1xuXHQgICAgLy9wcmludChcImlsYWJlbDpcIitpbGFiZWwpO1xuXG5cdCAgICBPVVRFUldISUxFOlxuXHQgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICB0cCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcblx0ICAgICAgICBzdGF0ZXMgPSB0cC5kZmFbMF07XG5cdCAgICAgICAgZmlyc3QgPSB0cC5kZmFbMV07XG5cdCAgICAgICAgYXJjcyA9IHN0YXRlc1t0cC5zdGF0ZV07XG5cblx0ICAgICAgICAvLyBsb29rIGZvciBhIHN0YXRlIHdpdGggdGhpcyBsYWJlbFxuXHQgICAgICAgIGZvciAoYSA9IDA7IGEgPCBhcmNzLmxlbmd0aDsgKythKSB7XG5cdCAgICAgICAgICAgIGkgPSBhcmNzW2FdWzBdO1xuXHQgICAgICAgICAgICBuZXdzdGF0ZSA9IGFyY3NbYV1bMV07XG5cdCAgICAgICAgICAgIHQgPSB0aGlzLmdyYW1tYXIubGFiZWxzW2ldWzBdO1xuXHQgICAgICAgICAgICB2ID0gdGhpcy5ncmFtbWFyLmxhYmVsc1tpXVsxXTtcblx0ICAgICAgICAgICAgaWYgKGlsYWJlbCA9PT0gaSkge1xuXHQgICAgICAgICAgICAgICAgLy8gbG9vayBpdCB1cCBpbiB0aGUgbGlzdCBvZiBsYWJlbHNcblx0ICAgICAgICAgICAgICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQodCA8IDI1Nik7XG5cdCAgICAgICAgICAgICAgICAvLyBzaGlmdCBhIHRva2VuOyB3ZSdyZSBkb25lIHdpdGggaXRcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2hpZnQodHlwZSwgdmFsdWUsIG5ld3N0YXRlLCBjb250ZXh0KTtcblx0ICAgICAgICAgICAgICAgIC8vIHBvcCB3aGlsZSB3ZSBhcmUgaW4gYW4gYWNjZXB0LW9ubHkgc3RhdGVcblx0ICAgICAgICAgICAgICAgIHN0YXRlID0gbmV3c3RhdGU7XG5cdCAgICAgICAgICAgICAgICAvL3ByaW50KFwiYmVmb3JlOlwiK0pTT04uc3RyaW5naWZ5KHN0YXRlc1tzdGF0ZV0pICsgXCI6c3RhdGU6XCIrc3RhdGUrXCI6XCIrSlNPTi5zdHJpbmdpZnkoc3RhdGVzW3N0YXRlXSkpO1xuXHQgICAgICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlc1tzdGF0ZV0ubGVuZ3RoID09PSAxXG5cdCAgICAgICAgICAgICAgICAgICAgJiYgc3RhdGVzW3N0YXRlXVswXVswXSA9PT0gMFxuXHQgICAgICAgICAgICAgICAgICAgICYmIHN0YXRlc1tzdGF0ZV1bMF1bMV0gPT09IHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGVzW3N0YXRlXSA9PSBbKDAsIHN0YXRlKV0pXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAvL3ByaW50KFwiaW4gYWZ0ZXIgcG9wOlwiK0pTT04uc3RyaW5naWZ5KHN0YXRlc1tzdGF0ZV0pICsgXCI6c3RhdGU6XCIrc3RhdGUrXCI6XCIrSlNPTi5zdHJpbmdpZnkoc3RhdGVzW3N0YXRlXSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb25lIVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdHAgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0cC5zdGF0ZTtcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZXMgPSB0cC5kZmFbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0cC5kZmFbMV07XG5cdCAgICAgICAgICAgICAgICAgICAgLy9wcmludChKU09OLnN0cmluZ2lmeShzdGF0ZXMpLCBKU09OLnN0cmluZ2lmeShmaXJzdCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vcHJpbnQoXCJib3R0b206XCIrSlNPTi5zdHJpbmdpZnkoc3RhdGVzW3N0YXRlXSkgKyBcIjpzdGF0ZTpcIitzdGF0ZStcIjpcIitKU09OLnN0cmluZ2lmeShzdGF0ZXNbc3RhdGVdKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXHQgICAgICAgICAgICAgICAgLy8gZG9uZSB3aXRoIHRoaXMgdG9rZW5cblx0ICAgICAgICAgICAgICAgIC8vcHJpbnQoXCJET05FLCByZXR1cm4gZmFsc2VcIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodCA+PSAyNTYpIHtcblx0ICAgICAgICAgICAgICAgIGl0c2RmYSA9IHRoaXMuZ3JhbW1hci5kZmFzW3RdO1xuXHQgICAgICAgICAgICAgICAgaXRzZmlyc3QgPSBpdHNkZmFbMV07XG5cdCAgICAgICAgICAgICAgICBpZiAoaXRzZmlyc3QuaGFzT3duUHJvcGVydHkoaWxhYmVsKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggYSBzeW1ib2xcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2godCwgdGhpcy5ncmFtbWFyLmRmYXNbdF0sIG5ld3N0YXRlLCBjb250ZXh0KTtcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBPVVRFUldISUxFO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy9wcmludChcImZpbmRJbkRmYTogXCIgKyBKU09OLnN0cmluZ2lmeShhcmNzKStcIiB2cy4gXCIgKyB0cC5zdGF0ZSk7XG5cdCAgICAgICAgaWYgKGZpbmRJbkRmYShhcmNzLCBbMCwgdHAuc3RhdGVdKSkge1xuXHQgICAgICAgICAgICAvLyBhbiBhY2NlcHRpbmcgc3RhdGUsIHBvcCBpdCBhbmQgdHJ5IHNvbWV0aGlnbiBlbHNlXG5cdCAgICAgICAgICAgIC8vcHJpbnQoXCJXQUFcIik7XG5cdCAgICAgICAgICAgIHRoaXMucG9wKCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJ0b28gbXVjaCBpbnB1dFwiLCB0aGlzLmZpbGVuYW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIG5vIHRyYW5zaXRpb25cblx0ICAgICAgICAgICAgZXJybGluZSA9IGNvbnRleHRbMF1bMF07XG5cblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgYXIgPSBhcmNzLm1hcChmdW5jdGlvbihhKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaSA9IGFbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9IHRoYXQuZ3JhbW1hci5sYWJlbHNbaV1bMF07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gU2submFtZUZvclRva2VuKHQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdmFyIGV4dHJhID0ge1xuXHQgICAgICAgICAgICAgICAga2luZDogXCJEQUdfTUlTU1wiLFxuXHQgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGFyLFxuXHQgICAgICAgICAgICAgICAgZm91bmQ6IFNrLm5hbWVGb3JUb2tlbih0eXBlKSxcblx0ICAgICAgICAgICAgICAgIGZvdW5kX3ZhbDogdmFsdWUsXG5cdCAgICAgICAgICAgICAgICBpbnNpZGU6IFNrLm5hbWVGb3JUb2tlbih0cC5ub2RlLnR5cGUpLFxuXHQgICAgICAgICAgICAgICAgbm9kZTogdHAubm9kZSxcblx0ICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5zdGFjay5sZW5ndGggPiAxID8gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdLm5vZGUgOiB1bmRlZmluZWRcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdmFyIHJlYXNvbiA9IFwiZXhwZWN0ZWQgXCIgKyBhci5qb2luKCcsICcpICsgXCIgYnV0IGZvdW5kIFwiICsgZXh0cmEuZm91bmQgKyBcIiB3aGlsZSBwYXJzaW5nIFwiICsgZXh0cmEuaW5zaWRlO1xuXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKHJlYXNvbiwgdGhpcy5maWxlbmFtZSwgZXJybGluZSwgY29udGV4dCwgZXh0cmEpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fTtcblxuXHQvLyB0dXJuIGEgdG9rZW4gaW50byBhIGxhYmVsXG5cdFBhcnNlci5wcm90b3R5cGUuY2xhc3NpZnkgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUsIGNvbnRleHQpIHtcblx0ICAgIHZhciBpbGFiZWw7XG5cdCAgICBpZiAodHlwZSA9PT0gU2suVG9rZW5pemVyLlRva2Vucy5UX05BTUUpIHtcblx0ICAgICAgICB0aGlzLnVzZWRfbmFtZXNbdmFsdWVdID0gdHJ1ZTtcblx0ICAgICAgICBpbGFiZWwgPSB0aGlzLmdyYW1tYXIua2V5d29yZHMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHRoaXMuZ3JhbW1hci5rZXl3b3Jkc1t2YWx1ZV07XG5cblx0ICAgICAgICAvKiBDaGVjayBmb3IgaGFuZGxpbmcgcHJpbnQgYXMgYW4gYnVpbHRpbiBmdW5jdGlvbiAqL1xuXHQgICAgICAgIGlmKHZhbHVlID09PSBcInByaW50XCIgJiYgKHRoaXMucF9mbGFncyAmIFBhcnNlci5DT19GVVRVUkVfUFJJTlRfRlVOQ1RJT04gfHwgU2sucHl0aG9uMyA9PT0gdHJ1ZSkpIHtcblx0ICAgICAgICAgICAgaWxhYmVsID0gZmFsc2U7IC8vIGlsYWJlbCBkZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBhIGtleXdvcmRcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaWxhYmVsKSB7XG5cdCAgICAgICAgICAgIC8vcHJpbnQoXCJpcyBrZXl3b3JkXCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gaWxhYmVsO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlsYWJlbCA9IHRoaXMuZ3JhbW1hci50b2tlbnMuaGFzT3duUHJvcGVydHkodHlwZSkgJiYgdGhpcy5ncmFtbWFyLnRva2Vuc1t0eXBlXTtcblx0ICAgIGlmICghaWxhYmVsKSB7XG5cdCAgICAgICAgLy8gdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJiYWQgdG9rZW5cIiwgdHlwZSwgdmFsdWUsIGNvbnRleHQpO1xuXHQgICAgICAgIC8vIFF1ZXN0aW9uYWJsZSBtb2RpZmljYXRpb24gdG8gcHV0IGxpbmUgbnVtYmVyIGluIHBvc2l0aW9uIDJcblx0ICAgICAgICAvLyBsaWtlIGV2ZXJ5d2hlcmUgZWxzZSBhbmQgZmlsZW5hbWUgaW4gcG9zaXRpb24gMS5cblx0ICAgICAgICB2YXIgZXh0cmEgPSB7XG5cdCAgICAgICAgICAgIGtpbmQ6IFwiQ0xBU1NJRllcIixcblx0ICAgICAgICAgICAgdHlwZTogdHlwZSxcblx0ICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImJhZCB0b2tlblwiLCB0aGlzLmZpbGVuYW1lLCBjb250ZXh0WzBdWzBdLCBjb250ZXh0LCBleHRyYSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gaWxhYmVsO1xuXHR9O1xuXG5cdC8vIHNoaWZ0IGEgdG9rZW5cblx0UGFyc2VyLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSwgbmV3c3RhdGUsIGNvbnRleHQpIHtcblx0ICAgIHZhciBkZmEgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0uZGZhO1xuXHQgICAgdmFyIHN0YXRlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdLnN0YXRlO1xuXHQgICAgdmFyIG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcblx0ICAgIC8vcHJpbnQoXCJjb250ZXh0XCIsIGNvbnRleHQpO1xuXHQgICAgdmFyIG5ld25vZGUgPSB7XG5cdCAgICAgICAgdHlwZSAgICAgIDogdHlwZSxcblx0ICAgICAgICB2YWx1ZSAgICAgOiB2YWx1ZSxcblx0ICAgICAgICBsaW5lbm8gICAgOiBjb250ZXh0WzBdWzBdLCAgICAgICAgIC8vIHRocm93aW5nIGF3YXkgZW5kIGhlcmUgdG8gbWF0Y2ggY3B5dGhvblxuXHQgICAgICAgIGNvbF9vZmZzZXQ6IGNvbnRleHRbMF1bMV0sXG5cdCAgICAgICAgY2hpbGRyZW4gIDogbnVsbFxuXHQgICAgfTtcblx0ICAgIGlmIChuZXdub2RlKSB7XG5cdCAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ld25vZGUpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0ge1xuXHQgICAgICAgIGRmYSAgOiBkZmEsXG5cdCAgICAgICAgc3RhdGU6IG5ld3N0YXRlLFxuXHQgICAgICAgIG5vZGUgOiBub2RlXG5cdCAgICB9O1xuXHR9O1xuXG5cdC8vIHB1c2ggYSBub250ZXJtaW5hbFxuXHRQYXJzZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgbmV3ZGZhLCBuZXdzdGF0ZSwgY29udGV4dCkge1xuXHQgICAgdmFyIGRmYSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXS5kZmE7XG5cdCAgICB2YXIgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXS5ub2RlO1xuXHQgICAgdmFyIG5ld25vZGUgPSB7XG5cdCAgICAgICAgdHlwZSAgICAgIDogdHlwZSxcblx0ICAgICAgICB2YWx1ZSAgICAgOiBudWxsLFxuXHQgICAgICAgIGxpbmVubyAgICA6IGNvbnRleHRbMF1bMF0sICAgICAgLy8gdGhyb3dpbmcgYXdheSBlbmQgaGVyZSB0byBtYXRjaCBjcHl0aG9uXG5cdCAgICAgICAgY29sX29mZnNldDogY29udGV4dFswXVsxXSxcblx0ICAgICAgICBjaGlsZHJlbiAgOiBbXVxuXHQgICAgfTtcblx0ICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IHtcblx0ICAgICAgICBkZmEgIDogZGZhLFxuXHQgICAgICAgIHN0YXRlOiBuZXdzdGF0ZSxcblx0ICAgICAgICBub2RlIDogbm9kZVxuXHQgICAgfTtcblx0ICAgIHRoaXMuc3RhY2sucHVzaCh7XG5cdCAgICAgICAgZGZhICA6IG5ld2RmYSxcblx0ICAgICAgICBzdGF0ZTogMCxcblx0ICAgICAgICBub2RlIDogbmV3bm9kZVxuXHQgICAgfSk7XG5cdH07XG5cblx0Ly92YXIgYWMgPSAwO1xuXHQvL3ZhciBiYyA9IDA7XG5cblx0Ly8gcG9wIGEgbm9udGVybWluYWxcblx0UGFyc2VyLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgbm9kZTtcblx0ICAgIHZhciBwb3AgPSB0aGlzLnN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIG5ld25vZGUgPSBwb3Aubm9kZTtcblx0ICAgIC8vcHJpbnQoXCJQT1BcIik7XG5cdCAgICBpZiAobmV3bm9kZSkge1xuXHQgICAgICAgIC8vcHJpbnQoXCJBXCIsIGFjKyssIG5ld25vZGUudHlwZSk7XG5cdCAgICAgICAgLy9wcmludChcInN0YWNrbGVuOlwiK3RoaXMuc3RhY2subGVuZ3RoKTtcblx0ICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT09IDApIHtcblx0ICAgICAgICAgICAgLy9wcmludChcIkJcIiwgYmMrKyk7XG5cdCAgICAgICAgICAgIG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcblx0ICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ld25vZGUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vcHJpbnQoXCJDXCIpO1xuXHQgICAgICAgICAgICB0aGlzLnJvb3Rub2RlID0gbmV3bm9kZTtcblx0ICAgICAgICAgICAgdGhpcy5yb290bm9kZS51c2VkX25hbWVzID0gdGhpcy51c2VkX25hbWVzO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogcGFyc2VyIGZvciBpbnRlcmFjdGl2ZSBpbnB1dC4gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoXG5cdCAqIGxpbmVzIG9mIGlucHV0IGFzIHRoZXkgYXJlIGVudGVyZWQuIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZVxuXHQgKiB1bnRpbCB0aGUgaW5wdXQgaXMgY29tcGxldGUsIHdoZW4gaXQgd2lsbCByZXR1cm4gdGhlIHJvb3Rub2RlIG9mIHRoZSBwYXJzZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gc3R5bGUgcm9vdCBvZiBwYXJzZSB0cmVlIChvcHRpb25hbClcblx0ICovXG5cdGZ1bmN0aW9uIG1ha2VQYXJzZXIgKGZpbGVuYW1lLCBzdHlsZSkge1xuXHQgICAgdmFyIHRva2VuaXplcjtcblx0ICAgIHZhciBUX09QO1xuXHQgICAgdmFyIFRfTkw7XG5cdCAgICB2YXIgVF9DT01NRU5UO1xuXHQgICAgdmFyIHByZWZpeDtcblx0ICAgIHZhciBjb2x1bW47XG5cdCAgICB2YXIgbGluZW5vO1xuXHQgICAgdmFyIHA7XG5cdCAgICBpZiAoc3R5bGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHN0eWxlID0gXCJmaWxlX2lucHV0XCI7XG5cdCAgICB9XG5cdCAgICBwID0gbmV3IFBhcnNlcihmaWxlbmFtZSwgU2suUGFyc2VUYWJsZXMpO1xuXHQgICAgLy8gZm9yIGNsb3N1cmUncyBiZW5lZml0XG5cdCAgICBpZiAoc3R5bGUgPT09IFwiZmlsZV9pbnB1dFwiKSB7XG5cdCAgICAgICAgcC5zZXR1cChTay5QYXJzZVRhYmxlcy5zeW0uZmlsZV9pbnB1dCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGdvb2cuYXNzZXJ0cy5mYWlsKFwidG9kbztcIik7XG5cdCAgICB9XG5cdCAgICBsaW5lbm8gPSAxO1xuXHQgICAgY29sdW1uID0gMDtcblx0ICAgIHByZWZpeCA9IFwiXCI7XG5cdCAgICBUX0NPTU1FTlQgPSBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfQ09NTUVOVDtcblx0ICAgIFRfTkwgPSBTay5Ub2tlbml6ZXIuVG9rZW5zLlRfTkw7XG5cdCAgICBUX09QID0gU2suVG9rZW5pemVyLlRva2Vucy5UX09QO1xuXHQgICAgdG9rZW5pemVyID0gbmV3IFNrLlRva2VuaXplcihmaWxlbmFtZSwgc3R5bGUgPT09IFwic2luZ2xlX2lucHV0XCIsIGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSwgc3RhcnQsIGVuZCwgbGluZSkge1xuXHQgICAgICAgIHZhciBzX2xpbmVubyA9IHN0YXJ0WzBdO1xuXHQgICAgICAgIHZhciBzX2NvbHVtbiA9IHN0YXJ0WzFdO1xuXHQgICAgICAgIC8qXG5cdCAgICAgICAgIGlmIChzX2xpbmVubyAhPT0gbGluZW5vICYmIHNfY29sdW1uICE9PSBjb2x1bW4pXG5cdCAgICAgICAgIHtcblx0ICAgICAgICAgLy8gdG9kbzsgdXBkYXRlIHByZWZpeCBhbmQgbGluZS9jb2xcblx0ICAgICAgICAgfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGlmICh0eXBlID09PSBUX0NPTU1FTlQgfHwgdHlwZSA9PT0gVF9OTCkge1xuXHQgICAgICAgICAgICBwcmVmaXggKz0gdmFsdWU7XG5cdCAgICAgICAgICAgIGxpbmVubyA9IGVuZFswXTtcblx0ICAgICAgICAgICAgY29sdW1uID0gZW5kWzFdO1xuXHQgICAgICAgICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09IFwiXFxuXCIpIHtcblx0ICAgICAgICAgICAgICAgIGxpbmVubyArPSAxO1xuXHQgICAgICAgICAgICAgICAgY29sdW1uID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL3ByaW50KFwiICBub3QgY2FsbGluZyBhZGR0b2tlblwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGUgPT09IFRfT1ApIHtcblx0ICAgICAgICAgICAgdHlwZSA9IFNrLk9wTWFwW3ZhbHVlXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHAuYWRkdG9rZW4odHlwZSwgdmFsdWUsIFtzdGFydCwgZW5kLCBsaW5lXSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8vIGNyZWF0ZSBwYXJzZXIgZnVuY3Rpb25cblx0ICAgIHZhciBwYXJzZUZ1bmMgPSBmdW5jdGlvbiAobGluZSkge1xuXHQgICAgICAgIHZhciByZXQgPSB0b2tlbml6ZXIuZ2VuZXJhdGVUb2tlbnMobGluZSk7XG5cdCAgICAgICAgLy9wcmludChcInRvazpcIityZXQpO1xuXHQgICAgICAgIGlmIChyZXQpIHtcblx0ICAgICAgICAgICAgaWYgKHJldCAhPT0gXCJkb25lXCIpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaW5jb21wbGV0ZSBpbnB1dFwiLCB0aGlzLmZpbGVuYW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcC5yb290bm9kZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfTtcblxuXHQgICAgLy8gc2V0IGZsYWdzLCBhbmQgcmV0dXJuXG5cdCAgICBwYXJzZUZ1bmMucF9mbGFncyA9IHAucF9mbGFncztcblx0ICAgIHJldHVybiBwYXJzZUZ1bmM7XG5cdH1cblxuXHRTay5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChmaWxlbmFtZSwgaW5wdXQpIHtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIHJldDtcblx0ICAgIHZhciBsaW5lcztcblx0ICAgIHZhciBwYXJzZUZ1bmMgPSBtYWtlUGFyc2VyKGZpbGVuYW1lKTtcblx0ICAgIGlmIChpbnB1dC5zdWJzdHIoaW5wdXQubGVuZ3RoIC0gMSwgMSkgIT09IFwiXFxuXCIpIHtcblx0ICAgICAgICBpbnB1dCArPSBcIlxcblwiO1xuXHQgICAgfVxuXHQgICAgLy9wcmludChcImlucHV0OlwiK2lucHV0KTtcblx0ICAgIGxpbmVzID0gaW5wdXQuc3BsaXQoXCJcXG5cIik7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICByZXQgPSBwYXJzZUZ1bmMobGluZXNbaV0gKyAoKGkgPT09IGxpbmVzLmxlbmd0aCAtIDEpID8gXCJcIiA6IFwiXFxuXCIpKTtcblx0ICAgIH1cblxuXHQgICAgLypcblx0ICAgICAqIFNtYWxsIGFkanVzdG1lbnRzIGhlcmUgaW4gb3JkZXIgdG8gcmV0dXJuIHRoIGZsYWdzIGFuZCB0aGUgY3N0XG5cdCAgICAgKi9cblx0ICAgIHJldHVybiB7XCJjc3RcIjogcmV0LCBcImZsYWdzXCI6IHBhcnNlRnVuYy5wX2ZsYWdzfTtcblx0fTtcblxuXHRTay5wYXJzZVRyZWVEdW1wID0gZnVuY3Rpb24gcGFyc2VUcmVlRHVtcCAobiwgaW5kZW50KSB7XG5cdCAgICAvL3JldHVybiBKU09OLnN0cmluZ2lmeShuLCBudWxsLCAyKTtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIHJldDtcblx0ICAgIGluZGVudCA9IGluZGVudCB8fCBcIlwiO1xuXHQgICAgcmV0ID0gXCJcIjtcblx0ICAgIHJldCArPSBpbmRlbnQ7XG5cdCAgICBpZiAobi50eXBlID49IDI1NikgeyAvLyBub24tdGVybVxuXHQgICAgICAgIHJldCArPSBTay5QYXJzZVRhYmxlcy5udW1iZXIyc3ltYm9sW24udHlwZV0gKyBcIlxcblwiO1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIHJldCArPSBTay5wYXJzZVRyZWVEdW1wKG4uY2hpbGRyZW5baV0sIGluZGVudCArIFwiICBcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXQgKz0gU2suVG9rZW5pemVyLnRva2VuTmFtZXNbbi50eXBlXSArIFwiOiBcIiArIG5ldyBTay5idWlsdGluLnN0cihuLnZhbHVlKVtcIiRyXCJdKCkudiArIFwiXFxuXCI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmV0O1xuXHR9O1xuXG5cblx0Z29vZy5leHBvcnRTeW1ib2woXCJTay5wYXJzZVwiLCBTay5wYXJzZSk7XG5cdGdvb2cuZXhwb3J0U3ltYm9sKFwiU2sucGFyc2VUcmVlRHVtcFwiLCBTay5wYXJzZVRyZWVEdW1wKTtcblxuXG5cblx0LyogLS0tLSAvVXNlcnMvcm9iL3NrdWxwdHkvbGliLy4uL25vZGVfbW9kdWxlcy9za3VscHQvZ2VuL2FzdG5vZGVzLmpzIC0tLS0gKi8gXG5cblx0LyogRmlsZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSAuL2FzZGxfanMucHkuICovXG5cblx0LyogLS0tLS0gZXhwcl9jb250ZXh0IC0tLS0tICovXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gTG9hZCgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gU3RvcmUoKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIERlbCgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQXVnTG9hZCgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQXVnU3RvcmUoKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFBhcmFtKCkge31cblxuXHQvKiAtLS0tLSBib29sb3AgLS0tLS0gKi9cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBBbmQoKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIE9yKCkge31cblxuXHQvKiAtLS0tLSBvcGVyYXRvciAtLS0tLSAqL1xuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEFkZCgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gU3ViKCkge31cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBNdWx0KCkge31cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBEaXYoKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIE1vZCgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gUG93KCkge31cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBMU2hpZnQoKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFJTaGlmdCgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQml0T3IoKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEJpdFhvcigpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQml0QW5kKCkge31cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBGbG9vckRpdigpIHt9XG5cblx0LyogLS0tLS0gdW5hcnlvcCAtLS0tLSAqL1xuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEludmVydCgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gTm90KCkge31cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBVQWRkKCkge31cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBVU3ViKCkge31cblxuXHQvKiAtLS0tLSBjbXBvcCAtLS0tLSAqL1xuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEVxKCkge31cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBOb3RFcSgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gTHQoKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEx0RSgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gR3QoKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEd0RSgpIHt9XG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gSXMoKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIElzTm90KCkge31cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBJbl8oKSB7fVxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIE5vdEluKCkge31cblxuXG5cblxuXG5cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdC8qIGNvbnN0cnVjdG9ycyBmb3Igbm9kZXMgKi9cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cblxuXG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBNb2R1bGUoLyoge2FzZGxfc2VxICp9ICovIGJvZHkpXG5cdHtcblx0ICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gSW50ZXJhY3RpdmUoLyoge2FzZGxfc2VxICp9ICovIGJvZHkpXG5cdHtcblx0ICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gRXhwcmVzc2lvbigvKiB7ZXhwcl90eX0gKi8gYm9keSlcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFN1aXRlKC8qIHthc2RsX3NlcSAqfSAqLyBib2R5KVxuXHR7XG5cdCAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEZ1bmN0aW9uRGVmKC8qIHtpZGVudGlmaWVyfSAqLyBuYW1lLCAvKiB7YXJndW1lbnRzX190eX0gKi8gYXJncywgLypcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICB7YXNkbF9zZXEgKn0gKi8gYm9keSwgLyoge2FzZGxfc2VxICp9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9yX2xpc3QsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoYXJncyAhPT0gbnVsbCAmJiBhcmdzICE9PSB1bmRlZmluZWQpO1xuXHQgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgIHRoaXMuYXJncyA9IGFyZ3M7XG5cdCAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgdGhpcy5kZWNvcmF0b3JfbGlzdCA9IGRlY29yYXRvcl9saXN0O1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENsYXNzRGVmKC8qIHtpZGVudGlmaWVyfSAqLyBuYW1lLCAvKiB7YXNkbF9zZXEgKn0gKi8gYmFzZXMsIC8qXG5cdCAgICAgICAgICAgICAgICAgICAgICAge2FzZGxfc2VxICp9ICovIGJvZHksIC8qIHthc2RsX3NlcSAqfSAqLyBkZWNvcmF0b3JfbGlzdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAvKiB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQobmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB1bmRlZmluZWQpO1xuXHQgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgIHRoaXMuYmFzZXMgPSBiYXNlcztcblx0ICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICB0aGlzLmRlY29yYXRvcl9saXN0ID0gZGVjb3JhdG9yX2xpc3Q7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gUmV0dXJuXygvKiB7ZXhwcl90eX0gKi8gdmFsdWUsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi9cblx0ICAgICAgICAgICAgICAgICAgICAgIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBEZWxldGVfKC8qIHthc2RsX3NlcSAqfSAqLyB0YXJnZXRzLCAvKiB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgICBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICB0aGlzLnRhcmdldHMgPSB0YXJnZXRzO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEFzc2lnbigvKiB7YXNkbF9zZXEgKn0gKi8gdGFyZ2V0cywgLyoge2V4cHJfdHl9ICovIHZhbHVlLCAvKiB7aW50fSAqL1xuXHQgICAgICAgICAgICAgICAgICAgICBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLnRhcmdldHMgPSB0YXJnZXRzO1xuXHQgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEF1Z0Fzc2lnbigvKiB7ZXhwcl90eX0gKi8gdGFyZ2V0LCAvKiB7b3BlcmF0b3JfdHl9ICovIG9wLCAvKiB7ZXhwcl90eX1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgKi8gdmFsdWUsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB1bmRlZmluZWQpO1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChvcCAhPT0gbnVsbCAmJiBvcCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0ICAgIHRoaXMub3AgPSBvcDtcblx0ICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBQcmludCgvKiB7ZXhwcl90eX0gKi8gZGVzdCwgLyoge2FzZGxfc2VxICp9ICovIHZhbHVlcywgLyoge2Jvb2x9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgbmwsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgdGhpcy5kZXN0ID0gZGVzdDtcblx0ICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXHQgICAgdGhpcy5ubCA9IG5sO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEZvcl8oLyoge2V4cHJfdHl9ICovIHRhcmdldCwgLyoge2V4cHJfdHl9ICovIGl0ZXIsIC8qIHthc2RsX3NlcSAqfSAqL1xuXHQgICAgICAgICAgICAgICAgICAgYm9keSwgLyoge2FzZGxfc2VxICp9ICovIG9yZWxzZSwgLyoge2ludH0gKi8gbGluZW5vLCAvKlxuXHQgICAgICAgICAgICAgICAgICAge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB1bmRlZmluZWQpO1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChpdGVyICE9PSBudWxsICYmIGl0ZXIgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0ICAgIHRoaXMuaXRlciA9IGl0ZXI7XG5cdCAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgdGhpcy5vcmVsc2UgPSBvcmVsc2U7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gV2hpbGVfKC8qIHtleHByX3R5fSAqLyB0ZXN0LCAvKiB7YXNkbF9zZXEgKn0gKi8gYm9keSwgLyoge2FzZGxfc2VxICp9XG5cdCAgICAgICAgICAgICAgICAgICAgICovIG9yZWxzZSwgLyoge2ludH0gKi8gbGluZW5vLCAvKiB7aW50fSAqLyBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KHRlc3QgIT09IG51bGwgJiYgdGVzdCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMudGVzdCA9IHRlc3Q7XG5cdCAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgdGhpcy5vcmVsc2UgPSBvcmVsc2U7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gSWZfKC8qIHtleHByX3R5fSAqLyB0ZXN0LCAvKiB7YXNkbF9zZXEgKn0gKi8gYm9keSwgLyoge2FzZGxfc2VxICp9ICovXG5cdCAgICAgICAgICAgICAgICAgIG9yZWxzZSwgLyoge2ludH0gKi8gbGluZW5vLCAvKiB7aW50fSAqLyBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KHRlc3QgIT09IG51bGwgJiYgdGVzdCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMudGVzdCA9IHRlc3Q7XG5cdCAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgdGhpcy5vcmVsc2UgPSBvcmVsc2U7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gV2l0aF8oLyoge2V4cHJfdHl9ICovIGNvbnRleHRfZXhwciwgLyoge2V4cHJfdHl9ICovIG9wdGlvbmFsX3ZhcnMsIC8qXG5cdCAgICAgICAgICAgICAgICAgICAge2FzZGxfc2VxICp9ICovIGJvZHksIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi9cblx0ICAgICAgICAgICAgICAgICAgICBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGNvbnRleHRfZXhwciAhPT0gbnVsbCAmJiBjb250ZXh0X2V4cHIgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLmNvbnRleHRfZXhwciA9IGNvbnRleHRfZXhwcjtcblx0ICAgIHRoaXMub3B0aW9uYWxfdmFycyA9IG9wdGlvbmFsX3ZhcnM7XG5cdCAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFJhaXNlKC8qIHtleHByX3R5fSAqLyB0eXBlLCAvKiB7ZXhwcl90eX0gKi8gaW5zdCwgLyoge2V4cHJfdHl9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgdGJhY2ssIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgdGhpcy50eXBlID0gdHlwZTtcblx0ICAgIHRoaXMuaW5zdCA9IGluc3Q7XG5cdCAgICB0aGlzLnRiYWNrID0gdGJhY2s7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gVHJ5RXhjZXB0KC8qIHthc2RsX3NlcSAqfSAqLyBib2R5LCAvKiB7YXNkbF9zZXEgKn0gKi8gaGFuZGxlcnMsIC8qXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHthc2RsX3NlcSAqfSAqLyBvcmVsc2UsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sX29mZnNldClcblx0e1xuXHQgICAgdGhpcy5ib2R5ID0gYm9keTtcblx0ICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcblx0ICAgIHRoaXMub3JlbHNlID0gb3JlbHNlO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFRyeUZpbmFsbHkoLyoge2FzZGxfc2VxICp9ICovIGJvZHksIC8qIHthc2RsX3NlcSAqfSAqLyBmaW5hbGJvZHksIC8qXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICB0aGlzLmZpbmFsYm9keSA9IGZpbmFsYm9keTtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBBc3NlcnQoLyoge2V4cHJfdHl9ICovIHRlc3QsIC8qIHtleHByX3R5fSAqLyBtc2csIC8qIHtpbnR9ICovIGxpbmVubyxcblx0ICAgICAgICAgICAgICAgICAgICAgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh0ZXN0ICE9PSBudWxsICYmIHRlc3QgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuXHQgICAgdGhpcy5tc2cgPSBtc2c7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gSW1wb3J0XygvKiB7YXNkbF9zZXEgKn0gKi8gbmFtZXMsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi9cblx0ICAgICAgICAgICAgICAgICAgICAgIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIHRoaXMubmFtZXMgPSBuYW1lcztcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBJbXBvcnRGcm9tKC8qIHtpZGVudGlmaWVyfSAqLyBtb2R1bGUsIC8qIHthc2RsX3NlcSAqfSAqLyBuYW1lcywgLypcblx0ICAgICAgICAgICAgICAgICAgICAgICAgIHtpbnR9ICovIGxldmVsLCAvKiB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KG1vZHVsZSAhPT0gbnVsbCAmJiBtb2R1bGUgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcblx0ICAgIHRoaXMubmFtZXMgPSBuYW1lcztcblx0ICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBFeGVjKC8qIHtleHByX3R5fSAqLyBib2R5LCAvKiB7ZXhwcl90eX0gKi8gZ2xvYmFscywgLyoge2V4cHJfdHl9ICovXG5cdCAgICAgICAgICAgICAgICAgICBsb2NhbHMsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgdGhpcy5nbG9iYWxzID0gZ2xvYmFscztcblx0ICAgIHRoaXMubG9jYWxzID0gbG9jYWxzO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEdsb2JhbCgvKiB7YXNkbF9zZXEgKn0gKi8gbmFtZXMsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi9cblx0ICAgICAgICAgICAgICAgICAgICAgY29sX29mZnNldClcblx0e1xuXHQgICAgdGhpcy5uYW1lcyA9IG5hbWVzO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEV4cHIoLyoge2V4cHJfdHl9ICovIHZhbHVlLCAvKiB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gUGFzcygvKiB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBCcmVha18oLyoge2ludH0gKi8gbGluZW5vLCAvKiB7aW50fSAqLyBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ29udGludWVfKC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIERlYnVnZ2VyXygvKiB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBCb29sT3AoLyoge2Jvb2xvcF90eX0gKi8gb3AsIC8qIHthc2RsX3NlcSAqfSAqLyB2YWx1ZXMsIC8qIHtpbnR9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChvcCAhPT0gbnVsbCAmJiBvcCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMub3AgPSBvcDtcblx0ICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEJpbk9wKC8qIHtleHByX3R5fSAqLyBsZWZ0LCAvKiB7b3BlcmF0b3JfdHl9ICovIG9wLCAvKiB7ZXhwcl90eX0gKi9cblx0ICAgICAgICAgICAgICAgICAgICByaWdodCwgLyoge2ludH0gKi8gbGluZW5vLCAvKiB7aW50fSAqLyBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGxlZnQgIT09IG51bGwgJiYgbGVmdCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQob3AgIT09IG51bGwgJiYgb3AgIT09IHVuZGVmaW5lZCk7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KHJpZ2h0ICE9PSBudWxsICYmIHJpZ2h0ICE9PSB1bmRlZmluZWQpO1xuXHQgICAgdGhpcy5sZWZ0ID0gbGVmdDtcblx0ICAgIHRoaXMub3AgPSBvcDtcblx0ICAgIHRoaXMucmlnaHQgPSByaWdodDtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBVbmFyeU9wKC8qIHt1bmFyeW9wX3R5fSAqLyBvcCwgLyoge2V4cHJfdHl9ICovIG9wZXJhbmQsIC8qIHtpbnR9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgICBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQob3AgIT09IG51bGwgJiYgb3AgIT09IHVuZGVmaW5lZCk7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KG9wZXJhbmQgIT09IG51bGwgJiYgb3BlcmFuZCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMub3AgPSBvcDtcblx0ICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gTGFtYmRhKC8qIHthcmd1bWVudHNfX3R5fSAqLyBhcmdzLCAvKiB7ZXhwcl90eX0gKi8gYm9keSwgLyoge2ludH0gKi9cblx0ICAgICAgICAgICAgICAgICAgICAgbGluZW5vLCAvKiB7aW50fSAqLyBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGFyZ3MgIT09IG51bGwgJiYgYXJncyAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB1bmRlZmluZWQpO1xuXHQgICAgdGhpcy5hcmdzID0gYXJncztcblx0ICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gSWZFeHAoLyoge2V4cHJfdHl9ICovIHRlc3QsIC8qIHtleHByX3R5fSAqLyBib2R5LCAvKiB7ZXhwcl90eX0gKi9cblx0ICAgICAgICAgICAgICAgICAgICBvcmVsc2UsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh0ZXN0ICE9PSBudWxsICYmIHRlc3QgIT09IHVuZGVmaW5lZCk7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQob3JlbHNlICE9PSBudWxsICYmIG9yZWxzZSAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMudGVzdCA9IHRlc3Q7XG5cdCAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgdGhpcy5vcmVsc2UgPSBvcmVsc2U7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gRGljdCgvKiB7YXNkbF9zZXEgKn0gKi8ga2V5cywgLyoge2FzZGxfc2VxICp9ICovIHZhbHVlcywgLyoge2ludH0gKi9cblx0ICAgICAgICAgICAgICAgICAgIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgdGhpcy5rZXlzID0ga2V5cztcblx0ICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFNldCgvKiB7YXNkbF9zZXEgKn0gKi8gZWx0cywgLyoge2ludH0gKi8gbGluZW5vLCAvKiB7aW50fSAqL1xuXHQgICAgICAgICAgICAgICAgICBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICB0aGlzLmVsdHMgPSBlbHRzO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIExpc3RDb21wKC8qIHtleHByX3R5fSAqLyBlbHQsIC8qIHthc2RsX3NlcSAqfSAqLyBnZW5lcmF0b3JzLCAvKiB7aW50fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChlbHQgIT09IG51bGwgJiYgZWx0ICE9PSB1bmRlZmluZWQpO1xuXHQgICAgdGhpcy5lbHQgPSBlbHQ7XG5cdCAgICB0aGlzLmdlbmVyYXRvcnMgPSBnZW5lcmF0b3JzO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFNldENvbXAoLyoge2V4cHJfdHl9ICovIGVsdCwgLyoge2FzZGxfc2VxICp9ICovIGdlbmVyYXRvcnMsIC8qIHtpbnR9XG5cdCAgICAgICAgICAgICAgICAgICAgICAqLyBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoZWx0ICE9PSBudWxsICYmIGVsdCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMuZWx0ID0gZWx0O1xuXHQgICAgdGhpcy5nZW5lcmF0b3JzID0gZ2VuZXJhdG9ycztcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBEaWN0Q29tcCgvKiB7ZXhwcl90eX0gKi8ga2V5LCAvKiB7ZXhwcl90eX0gKi8gdmFsdWUsIC8qIHthc2RsX3NlcSAqfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICovIGdlbmVyYXRvcnMsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi9cblx0ICAgICAgICAgICAgICAgICAgICAgICBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGtleSAhPT0gbnVsbCAmJiBrZXkgIT09IHVuZGVmaW5lZCk7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpO1xuXHQgICAgdGhpcy5rZXkgPSBrZXk7XG5cdCAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cdCAgICB0aGlzLmdlbmVyYXRvcnMgPSBnZW5lcmF0b3JzO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEdlbmVyYXRvckV4cCgvKiB7ZXhwcl90eX0gKi8gZWx0LCAvKiB7YXNkbF9zZXEgKn0gKi8gZ2VuZXJhdG9ycywgLypcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAge2ludH0gKi8gbGluZW5vLCAvKiB7aW50fSAqLyBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGVsdCAhPT0gbnVsbCAmJiBlbHQgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLmVsdCA9IGVsdDtcblx0ICAgIHRoaXMuZ2VuZXJhdG9ycyA9IGdlbmVyYXRvcnM7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gWWllbGQoLyoge2V4cHJfdHl9ICovIHZhbHVlLCAvKiB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgY29sX29mZnNldClcblx0e1xuXHQgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENvbXBhcmUoLyoge2V4cHJfdHl9ICovIGxlZnQsIC8qIHthc2RsX2ludF9zZXEgKn0gKi8gb3BzLCAvKiB7YXNkbF9zZXFcblx0ICAgICAgICAgICAgICAgICAgICAgICp9ICovIGNvbXBhcmF0b3JzLCAvKiB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgICBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGxlZnQgIT09IG51bGwgJiYgbGVmdCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMubGVmdCA9IGxlZnQ7XG5cdCAgICB0aGlzLm9wcyA9IG9wcztcblx0ICAgIHRoaXMuY29tcGFyYXRvcnMgPSBjb21wYXJhdG9ycztcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBDYWxsKC8qIHtleHByX3R5fSAqLyBmdW5jLCAvKiB7YXNkbF9zZXEgKn0gKi8gYXJncywgLyoge2FzZGxfc2VxICp9ICovXG5cdCAgICAgICAgICAgICAgICAgICBrZXl3b3JkcywgLyoge2V4cHJfdHl9ICovIHN0YXJhcmdzLCAvKiB7ZXhwcl90eX0gKi8ga3dhcmdzLFxuXHQgICAgICAgICAgICAgICAgICAgLyoge2ludH0gKi8gbGluZW5vLCAvKiB7aW50fSAqLyBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGZ1bmMgIT09IG51bGwgJiYgZnVuYyAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG5cdCAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuXHQgICAgdGhpcy5rZXl3b3JkcyA9IGtleXdvcmRzO1xuXHQgICAgdGhpcy5zdGFyYXJncyA9IHN0YXJhcmdzO1xuXHQgICAgdGhpcy5rd2FyZ3MgPSBrd2FyZ3M7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gUmVwcigvKiB7ZXhwcl90eX0gKi8gdmFsdWUsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBOdW0oLyoge29iamVjdH0gKi8gbiwgLyoge2ludH0gKi8gbGluZW5vLCAvKiB7aW50fSAqLyBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KG4gIT09IG51bGwgJiYgbiAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMubiA9IG47XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gU3RyKC8qIHtzdHJpbmd9ICovIHMsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChzICE9PSBudWxsICYmIHMgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLnMgPSBzO1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEF0dHJpYnV0ZSgvKiB7ZXhwcl90eX0gKi8gdmFsdWUsIC8qIHtpZGVudGlmaWVyfSAqLyBhdHRyLCAvKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB7ZXhwcl9jb250ZXh0X3R5fSAqLyBjdHgsIC8qIHtpbnR9ICovIGxpbmVubywgLyoge2ludH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSB1bmRlZmluZWQpO1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChjdHggIT09IG51bGwgJiYgY3R4ICE9PSB1bmRlZmluZWQpO1xuXHQgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgdGhpcy5hdHRyID0gYXR0cjtcblx0ICAgIHRoaXMuY3R4ID0gY3R4O1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFN1YnNjcmlwdCgvKiB7ZXhwcl90eX0gKi8gdmFsdWUsIC8qIHtzbGljZV90eX0gKi8gc2xpY2UsIC8qXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHtleHByX2NvbnRleHRfdHl9ICovIGN0eCwgLyoge2ludH0gKi8gbGluZW5vLCAvKiB7aW50fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAqLyBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpO1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChzbGljZSAhPT0gbnVsbCAmJiBzbGljZSAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoY3R4ICE9PSBudWxsICYmIGN0eCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcblx0ICAgIHRoaXMuY3R4ID0gY3R4O1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIE5hbWUoLyoge2lkZW50aWZpZXJ9ICovIGlkLCAvKiB7ZXhwcl9jb250ZXh0X3R5fSAqLyBjdHgsIC8qIHtpbnR9ICovXG5cdCAgICAgICAgICAgICAgICAgICBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoaWQgIT09IG51bGwgJiYgaWQgIT09IHVuZGVmaW5lZCk7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGN0eCAhPT0gbnVsbCAmJiBjdHggIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLmlkID0gaWQ7XG5cdCAgICB0aGlzLmN0eCA9IGN0eDtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBMaXN0KC8qIHthc2RsX3NlcSAqfSAqLyBlbHRzLCAvKiB7ZXhwcl9jb250ZXh0X3R5fSAqLyBjdHgsIC8qIHtpbnR9ICovXG5cdCAgICAgICAgICAgICAgICAgICBsaW5lbm8sIC8qIHtpbnR9ICovIGNvbF9vZmZzZXQpXG5cdHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoY3R4ICE9PSBudWxsICYmIGN0eCAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMuZWx0cyA9IGVsdHM7XG5cdCAgICB0aGlzLmN0eCA9IGN0eDtcblx0ICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuXHQgICAgdGhpcy5jb2xfb2Zmc2V0ID0gY29sX29mZnNldDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBUdXBsZSgvKiB7YXNkbF9zZXEgKn0gKi8gZWx0cywgLyoge2V4cHJfY29udGV4dF90eX0gKi8gY3R4LCAvKiB7aW50fVxuXHQgICAgICAgICAgICAgICAgICAgICovIGxpbmVubywgLyoge2ludH0gKi8gY29sX29mZnNldClcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChjdHggIT09IG51bGwgJiYgY3R4ICE9PSB1bmRlZmluZWQpO1xuXHQgICAgdGhpcy5lbHRzID0gZWx0cztcblx0ICAgIHRoaXMuY3R4ID0gY3R4O1xuXHQgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG5cdCAgICB0aGlzLmNvbF9vZmZzZXQgPSBjb2xfb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEVsbGlwc2lzKClcblx0e1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFNsaWNlKC8qIHtleHByX3R5fSAqLyBsb3dlciwgLyoge2V4cHJfdHl9ICovIHVwcGVyLCAvKiB7ZXhwcl90eX0gKi9cblx0ICAgICAgICAgICAgICAgICAgICBzdGVwKVxuXHR7XG5cdCAgICB0aGlzLmxvd2VyID0gbG93ZXI7XG5cdCAgICB0aGlzLnVwcGVyID0gdXBwZXI7XG5cdCAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEV4dFNsaWNlKC8qIHthc2RsX3NlcSAqfSAqLyBkaW1zKVxuXHR7XG5cdCAgICB0aGlzLmRpbXMgPSBkaW1zO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEluZGV4KC8qIHtleHByX3R5fSAqLyB2YWx1ZSlcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBjb21wcmVoZW5zaW9uKC8qIHtleHByX3R5fSAqLyB0YXJnZXQsIC8qIHtleHByX3R5fSAqLyBpdGVyLCAvKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAge2FzZGxfc2VxICp9ICovIGlmcylcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSB1bmRlZmluZWQpO1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChpdGVyICE9PSBudWxsICYmIGl0ZXIgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0ICAgIHRoaXMuaXRlciA9IGl0ZXI7XG5cdCAgICB0aGlzLmlmcyA9IGlmcztcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBFeGNlcHRIYW5kbGVyKC8qIHtleHByX3R5fSAqLyB0eXBlLCAvKiB7ZXhwcl90eX0gKi8gbmFtZSwgLyoge2FzZGxfc2VxXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqfSAqLyBib2R5LCAvKiB7aW50fSAqLyBsaW5lbm8sIC8qIHtpbnR9ICovXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfb2Zmc2V0KVxuXHR7XG5cdCAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXHQgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcblx0ICAgIHRoaXMuY29sX29mZnNldCA9IGNvbF9vZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gYXJndW1lbnRzXygvKiB7YXNkbF9zZXEgKn0gKi8gYXJncywgLyoge2lkZW50aWZpZXJ9ICovIHZhcmFyZywgLypcblx0ICAgICAgICAgICAgICAgICAgICAgICAgIHtpZGVudGlmaWVyfSAqLyBrd2FyZywgLyoge2FzZGxfc2VxICp9ICovIGRlZmF1bHRzKVxuXHR7XG5cdCAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuXHQgICAgdGhpcy52YXJhcmcgPSB2YXJhcmc7XG5cdCAgICB0aGlzLmt3YXJnID0ga3dhcmc7XG5cdCAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKiBAY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24ga2V5d29yZCgvKiB7aWRlbnRpZmllcn0gKi8gYXJnLCAvKiB7ZXhwcl90eX0gKi8gdmFsdWUpXG5cdHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoYXJnICE9PSBudWxsICYmIGFyZyAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLmFyZyA9IGFyZztcblx0ICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBhbGlhcygvKiB7aWRlbnRpZmllcn0gKi8gbmFtZSwgLyoge2lkZW50aWZpZXJ9ICovIGFzbmFtZSlcblx0e1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHVuZGVmaW5lZCk7XG5cdCAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgdGhpcy5hc25hbWUgPSBhc25hbWU7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXG5cblx0TW9kdWxlLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiTW9kdWxlXCI7XG5cdE1vZHVsZS5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiYm9keVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmJvZHk7IH1cblx0XTtcblx0SW50ZXJhY3RpdmUucHJvdG90eXBlLl9hc3RuYW1lID0gXCJJbnRlcmFjdGl2ZVwiO1xuXHRJbnRlcmFjdGl2ZS5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiYm9keVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmJvZHk7IH1cblx0XTtcblx0RXhwcmVzc2lvbi5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkV4cHJlc3Npb25cIjtcblx0RXhwcmVzc2lvbi5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiYm9keVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmJvZHk7IH1cblx0XTtcblx0U3VpdGUucHJvdG90eXBlLl9hc3RuYW1lID0gXCJTdWl0ZVwiO1xuXHRTdWl0ZS5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiYm9keVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmJvZHk7IH1cblx0XTtcblx0RnVuY3Rpb25EZWYucHJvdG90eXBlLl9hc3RuYW1lID0gXCJGdW5jdGlvbkRlZlwiO1xuXHRGdW5jdGlvbkRlZi5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwibmFtZVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm5hbWU7IH0sXG5cdCAgICBcImFyZ3NcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5hcmdzOyB9LFxuXHQgICAgXCJib2R5XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uYm9keTsgfSxcblx0ICAgIFwiZGVjb3JhdG9yX2xpc3RcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5kZWNvcmF0b3JfbGlzdDsgfVxuXHRdO1xuXHRDbGFzc0RlZi5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkNsYXNzRGVmXCI7XG5cdENsYXNzRGVmLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJuYW1lXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubmFtZTsgfSxcblx0ICAgIFwiYmFzZXNcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5iYXNlczsgfSxcblx0ICAgIFwiYm9keVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmJvZHk7IH0sXG5cdCAgICBcImRlY29yYXRvcl9saXN0XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZGVjb3JhdG9yX2xpc3Q7IH1cblx0XTtcblx0UmV0dXJuXy5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIlJldHVyblwiO1xuXHRSZXR1cm5fLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJ2YWx1ZVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLnZhbHVlOyB9XG5cdF07XG5cdERlbGV0ZV8ucHJvdG90eXBlLl9hc3RuYW1lID0gXCJEZWxldGVcIjtcblx0RGVsZXRlXy5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwidGFyZ2V0c1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLnRhcmdldHM7IH1cblx0XTtcblx0QXNzaWduLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiQXNzaWduXCI7XG5cdEFzc2lnbi5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwidGFyZ2V0c1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLnRhcmdldHM7IH0sXG5cdCAgICBcInZhbHVlXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4udmFsdWU7IH1cblx0XTtcblx0QXVnQXNzaWduLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiQXVnQXNzaWduXCI7XG5cdEF1Z0Fzc2lnbi5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwidGFyZ2V0XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4udGFyZ2V0OyB9LFxuXHQgICAgXCJvcFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm9wOyB9LFxuXHQgICAgXCJ2YWx1ZVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLnZhbHVlOyB9XG5cdF07XG5cdFByaW50LnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiUHJpbnRcIjtcblx0UHJpbnQucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImRlc3RcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5kZXN0OyB9LFxuXHQgICAgXCJ2YWx1ZXNcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi52YWx1ZXM7IH0sXG5cdCAgICBcIm5sXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubmw7IH1cblx0XTtcblx0Rm9yXy5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkZvclwiO1xuXHRGb3JfLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJ0YXJnZXRcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi50YXJnZXQ7IH0sXG5cdCAgICBcIml0ZXJcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5pdGVyOyB9LFxuXHQgICAgXCJib2R5XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uYm9keTsgfSxcblx0ICAgIFwib3JlbHNlXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ub3JlbHNlOyB9XG5cdF07XG5cdFdoaWxlXy5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIldoaWxlXCI7XG5cdFdoaWxlXy5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwidGVzdFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLnRlc3Q7IH0sXG5cdCAgICBcImJvZHlcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5ib2R5OyB9LFxuXHQgICAgXCJvcmVsc2VcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5vcmVsc2U7IH1cblx0XTtcblx0SWZfLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiSWZcIjtcblx0SWZfLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJ0ZXN0XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4udGVzdDsgfSxcblx0ICAgIFwiYm9keVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmJvZHk7IH0sXG5cdCAgICBcIm9yZWxzZVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm9yZWxzZTsgfVxuXHRdO1xuXHRXaXRoXy5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIldpdGhcIjtcblx0V2l0aF8ucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImNvbnRleHRfZXhwclwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmNvbnRleHRfZXhwcjsgfSxcblx0ICAgIFwib3B0aW9uYWxfdmFyc1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm9wdGlvbmFsX3ZhcnM7IH0sXG5cdCAgICBcImJvZHlcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5ib2R5OyB9XG5cdF07XG5cdFJhaXNlLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiUmFpc2VcIjtcblx0UmFpc2UucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcInR5cGVcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi50eXBlOyB9LFxuXHQgICAgXCJpbnN0XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uaW5zdDsgfSxcblx0ICAgIFwidGJhY2tcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi50YmFjazsgfVxuXHRdO1xuXHRUcnlFeGNlcHQucHJvdG90eXBlLl9hc3RuYW1lID0gXCJUcnlFeGNlcHRcIjtcblx0VHJ5RXhjZXB0LnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJib2R5XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uYm9keTsgfSxcblx0ICAgIFwiaGFuZGxlcnNcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5oYW5kbGVyczsgfSxcblx0ICAgIFwib3JlbHNlXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ub3JlbHNlOyB9XG5cdF07XG5cdFRyeUZpbmFsbHkucHJvdG90eXBlLl9hc3RuYW1lID0gXCJUcnlGaW5hbGx5XCI7XG5cdFRyeUZpbmFsbHkucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImJvZHlcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5ib2R5OyB9LFxuXHQgICAgXCJmaW5hbGJvZHlcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5maW5hbGJvZHk7IH1cblx0XTtcblx0QXNzZXJ0LnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiQXNzZXJ0XCI7XG5cdEFzc2VydC5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwidGVzdFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLnRlc3Q7IH0sXG5cdCAgICBcIm1zZ1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm1zZzsgfVxuXHRdO1xuXHRJbXBvcnRfLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiSW1wb3J0XCI7XG5cdEltcG9ydF8ucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcIm5hbWVzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubmFtZXM7IH1cblx0XTtcblx0SW1wb3J0RnJvbS5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkltcG9ydEZyb21cIjtcblx0SW1wb3J0RnJvbS5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwibW9kdWxlXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubW9kdWxlOyB9LFxuXHQgICAgXCJuYW1lc1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm5hbWVzOyB9LFxuXHQgICAgXCJsZXZlbFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmxldmVsOyB9XG5cdF07XG5cdEV4ZWMucHJvdG90eXBlLl9hc3RuYW1lID0gXCJFeGVjXCI7XG5cdEV4ZWMucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImJvZHlcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5ib2R5OyB9LFxuXHQgICAgXCJnbG9iYWxzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZ2xvYmFsczsgfSxcblx0ICAgIFwibG9jYWxzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubG9jYWxzOyB9XG5cdF07XG5cdEdsb2JhbC5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkdsb2JhbFwiO1xuXHRHbG9iYWwucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcIm5hbWVzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubmFtZXM7IH1cblx0XTtcblx0RXhwci5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkV4cHJcIjtcblx0RXhwci5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwidmFsdWVcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi52YWx1ZTsgfVxuXHRdO1xuXHRQYXNzLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiUGFzc1wiO1xuXHRQYXNzLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHRdO1xuXHRCcmVha18ucHJvdG90eXBlLl9hc3RuYW1lID0gXCJCcmVha1wiO1xuXHRCcmVha18ucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdF07XG5cdENvbnRpbnVlXy5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkNvbnRpbnVlXCI7XG5cdENvbnRpbnVlXy5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0XTtcblx0RGVidWdnZXJfLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiRGVidWdnZXJcIjtcblx0RGVidWdnZXJfLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHRdO1xuXHRCb29sT3AucHJvdG90eXBlLl9hc3RuYW1lID0gXCJCb29sT3BcIjtcblx0Qm9vbE9wLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJvcFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm9wOyB9LFxuXHQgICAgXCJ2YWx1ZXNcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi52YWx1ZXM7IH1cblx0XTtcblx0QmluT3AucHJvdG90eXBlLl9hc3RuYW1lID0gXCJCaW5PcFwiO1xuXHRCaW5PcC5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwibGVmdFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmxlZnQ7IH0sXG5cdCAgICBcIm9wXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ub3A7IH0sXG5cdCAgICBcInJpZ2h0XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ucmlnaHQ7IH1cblx0XTtcblx0VW5hcnlPcC5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIlVuYXJ5T3BcIjtcblx0VW5hcnlPcC5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwib3BcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5vcDsgfSxcblx0ICAgIFwib3BlcmFuZFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm9wZXJhbmQ7IH1cblx0XTtcblx0TGFtYmRhLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiTGFtYmRhXCI7XG5cdExhbWJkYS5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiYXJnc1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmFyZ3M7IH0sXG5cdCAgICBcImJvZHlcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5ib2R5OyB9XG5cdF07XG5cdElmRXhwLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiSWZFeHBcIjtcblx0SWZFeHAucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcInRlc3RcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi50ZXN0OyB9LFxuXHQgICAgXCJib2R5XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uYm9keTsgfSxcblx0ICAgIFwib3JlbHNlXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ub3JlbHNlOyB9XG5cdF07XG5cdERpY3QucHJvdG90eXBlLl9hc3RuYW1lID0gXCJEaWN0XCI7XG5cdERpY3QucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImtleXNcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5rZXlzOyB9LFxuXHQgICAgXCJ2YWx1ZXNcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi52YWx1ZXM7IH1cblx0XTtcblx0U2V0LnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiU2V0XCI7XG5cdFNldC5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiZWx0c1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmVsdHM7IH1cblx0XTtcblx0TGlzdENvbXAucHJvdG90eXBlLl9hc3RuYW1lID0gXCJMaXN0Q29tcFwiO1xuXHRMaXN0Q29tcC5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiZWx0XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZWx0OyB9LFxuXHQgICAgXCJnZW5lcmF0b3JzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZ2VuZXJhdG9yczsgfVxuXHRdO1xuXHRTZXRDb21wLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiU2V0Q29tcFwiO1xuXHRTZXRDb21wLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJlbHRcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5lbHQ7IH0sXG5cdCAgICBcImdlbmVyYXRvcnNcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5nZW5lcmF0b3JzOyB9XG5cdF07XG5cdERpY3RDb21wLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiRGljdENvbXBcIjtcblx0RGljdENvbXAucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImtleVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmtleTsgfSxcblx0ICAgIFwidmFsdWVcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi52YWx1ZTsgfSxcblx0ICAgIFwiZ2VuZXJhdG9yc1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmdlbmVyYXRvcnM7IH1cblx0XTtcblx0R2VuZXJhdG9yRXhwLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiR2VuZXJhdG9yRXhwXCI7XG5cdEdlbmVyYXRvckV4cC5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiZWx0XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZWx0OyB9LFxuXHQgICAgXCJnZW5lcmF0b3JzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZ2VuZXJhdG9yczsgfVxuXHRdO1xuXHRZaWVsZC5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIllpZWxkXCI7XG5cdFlpZWxkLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJ2YWx1ZVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLnZhbHVlOyB9XG5cdF07XG5cdENvbXBhcmUucHJvdG90eXBlLl9hc3RuYW1lID0gXCJDb21wYXJlXCI7XG5cdENvbXBhcmUucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImxlZnRcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5sZWZ0OyB9LFxuXHQgICAgXCJvcHNcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5vcHM7IH0sXG5cdCAgICBcImNvbXBhcmF0b3JzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uY29tcGFyYXRvcnM7IH1cblx0XTtcblx0Q2FsbC5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkNhbGxcIjtcblx0Q2FsbC5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiZnVuY1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmZ1bmM7IH0sXG5cdCAgICBcImFyZ3NcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5hcmdzOyB9LFxuXHQgICAgXCJrZXl3b3Jkc1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmtleXdvcmRzOyB9LFxuXHQgICAgXCJzdGFyYXJnc1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLnN0YXJhcmdzOyB9LFxuXHQgICAgXCJrd2FyZ3NcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5rd2FyZ3M7IH1cblx0XTtcblx0UmVwci5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIlJlcHJcIjtcblx0UmVwci5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwidmFsdWVcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi52YWx1ZTsgfVxuXHRdO1xuXHROdW0ucHJvdG90eXBlLl9hc3RuYW1lID0gXCJOdW1cIjtcblx0TnVtLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJuXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubjsgfVxuXHRdO1xuXHRTdHIucHJvdG90eXBlLl9hc3RuYW1lID0gXCJTdHJcIjtcblx0U3RyLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uczsgfVxuXHRdO1xuXHRBdHRyaWJ1dGUucHJvdG90eXBlLl9hc3RuYW1lID0gXCJBdHRyaWJ1dGVcIjtcblx0QXR0cmlidXRlLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJ2YWx1ZVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLnZhbHVlOyB9LFxuXHQgICAgXCJhdHRyXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uYXR0cjsgfSxcblx0ICAgIFwiY3R4XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uY3R4OyB9XG5cdF07XG5cdFN1YnNjcmlwdC5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIlN1YnNjcmlwdFwiO1xuXHRTdWJzY3JpcHQucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcInZhbHVlXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4udmFsdWU7IH0sXG5cdCAgICBcInNsaWNlXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uc2xpY2U7IH0sXG5cdCAgICBcImN0eFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmN0eDsgfVxuXHRdO1xuXHROYW1lLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiTmFtZVwiO1xuXHROYW1lLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJpZFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmlkOyB9LFxuXHQgICAgXCJjdHhcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5jdHg7IH1cblx0XTtcblx0TGlzdC5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkxpc3RcIjtcblx0TGlzdC5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwiZWx0c1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmVsdHM7IH0sXG5cdCAgICBcImN0eFwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmN0eDsgfVxuXHRdO1xuXHRUdXBsZS5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIlR1cGxlXCI7XG5cdFR1cGxlLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJlbHRzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZWx0czsgfSxcblx0ICAgIFwiY3R4XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uY3R4OyB9XG5cdF07XG5cdExvYWQucHJvdG90eXBlLl9hc3RuYW1lID0gXCJMb2FkXCI7XG5cdExvYWQucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRTdG9yZS5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIlN0b3JlXCI7XG5cdFN0b3JlLnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0RGVsLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiRGVsXCI7XG5cdERlbC5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdEF1Z0xvYWQucHJvdG90eXBlLl9hc3RuYW1lID0gXCJBdWdMb2FkXCI7XG5cdEF1Z0xvYWQucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRBdWdTdG9yZS5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkF1Z1N0b3JlXCI7XG5cdEF1Z1N0b3JlLnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0UGFyYW0ucHJvdG90eXBlLl9hc3RuYW1lID0gXCJQYXJhbVwiO1xuXHRQYXJhbS5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdEVsbGlwc2lzLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiRWxsaXBzaXNcIjtcblx0RWxsaXBzaXMucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdF07XG5cdFNsaWNlLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiU2xpY2VcIjtcblx0U2xpY2UucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImxvd2VyXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubG93ZXI7IH0sXG5cdCAgICBcInVwcGVyXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4udXBwZXI7IH0sXG5cdCAgICBcInN0ZXBcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5zdGVwOyB9XG5cdF07XG5cdEV4dFNsaWNlLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiRXh0U2xpY2VcIjtcblx0RXh0U2xpY2UucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImRpbXNcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi5kaW1zOyB9XG5cdF07XG5cdEluZGV4LnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiSW5kZXhcIjtcblx0SW5kZXgucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcInZhbHVlXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4udmFsdWU7IH1cblx0XTtcblx0QW5kLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiQW5kXCI7XG5cdEFuZC5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdE9yLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiT3JcIjtcblx0T3IucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRBZGQucHJvdG90eXBlLl9hc3RuYW1lID0gXCJBZGRcIjtcblx0QWRkLnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0U3ViLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiU3ViXCI7XG5cdFN1Yi5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdE11bHQucHJvdG90eXBlLl9hc3RuYW1lID0gXCJNdWx0XCI7XG5cdE11bHQucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHREaXYucHJvdG90eXBlLl9hc3RuYW1lID0gXCJEaXZcIjtcblx0RGl2LnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0TW9kLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiTW9kXCI7XG5cdE1vZC5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdFBvdy5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIlBvd1wiO1xuXHRQb3cucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRMU2hpZnQucHJvdG90eXBlLl9hc3RuYW1lID0gXCJMU2hpZnRcIjtcblx0TFNoaWZ0LnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0UlNoaWZ0LnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiUlNoaWZ0XCI7XG5cdFJTaGlmdC5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdEJpdE9yLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiQml0T3JcIjtcblx0Qml0T3IucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRCaXRYb3IucHJvdG90eXBlLl9hc3RuYW1lID0gXCJCaXRYb3JcIjtcblx0Qml0WG9yLnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0Qml0QW5kLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiQml0QW5kXCI7XG5cdEJpdEFuZC5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdEZsb29yRGl2LnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiRmxvb3JEaXZcIjtcblx0Rmxvb3JEaXYucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRJbnZlcnQucHJvdG90eXBlLl9hc3RuYW1lID0gXCJJbnZlcnRcIjtcblx0SW52ZXJ0LnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0Tm90LnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiTm90XCI7XG5cdE5vdC5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdFVBZGQucHJvdG90eXBlLl9hc3RuYW1lID0gXCJVQWRkXCI7XG5cdFVBZGQucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRVU3ViLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiVVN1YlwiO1xuXHRVU3ViLnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0RXEucHJvdG90eXBlLl9hc3RuYW1lID0gXCJFcVwiO1xuXHRFcS5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdE5vdEVxLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiTm90RXFcIjtcblx0Tm90RXEucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRMdC5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIkx0XCI7XG5cdEx0LnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0THRFLnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiTHRFXCI7XG5cdEx0RS5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdEd0LnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiR3RcIjtcblx0R3QucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRHdEUucHJvdG90eXBlLl9hc3RuYW1lID0gXCJHdEVcIjtcblx0R3RFLnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0SXMucHJvdG90eXBlLl9hc3RuYW1lID0gXCJJc1wiO1xuXHRJcy5wcm90b3R5cGUuX2lzZW51bSA9IHRydWU7XG5cdElzTm90LnByb3RvdHlwZS5fYXN0bmFtZSA9IFwiSXNOb3RcIjtcblx0SXNOb3QucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHRJbl8ucHJvdG90eXBlLl9hc3RuYW1lID0gXCJJblwiO1xuXHRJbl8ucHJvdG90eXBlLl9pc2VudW0gPSB0cnVlO1xuXHROb3RJbi5wcm90b3R5cGUuX2FzdG5hbWUgPSBcIk5vdEluXCI7XG5cdE5vdEluLnByb3RvdHlwZS5faXNlbnVtID0gdHJ1ZTtcblx0Y29tcHJlaGVuc2lvbi5wcm90b3R5cGUuX2FzdG5hbWUgPSBcImNvbXByZWhlbnNpb25cIjtcblx0Y29tcHJlaGVuc2lvbi5wcm90b3R5cGUuX2ZpZWxkcyA9IFtcblx0ICAgIFwidGFyZ2V0XCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4udGFyZ2V0OyB9LFxuXHQgICAgXCJpdGVyXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uaXRlcjsgfSxcblx0ICAgIFwiaWZzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uaWZzOyB9XG5cdF07XG5cdEV4Y2VwdEhhbmRsZXIucHJvdG90eXBlLl9hc3RuYW1lID0gXCJFeGNlcHRIYW5kbGVyXCI7XG5cdEV4Y2VwdEhhbmRsZXIucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcInR5cGVcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi50eXBlOyB9LFxuXHQgICAgXCJuYW1lXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubmFtZTsgfSxcblx0ICAgIFwiYm9keVwiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmJvZHk7IH1cblx0XTtcblx0YXJndW1lbnRzXy5wcm90b3R5cGUuX2FzdG5hbWUgPSBcImFyZ3VtZW50c1wiO1xuXHRhcmd1bWVudHNfLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJhcmdzXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uYXJnczsgfSxcblx0ICAgIFwidmFyYXJnXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4udmFyYXJnOyB9LFxuXHQgICAgXCJrd2FyZ1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmt3YXJnOyB9LFxuXHQgICAgXCJkZWZhdWx0c1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmRlZmF1bHRzOyB9XG5cdF07XG5cdGtleXdvcmQucHJvdG90eXBlLl9hc3RuYW1lID0gXCJrZXl3b3JkXCI7XG5cdGtleXdvcmQucHJvdG90eXBlLl9maWVsZHMgPSBbXG5cdCAgICBcImFyZ1wiLCBmdW5jdGlvbihuKSB7IHJldHVybiBuLmFyZzsgfSxcblx0ICAgIFwidmFsdWVcIiwgZnVuY3Rpb24obikgeyByZXR1cm4gbi52YWx1ZTsgfVxuXHRdO1xuXHRhbGlhcy5wcm90b3R5cGUuX2FzdG5hbWUgPSBcImFsaWFzXCI7XG5cdGFsaWFzLnByb3RvdHlwZS5fZmllbGRzID0gW1xuXHQgICAgXCJuYW1lXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4ubmFtZTsgfSxcblx0ICAgIFwiYXNuYW1lXCIsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uYXNuYW1lOyB9XG5cdF07XG5cblxuXG5cblx0LyogLS0tLSAvVXNlcnMvcm9iL3NrdWxwdHkvbGliLy4uL25vZGVfbW9kdWxlcy9za3VscHQvc3JjL2FzdC5qcyAtLS0tICovIFxuXG5cdC8vXG5cdC8vIFRoaXMgaXMgcHJldHR5IG11Y2ggYSBzdHJhaWdodCBwb3J0IG9mIGFzdC5jIGZyb20gQ1B5dGhvbiAyLjYuNS5cblx0Ly9cblx0Ly8gVGhlIHByZXZpb3VzIHZlcnNpb24gd2FzIGVhc2llciB0byB3b3JrIHdpdGggYW5kIG1vcmUgSlMtaXNoLCBidXQgaGF2aW5nIGFcblx0Ly8gc29tZXdoYXQgZGlmZmVyZW50IGFzdCBzdHJ1Y3R1cmUgdGhhbiBjcHl0aG9uIG1ha2VzIHRlc3RpbmcgbW9yZSBkaWZmaWN1bHQuXG5cdC8vXG5cdC8vIFRoaXMgd2F5LCB3ZSBjYW4gdXNlIGEgZHVtcCBmcm9tIHRoZSBhc3QgbW9kdWxlIG9uIGFueSBhcmJpdHJhcnkgcHl0aG9uXG5cdC8vIGNvZGUgYW5kIGtub3cgdGhhdCB3ZSdyZSB0aGUgc2FtZSB1cCB0byBhc3QgbGV2ZWwsIGF0IGxlYXN0LlxuXHQvL1xuXG5cdHZhciBTWU0gPSBTay5QYXJzZVRhYmxlcy5zeW07XG5cdHZhciBUT0sgPSBTay5Ub2tlbml6ZXIuVG9rZW5zO1xuXHR2YXIgQ09NUF9HRU5FWFAgPSAwO1xuXHR2YXIgQ09NUF9TRVRDT01QID0gMTtcblxuXHQvKiogQGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENvbXBpbGluZyAoZW5jb2RpbmcsIGZpbGVuYW1lLCBjX2ZsYWdzKSB7XG5cdCAgICB0aGlzLmNfZW5jb2RpbmcgPSBlbmNvZGluZztcblx0ICAgIHRoaXMuY19maWxlbmFtZSA9IGZpbGVuYW1lO1xuXHQgICAgdGhpcy5jX2ZsYWdzID0gY19mbGFncyB8fCAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIE5DSCAobikge1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChuICE9PSB1bmRlZmluZWQpO1xuXHQgICAgaWYgKG4uY2hpbGRyZW4gPT09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuLmNoaWxkcmVuLmxlbmd0aDtcblx0fVxuXG5cdGZ1bmN0aW9uIENISUxEIChuLCBpKSB7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KG4gIT09IHVuZGVmaW5lZCk7XG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGkgIT09IHVuZGVmaW5lZCk7XG5cdCAgICByZXR1cm4gbi5jaGlsZHJlbltpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIFJFUSAobiwgdHlwZSkge1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChuLnR5cGUgPT09IHR5cGUsIFwibm9kZSB3YXNuJ3QgZXhwZWN0ZWQgdHlwZVwiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0cm9iaiAocykge1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiwgXCJleHBlY3Rpbmcgc3RyaW5nLCBnb3QgXCIgKyAodHlwZW9mIHMpKTtcblx0ICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIocyk7XG5cdH1cblxuXHQvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuXHRmdW5jdGlvbiBudW1TdG10cyAobikge1xuXHQgICAgdmFyIGNoO1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgY250O1xuXHQgICAgc3dpdGNoIChuLnR5cGUpIHtcblx0ICAgICAgICBjYXNlIFNZTS5zaW5nbGVfaW5wdXQ6XG5cdCAgICAgICAgICAgIGlmIChDSElMRChuLCAwKS50eXBlID09PSBUT0suVF9ORVdMSU5FKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudW1TdG10cyhDSElMRChuLCAwKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICBjYXNlIFNZTS5maWxlX2lucHV0OlxuXHQgICAgICAgICAgICBjbnQgPSAwO1xuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTkNIKG4pOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgIGNoID0gQ0hJTEQobiwgaSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2gudHlwZSA9PT0gU1lNLnN0bXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjbnQgKz0gbnVtU3RtdHMoY2gpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBjbnQ7XG5cdCAgICAgICAgY2FzZSBTWU0uc3RtdDpcblx0ICAgICAgICAgICAgcmV0dXJuIG51bVN0bXRzKENISUxEKG4sIDApKTtcblx0ICAgICAgICBjYXNlIFNZTS5jb21wb3VuZF9zdG10OlxuXHQgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICBjYXNlIFNZTS5zaW1wbGVfc3RtdDpcblx0ICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTkNIKG4pIC8gMik7IC8vIGRpdiAyIGlzIHRvIHJlbW92ZSBjb3VudCBvZiA7c1xuXHQgICAgICAgIGNhc2UgU1lNLnN1aXRlOlxuXHQgICAgICAgICAgICBpZiAoTkNIKG4pID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVtU3RtdHMoQ0hJTEQobiwgMCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgY250ID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDI7IGkgPCBOQ0gobikgLSAxOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjbnQgKz0gbnVtU3RtdHMoQ0hJTEQobiwgaSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICBnb29nLmFzc2VydHMuZmFpbChcIk5vbi1zdGF0ZW1lbnQgZm91bmRcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gMDtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcmJpZGRlbkNoZWNrIChjLCBuLCB4LCBsaW5lbm8pIHtcblx0ICAgIGlmICh4ID09PSBcIk5vbmVcIikge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYXNzaWdubWVudCB0byBOb25lXCIsIGMuY19maWxlbmFtZSwgbGluZW5vLCBbXSwge25vZGU6IG59KTtcblx0ICAgIH1cblx0ICAgIGlmICh4ID09PSBcIlRydWVcIiB8fCB4ID09PSBcIkZhbHNlXCIpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImFzc2lnbm1lbnQgdG8gVHJ1ZSBvciBGYWxzZSBpcyBmb3JiaWRkZW5cIiwgYy5jX2ZpbGVuYW1lLCBsaW5lbm8sIFtdLCB7bm9kZTogbn0pO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY29udGV4dCBjdHggZm9yIGUsIHJlY3Vyc2l2ZWx5IHRyYXZlcnNpbmcgZS5cblx0ICpcblx0ICogT25seSBzZXRzIGNvbnRleHQgZm9yIGV4cHIga2luZHMgdGhhdCBjYW4gYXBwZWFyIGluIGFzc2lnbm1lbnQgY29udGV4dCBhc1xuXHQgKiBwZXIgdGhlIGFzZGwgZmlsZS5cblx0ICovXG5cdGZ1bmN0aW9uIHNldENvbnRleHQgKGMsIGUsIGN0eCwgbikge1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgZXhwck5hbWU7XG5cdCAgICB2YXIgcztcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoY3R4ICE9PSBBdWdTdG9yZSAmJiBjdHggIT09IEF1Z0xvYWQpO1xuXHQgICAgcyA9IG51bGw7XG5cdCAgICBleHByTmFtZSA9IG51bGw7XG5cblx0ICAgIHN3aXRjaCAoZS5jb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgIGNhc2UgQXR0cmlidXRlOlxuXHQgICAgICAgIGNhc2UgTmFtZTpcblx0ICAgICAgICAgICAgaWYgKGN0eCA9PT0gU3RvcmUpIHtcblx0ICAgICAgICAgICAgICAgIGZvcmJpZGRlbkNoZWNrKGMsIG4sIGUuYXR0ciwgbi5saW5lbm8pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGUuY3R4ID0gY3R4O1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIFN1YnNjcmlwdDpcblx0ICAgICAgICAgICAgZS5jdHggPSBjdHg7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgTGlzdDpcblx0ICAgICAgICAgICAgZS5jdHggPSBjdHg7XG5cdCAgICAgICAgICAgIHMgPSBlLmVsdHM7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgVHVwbGU6XG5cdCAgICAgICAgICAgIGlmIChlLmVsdHMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImNhbid0IGFzc2lnbiB0byAoKVwiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vLCBjdHgsIHtub2RlOiBufSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZS5jdHggPSBjdHg7XG5cdCAgICAgICAgICAgIHMgPSBlLmVsdHM7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgTGFtYmRhOlxuXHQgICAgICAgICAgICBleHByTmFtZSA9IFwibGFtYmRhXCI7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgQ2FsbDpcblx0ICAgICAgICAgICAgZXhwck5hbWUgPSBcImZ1bmN0aW9uIGNhbGxcIjtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBCb29sT3A6XG5cdCAgICAgICAgY2FzZSBCaW5PcDpcblx0ICAgICAgICBjYXNlIFVuYXJ5T3A6XG5cdCAgICAgICAgICAgIGV4cHJOYW1lID0gXCJvcGVyYXRvclwiO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIEdlbmVyYXRvckV4cDpcblx0ICAgICAgICAgICAgZXhwck5hbWUgPSBcImdlbmVyYXRvciBleHByZXNzaW9uXCI7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgWWllbGQ6XG5cdCAgICAgICAgICAgIGV4cHJOYW1lID0gXCJ5aWVsZCBleHByZXNzaW9uXCI7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgTGlzdENvbXA6XG5cdCAgICAgICAgICAgIGV4cHJOYW1lID0gXCJsaXN0IGNvbXByZWhlbnNpb25cIjtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBTZXRDb21wOlxuXHQgICAgICAgICAgICBleHByTmFtZSA9IFwic2V0IGNvbXByZWhlbnNpb25cIjtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBEaWN0Q29tcDpcblx0ICAgICAgICAgICAgZXhwck5hbWUgPSBcImRpY3QgY29tcHJlaGVuc2lvblwiO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIERpY3Q6XG5cdCAgICAgICAgY2FzZSBTZXQ6XG5cdCAgICAgICAgY2FzZSBOdW06XG5cdCAgICAgICAgY2FzZSBTdHI6XG5cdCAgICAgICAgICAgIGV4cHJOYW1lID0gXCJsaXRlcmFsXCI7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgQ29tcGFyZTpcblx0ICAgICAgICAgICAgZXhwck5hbWUgPSBcImNvbXBhcmlzb25cIjtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBSZXByOlxuXHQgICAgICAgICAgICBleHByTmFtZSA9IFwicmVwclwiO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIElmRXhwOlxuXHQgICAgICAgICAgICBleHByTmFtZSA9IFwiY29uZGl0aW9uYWwgZXhwcmVzc2lvblwiO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICBnb29nLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBleHByZXNzaW9uIGluIGFzc2lnbm1lbnRcIik7XG5cdCAgICB9XG5cdCAgICBpZiAoZXhwck5hbWUpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImNhbid0IFwiICsgKGN0eCA9PT0gU3RvcmUgPyBcImFzc2lnbiB0b1wiIDogXCJkZWxldGVcIikgKyBcIiBcIiArIGV4cHJOYW1lLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vLCBbXSwge25vZGU6IG59KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHMpIHtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICBzZXRDb250ZXh0KGMsIHNbaV0sIGN0eCwgbik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0dmFyIG9wZXJhdG9yTWFwID0ge307XG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICBvcGVyYXRvck1hcFtUT0suVF9WQkFSXSA9IEJpdE9yO1xuXHQgICAgb3BlcmF0b3JNYXBbVE9LLlRfQ0lSQ1VNRkxFWF0gPSBCaXRYb3I7XG5cdCAgICBvcGVyYXRvck1hcFtUT0suVF9BTVBFUl0gPSBCaXRBbmQ7XG5cdCAgICBvcGVyYXRvck1hcFtUT0suVF9MRUZUU0hJRlRdID0gTFNoaWZ0O1xuXHQgICAgb3BlcmF0b3JNYXBbVE9LLlRfUklHSFRTSElGVF0gPSBSU2hpZnQ7XG5cdCAgICBvcGVyYXRvck1hcFtUT0suVF9QTFVTXSA9IEFkZDtcblx0ICAgIG9wZXJhdG9yTWFwW1RPSy5UX01JTlVTXSA9IFN1Yjtcblx0ICAgIG9wZXJhdG9yTWFwW1RPSy5UX1NUQVJdID0gTXVsdDtcblx0ICAgIG9wZXJhdG9yTWFwW1RPSy5UX1NMQVNIXSA9IERpdjtcblx0ICAgIG9wZXJhdG9yTWFwW1RPSy5UX0RPVUJMRVNMQVNIXSA9IEZsb29yRGl2O1xuXHQgICAgb3BlcmF0b3JNYXBbVE9LLlRfUEVSQ0VOVF0gPSBNb2Q7XG5cdH0oKSk7XG5cblx0ZnVuY3Rpb24gZ2V0T3BlcmF0b3IgKG4pIHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQob3BlcmF0b3JNYXBbbi50eXBlXSAhPT0gdW5kZWZpbmVkKTtcblx0ICAgIHJldHVybiBvcGVyYXRvck1hcFtuLnR5cGVdO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yQ29tcE9wIChjLCBuKSB7XG5cdCAgICAvKiBjb21wX29wOiAnPCd8Jz4nfCc9PSd8Jz49J3wnPD0nfCc8Pid8JyE9J3wnaW4nfCdub3QnICdpbid8J2lzJ1xuXHQgICAgIHwnaXMnICdub3QnXG5cdCAgICAgKi9cblx0ICAgIFJFUShuLCBTWU0uY29tcF9vcCk7XG5cdCAgICBpZiAoTkNIKG4pID09PSAxKSB7XG5cdCAgICAgICAgbiA9IENISUxEKG4sIDApO1xuXHQgICAgICAgIHN3aXRjaCAobi50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgVE9LLlRfTEVTUzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBMdDtcblx0ICAgICAgICAgICAgY2FzZSBUT0suVF9HUkVBVEVSOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEd0O1xuXHQgICAgICAgICAgICBjYXNlIFRPSy5UX0VRRVFVQUw6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRXE7XG5cdCAgICAgICAgICAgIGNhc2UgVE9LLlRfTEVTU0VRVUFMOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEx0RTtcblx0ICAgICAgICAgICAgY2FzZSBUT0suVF9HUkVBVEVSRVFVQUw6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gR3RFO1xuXHQgICAgICAgICAgICBjYXNlIFRPSy5UX05PVEVRVUFMOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE5vdEVxO1xuXHQgICAgICAgICAgICBjYXNlIFRPSy5UX05BTUU6XG5cdCAgICAgICAgICAgICAgICBpZiAobi52YWx1ZSA9PT0gXCJpblwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEluXztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChuLnZhbHVlID09PSBcImlzXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gSXM7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoTkNIKG4pID09PSAyKSB7XG5cdCAgICAgICAgaWYgKENISUxEKG4sIDApLnR5cGUgPT09IFRPSy5UX05BTUUpIHtcblx0ICAgICAgICAgICAgaWYgKENISUxEKG4sIDEpLnZhbHVlID09PSBcImluXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBOb3RJbjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoQ0hJTEQobiwgMCkudmFsdWUgPT09IFwiaXNcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIElzTm90O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZ29vZy5hc3NlcnRzLmZhaWwoXCJpbnZhbGlkIGNvbXBfb3BcIik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXFGb3JUZXN0bGlzdCAoYywgbikge1xuXHQgICAgLyogdGVzdGxpc3Q6IHRlc3QgKCcsJyB0ZXN0KSogWycsJ10gKi9cblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIHNlcSA9IFtdO1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChuLnR5cGUgPT09IFNZTS50ZXN0bGlzdCB8fFxuXHQgICAgICAgIG4udHlwZSA9PT0gU1lNLmxpc3RtYWtlciB8fFxuXHQgICAgICAgIG4udHlwZSA9PT0gU1lNLnRlc3RsaXN0X2NvbXAgfHxcblx0ICAgICAgICBuLnR5cGUgPT09IFNZTS50ZXN0bGlzdF9zYWZlIHx8XG5cdCAgICAgICAgbi50eXBlID09PSBTWU0udGVzdGxpc3QxKTtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBOQ0gobik7IGkgKz0gMikge1xuXHQgICAgICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoQ0hJTEQobiwgaSkudHlwZSA9PT0gU1lNLnRlc3QgfHwgQ0hJTEQobiwgaSkudHlwZSA9PT0gU1lNLm9sZF90ZXN0KTtcblx0ICAgICAgICBzZXFbaSAvIDJdID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCBpKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc2VxO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yU3VpdGUgKGMsIG4pIHtcblx0ICAgIC8qIHN1aXRlOiBzaW1wbGVfc3RtdCB8IE5FV0xJTkUgSU5ERU5UIHN0bXQrIERFREVOVCAqL1xuXHQgICAgdmFyIGo7XG5cdCAgICB2YXIgbnVtO1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgZW5kO1xuXHQgICAgdmFyIGNoO1xuXHQgICAgdmFyIHBvcztcblx0ICAgIHZhciBzZXE7XG5cdCAgICBSRVEobiwgU1lNLnN1aXRlKTtcblx0ICAgIHNlcSA9IFtdO1xuXHQgICAgcG9zID0gMDtcblx0ICAgIGlmIChDSElMRChuLCAwKS50eXBlID09PSBTWU0uc2ltcGxlX3N0bXQpIHtcblx0ICAgICAgICBuID0gQ0hJTEQobiwgMCk7XG5cdCAgICAgICAgLyogc2ltcGxlX3N0bXQgYWx3YXlzIGVuZHMgd2l0aCBhbiBORVdMSU5FIGFuZCBtYXkgaGF2ZSBhIHRyYWlsaW5nXG5cdCAgICAgICAgICogU0VNSS4gKi9cblx0ICAgICAgICBlbmQgPSBOQ0gobikgLSAxO1xuXHQgICAgICAgIGlmIChDSElMRChuLCBlbmQgLSAxKS50eXBlID09PSBUT0suVF9TRU1JKSB7XG5cdCAgICAgICAgICAgIGVuZCAtPSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5kOyBpICs9IDIpIC8vIGJ5IDIgdG8gc2tpcCA7XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICBzZXFbcG9zKytdID0gYXN0Rm9yU3RtdChjLCBDSElMRChuLCBpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgZm9yIChpID0gMjsgaSA8IE5DSChuKSAtIDE7ICsraSkge1xuXHQgICAgICAgICAgICBjaCA9IENISUxEKG4sIGkpO1xuXHQgICAgICAgICAgICBSRVEoY2gsIFNZTS5zdG10KTtcblx0ICAgICAgICAgICAgbnVtID0gbnVtU3RtdHMoY2gpO1xuXHQgICAgICAgICAgICBpZiAobnVtID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBzbWFsbF9zdG10IG9yIGNvbXBvdW5kX3N0bXQgdy8gb25seSAxIGNoaWxkXG5cdCAgICAgICAgICAgICAgICBzZXFbcG9zKytdID0gYXN0Rm9yU3RtdChjLCBjaCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjaCA9IENISUxEKGNoLCAwKTtcblx0ICAgICAgICAgICAgICAgIFJFUShjaCwgU1lNLnNpbXBsZV9zdG10KTtcblx0ICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBOQ0goY2gpOyBqICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoTkNIKENISUxEKGNoLCBqKSkgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ29vZy5hc3NlcnRzLmFzc2VydChqICsgMSA9PT0gTkNIKGNoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBzZXFbcG9zKytdID0gYXN0Rm9yU3RtdChjLCBDSElMRChjaCwgaikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChwb3MgPT09IG51bVN0bXRzKG4pKTtcblx0ICAgIHJldHVybiBzZXE7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JFeGNlcHRDbGF1c2UgKGMsIGV4YywgYm9keSkge1xuXHQgICAgLyogZXhjZXB0X2NsYXVzZTogJ2V4Y2VwdCcgW3Rlc3QgWygnLCcgfCAnYXMnKSB0ZXN0XV0gKi9cblx0ICAgIHZhciBlO1xuXHQgICAgUkVRKGV4YywgU1lNLmV4Y2VwdF9jbGF1c2UpO1xuXHQgICAgUkVRKGJvZHksIFNZTS5zdWl0ZSk7XG5cdCAgICBpZiAoTkNIKGV4YykgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IEV4Y2VwdEhhbmRsZXIobnVsbCwgbnVsbCwgYXN0Rm9yU3VpdGUoYywgYm9keSksIGV4Yy5saW5lbm8sIGV4Yy5jb2xfb2Zmc2V0KTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKE5DSChleGMpID09PSAyKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBFeGNlcHRIYW5kbGVyKGFzdEZvckV4cHIoYywgQ0hJTEQoZXhjLCAxKSksIG51bGwsIGFzdEZvclN1aXRlKGMsIGJvZHkpLCBleGMubGluZW5vLCBleGMuY29sX29mZnNldCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChOQ0goZXhjKSA9PT0gNCkge1xuXHQgICAgICAgIGUgPSBhc3RGb3JFeHByKGMsIENISUxEKGV4YywgMykpO1xuXHQgICAgICAgIHNldENvbnRleHQoYywgZSwgU3RvcmUsIENISUxEKGV4YywgMykpO1xuXHQgICAgICAgIHJldHVybiBuZXcgRXhjZXB0SGFuZGxlcihhc3RGb3JFeHByKGMsIENISUxEKGV4YywgMSkpLCBlLCBhc3RGb3JTdWl0ZShjLCBib2R5KSwgZXhjLmxpbmVubywgZXhjLmNvbF9vZmZzZXQpO1xuXHQgICAgfVxuXHQgICAgZ29vZy5hc3NlcnRzLmZhaWwoXCJ3cm9uZyBudW1iZXIgb2YgY2hpbGRyZW4gZm9yIGV4Y2VwdCBjbGF1c2VcIik7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JUcnlTdG10IChjLCBuKSB7XG5cdCAgICB2YXIgZXhjZXB0U3Q7XG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciBoYW5kbGVycztcblx0ICAgIHZhciBuYyA9IE5DSChuKTtcblx0ICAgIHZhciBuZXhjZXB0ID0gKG5jIC0gMykgLyAzO1xuXHQgICAgdmFyIGJvZHksIG9yZWxzZSA9IFtdLFxuXHQgICAgICAgIGZpbmFsbHlfID0gbnVsbDtcblxuXHQgICAgUkVRKG4sIFNZTS50cnlfc3RtdCk7XG5cdCAgICBib2R5ID0gYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgMikpO1xuXHQgICAgaWYgKENISUxEKG4sIG5jIC0gMykudHlwZSA9PT0gVE9LLlRfTkFNRSkge1xuXHQgICAgICAgIGlmIChDSElMRChuLCBuYyAtIDMpLnZhbHVlID09PSBcImZpbmFsbHlcIikge1xuXHQgICAgICAgICAgICBpZiAobmMgPj0gOSAmJiBDSElMRChuLCBuYyAtIDYpLnR5cGUgPT09IFRPSy5UX05BTUUpIHtcblx0ICAgICAgICAgICAgICAgIC8qIHdlIGNhbiBhc3N1bWUgaXQncyBhbiBcImVsc2VcIixcblx0ICAgICAgICAgICAgICAgICBiZWNhdXNlIG5jID49IDkgZm9yIHRyeS1lbHNlLWZpbmFsbHkgYW5kXG5cdCAgICAgICAgICAgICAgICAgaXQgd291bGQgb3RoZXJ3aXNlIGhhdmUgYSB0eXBlIG9mIGV4Y2VwdF9jbGF1c2UgKi9cblx0ICAgICAgICAgICAgICAgIG9yZWxzZSA9IGFzdEZvclN1aXRlKGMsIENISUxEKG4sIG5jIC0gNCkpO1xuXHQgICAgICAgICAgICAgICAgbmV4Y2VwdC0tO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZmluYWxseV8gPSBhc3RGb3JTdWl0ZShjLCBDSElMRChuLCBuYyAtIDEpKTtcblx0ICAgICAgICAgICAgbmV4Y2VwdC0tO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgLyogd2UgY2FuIGFzc3VtZSBpdCdzIGFuIFwiZWxzZVwiLFxuXHQgICAgICAgICAgICAgb3RoZXJ3aXNlIGl0IHdvdWxkIGhhdmUgYSB0eXBlIG9mIGV4Y2VwdF9jbGF1c2UgKi9cblx0ICAgICAgICAgICAgb3JlbHNlID0gYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgbmMgLSAxKSk7XG5cdCAgICAgICAgICAgIG5leGNlcHQtLTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChDSElMRChuLCBuYyAtIDMpLnR5cGUgIT09IFNZTS5leGNlcHRfY2xhdXNlKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJtYWxmb3JtZWQgJ3RyeScgc3RhdGVtZW50XCIsIGMuY19maWxlbmFtZSwgbi5saW5lbm8pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobmV4Y2VwdCA+IDApIHtcblx0ICAgICAgICBoYW5kbGVycyA9IFtdO1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXhjZXB0OyArK2kpIHtcblx0ICAgICAgICAgICAgaGFuZGxlcnNbaV0gPSBhc3RGb3JFeGNlcHRDbGF1c2UoYywgQ0hJTEQobiwgMyArIGkgKiAzKSwgQ0hJTEQobiwgNSArIGkgKiAzKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGV4Y2VwdFN0ID0gbmV3IFRyeUV4Y2VwdChib2R5LCBoYW5kbGVycywgb3JlbHNlLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblxuXHQgICAgICAgIGlmICghZmluYWxseV8pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGV4Y2VwdFN0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8qIGlmIGEgJ2ZpbmFsbHknIGlzIHByZXNlbnQgdG9vLCB3ZSBuZXN0IHRoZSBUcnlFeGNlcHQgd2l0aGluIGFcblx0ICAgICAgICAgVHJ5RmluYWxseSB0byBlbXVsYXRlIHRyeSAuLi4gZXhjZXB0IC4uLiBmaW5hbGx5ICovXG5cdCAgICAgICAgYm9keSA9IFtleGNlcHRTdF07XG5cdCAgICB9XG5cblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoZmluYWxseV8gIT09IG51bGwpO1xuXHQgICAgcmV0dXJuIG5ldyBUcnlGaW5hbGx5KGJvZHksIGZpbmFsbHlfLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gYXN0Rm9yRG90dGVkTmFtZSAoYywgbikge1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgZTtcblx0ICAgIHZhciBpZDtcblx0ICAgIHZhciBjb2xfb2Zmc2V0O1xuXHQgICAgdmFyIGxpbmVubztcblx0ICAgIFJFUShuLCBTWU0uZG90dGVkX25hbWUpO1xuXHQgICAgbGluZW5vID0gbi5saW5lbm87XG5cdCAgICBjb2xfb2Zmc2V0ID0gbi5jb2xfb2Zmc2V0O1xuXHQgICAgaWQgPSBzdHJvYmooQ0hJTEQobiwgMCkudmFsdWUpO1xuXHQgICAgZSA9IG5ldyBOYW1lKGlkLCBMb2FkLCBsaW5lbm8sIGNvbF9vZmZzZXQpO1xuXHQgICAgZm9yIChpID0gMjsgaSA8IE5DSChuKTsgaSArPSAyKSB7XG5cdCAgICAgICAgaWQgPSBzdHJvYmooQ0hJTEQobiwgaSkudmFsdWUpO1xuXHQgICAgICAgIGUgPSBuZXcgQXR0cmlidXRlKGUsIGlkLCBMb2FkLCBsaW5lbm8sIGNvbF9vZmZzZXQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGU7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JEZWNvcmF0b3IgKGMsIG4pIHtcblx0ICAgIC8qIGRlY29yYXRvcjogJ0AnIGRvdHRlZF9uYW1lIFsgJygnIFthcmdsaXN0XSAnKScgXSBORVdMSU5FICovXG5cdCAgICB2YXIgbmFtZUV4cHI7XG5cdCAgICBSRVEobiwgU1lNLmRlY29yYXRvcik7XG5cdCAgICBSRVEoQ0hJTEQobiwgMCksIFRPSy5UX0FUKTtcblx0ICAgIFJFUShDSElMRChuLCBOQ0gobikgLSAxKSwgVE9LLlRfTkVXTElORSk7XG5cdCAgICBuYW1lRXhwciA9IGFzdEZvckRvdHRlZE5hbWUoYywgQ0hJTEQobiwgMSkpO1xuXHQgICAgaWYgKE5DSChuKSA9PT0gMykgLy8gbm8gYXJnc1xuXHQgICAge1xuXHQgICAgICAgIHJldHVybiBuYW1lRXhwcjtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKE5DSChuKSA9PT0gNSkgLy8gY2FsbCB3aXRoIG5vIGFyZ3Ncblx0ICAgIHtcblx0ICAgICAgICByZXR1cm4gbmV3IENhbGwobmFtZUV4cHIsIFtdLCBbXSwgbnVsbCwgbnVsbCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gYXN0Rm9yQ2FsbChjLCBDSElMRChuLCAzKSwgbmFtZUV4cHIpO1xuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yRGVjb3JhdG9ycyAoYywgbikge1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgZGVjb3JhdG9yU2VxO1xuXHQgICAgUkVRKG4sIFNZTS5kZWNvcmF0b3JzKTtcblx0ICAgIGRlY29yYXRvclNlcSA9IFtdO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IE5DSChuKTsgKytpKSB7XG5cdCAgICAgICAgZGVjb3JhdG9yU2VxW2ldID0gYXN0Rm9yRGVjb3JhdG9yKGMsIENISUxEKG4sIGkpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkZWNvcmF0b3JTZXE7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JEZWNvcmF0ZWQgKGMsIG4pIHtcblx0ICAgIHZhciB0aGluZztcblx0ICAgIHZhciBkZWNvcmF0b3JTZXE7XG5cdCAgICBSRVEobiwgU1lNLmRlY29yYXRlZCk7XG5cdCAgICBkZWNvcmF0b3JTZXEgPSBhc3RGb3JEZWNvcmF0b3JzKGMsIENISUxEKG4sIDApKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoQ0hJTEQobiwgMSkudHlwZSA9PT0gU1lNLmZ1bmNkZWYgfHwgQ0hJTEQobiwgMSkudHlwZSA9PT0gU1lNLmNsYXNzZGVmKTtcblxuXHQgICAgdGhpbmcgPSBudWxsO1xuXHQgICAgaWYgKENISUxEKG4sIDEpLnR5cGUgPT09IFNZTS5mdW5jZGVmKSB7XG5cdCAgICAgICAgdGhpbmcgPSBhc3RGb3JGdW5jZGVmKGMsIENISUxEKG4sIDEpLCBkZWNvcmF0b3JTZXEpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoQ0hJTEQobiwgMSkgPT09IFNZTS5jbGFzc2RlZikge1xuXHQgICAgICAgIHRoaW5nID0gYXN0Rm9yQ2xhc3NkZWYoYywgQ0hJTEQobiwgMSksIGRlY29yYXRvclNlcSk7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpbmcpIHtcblx0ICAgICAgICB0aGluZy5saW5lbm8gPSBuLmxpbmVubztcblx0ICAgICAgICB0aGluZy5jb2xfb2Zmc2V0ID0gbi5jb2xfb2Zmc2V0O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaW5nO1xuXHR9XG5cblx0Ly9ub3RlOiB3aXRoIHN0YXRlbWVudHMgbmVlZCB0byBiZSB1cGRhdGVkIHRvIDIuN1xuXHQvL3NlZTogYXN0LmMgbGluZXM6IDMxMjcgLT4gMzE4NVxuXG5cdGZ1bmN0aW9uIGFzdEZvcldpdGhWYXIgKGMsIG4pIHtcblx0ICAgIFJFUShuLCBTWU0ud2l0aF9pdGVtKTtcblx0ICAgIHJldHVybiBhc3RGb3JFeHByKGMsIENISUxEKG4sIDEpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvcldpdGhTdG10IChjLCBuKSB7XG5cdCAgICAvKiB3aXRoX3N0bXQ6ICd3aXRoJyB0ZXN0IFsgd2l0aF92YXIgXSAnOicgc3VpdGUgKi9cblx0ICAgIHZhciBvcHRpb25hbFZhcnM7XG5cdCAgICB2YXIgY29udGV4dEV4cHI7XG5cdCAgICB2YXIgc3VpdGVJbmRleCA9IDM7IC8vIHNraXAgd2l0aCwgdGVzdCwgOlxuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChuLnR5cGUgPT09IFNZTS53aXRoX3N0bXQpO1xuXHQgICAgY29udGV4dEV4cHIgPSBhc3RGb3JFeHByKGMsIENISUxEKG4sIDEpKTtcblx0ICAgIGlmIChDSElMRChuLCAyKS50eXBlID09PSBTWU0ud2l0aF9pdGVtKSB7XG5cdCAgICAgICAgb3B0aW9uYWxWYXJzID0gYXN0Rm9yV2l0aFZhcihjLCBDSElMRChuLCAyKSk7XG5cdCAgICAgICAgc2V0Q29udGV4dChjLCBvcHRpb25hbFZhcnMsIFN0b3JlLCBuKTtcblx0ICAgICAgICBzdWl0ZUluZGV4ID0gNDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgV2l0aF8oY29udGV4dEV4cHIsIG9wdGlvbmFsVmFycywgYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgc3VpdGVJbmRleCkpLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckV4ZWNTdG10IChjLCBuKSB7XG5cdCAgICB2YXIgZXhwcjEsIGdsb2JhbHMgPSBudWxsLCBsb2NhbHMgPSBudWxsO1xuXHQgICAgdmFyIG5jaGlsZHJlbiA9IE5DSChuKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQobmNoaWxkcmVuID09PSAyIHx8IG5jaGlsZHJlbiA9PT0gNCB8fCBuY2hpbGRyZW4gPT09IDYpO1xuXG5cdCAgICAvKiBleGVjX3N0bXQ6ICdleGVjJyBleHByIFsnaW4nIHRlc3QgWycsJyB0ZXN0XV0gKi9cblx0ICAgIFJFUShuLCBTWU0uZXhlY19zdG10KTtcblx0ICAgIGV4cHIxID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCAxKSk7XG5cdCAgICBpZiAobmNoaWxkcmVuID49IDQpIHtcblx0ICAgICAgICBnbG9iYWxzID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCAzKSk7XG5cdCAgICB9XG5cdCAgICBpZiAobmNoaWxkcmVuID09PSA2KSB7XG5cdCAgICAgICAgbG9jYWxzID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCA1KSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IEV4ZWMoZXhwcjEsIGdsb2JhbHMsIGxvY2Fscywgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JJZlN0bXQgKGMsIG4pIHtcblx0ICAgIC8qIGlmX3N0bXQ6ICdpZicgdGVzdCAnOicgc3VpdGUgKCdlbGlmJyB0ZXN0ICc6JyBzdWl0ZSkqXG5cdCAgICAgWydlbHNlJyAnOicgc3VpdGVdXG5cdCAgICAgKi9cblx0ICAgIHZhciBvZmY7XG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciBvcmVsc2U7XG5cdCAgICB2YXIgaGFzRWxzZTtcblx0ICAgIHZhciBuRWxpZjtcblx0ICAgIHZhciBkZWNpZGVyO1xuXHQgICAgdmFyIHM7XG5cdCAgICBSRVEobiwgU1lNLmlmX3N0bXQpO1xuXHQgICAgaWYgKE5DSChuKSA9PT0gNCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgSWZfKFxuXHQgICAgICAgICAgICBhc3RGb3JFeHByKGMsIENISUxEKG4sIDEpKSxcblx0ICAgICAgICAgICAgYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgMykpLFxuXHQgICAgICAgICAgICBbXSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICB9XG5cblx0ICAgIHMgPSBDSElMRChuLCA0KS52YWx1ZTtcblx0ICAgIGRlY2lkZXIgPSBzLmNoYXJBdCgyKTsgLy8gZWxTZSBvciBlbElmXG5cdCAgICBpZiAoZGVjaWRlciA9PT0gXCJzXCIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IElmXyhcblx0ICAgICAgICAgICAgYXN0Rm9yRXhwcihjLCBDSElMRChuLCAxKSksXG5cdCAgICAgICAgICAgIGFzdEZvclN1aXRlKGMsIENISUxEKG4sIDMpKSxcblx0ICAgICAgICAgICAgYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgNikpLFxuXHQgICAgICAgICAgICBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGRlY2lkZXIgPT09IFwiaVwiKSB7XG5cdCAgICAgICAgbkVsaWYgPSBOQ0gobikgLSA0O1xuXHQgICAgICAgIGhhc0Vsc2UgPSBmYWxzZTtcblx0ICAgICAgICBvcmVsc2UgPSBbXTtcblxuXHQgICAgICAgIC8qIG11c3QgcmVmZXJlbmNlIHRoZSBjaGlsZCBuRWxpZisxIHNpbmNlICdlbHNlJyB0b2tlbiBpcyB0aGlyZCwgbm90XG5cdCAgICAgICAgICogZm91cnRoIGNoaWxkIGZyb20gdGhlIGVuZC4gKi9cblx0ICAgICAgICBpZiAoQ0hJTEQobiwgbkVsaWYgKyAxKS50eXBlID09PSBUT0suVF9OQU1FICYmXG5cdCAgICAgICAgICAgIENISUxEKG4sIG5FbGlmICsgMSkudmFsdWUuY2hhckF0KDIpID09PSBcInNcIikge1xuXHQgICAgICAgICAgICBoYXNFbHNlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgbkVsaWYgLT0gMztcblx0ICAgICAgICB9XG5cdCAgICAgICAgbkVsaWYgLz0gNDtcblxuXHQgICAgICAgIGlmIChoYXNFbHNlKSB7XG5cdCAgICAgICAgICAgIG9yZWxzZSA9IFtcblx0ICAgICAgICAgICAgICAgIG5ldyBJZl8oXG5cdCAgICAgICAgICAgICAgICAgICAgYXN0Rm9yRXhwcihjLCBDSElMRChuLCBOQ0gobikgLSA2KSksXG5cdCAgICAgICAgICAgICAgICAgICAgYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgTkNIKG4pIC0gNCkpLFxuXHQgICAgICAgICAgICAgICAgICAgIGFzdEZvclN1aXRlKGMsIENISUxEKG4sIE5DSChuKSAtIDEpKSxcblx0ICAgICAgICAgICAgICAgICAgICBDSElMRChuLCBOQ0gobikgLSA2KS5saW5lbm8sXG5cdCAgICAgICAgICAgICAgICAgICAgQ0hJTEQobiwgTkNIKG4pIC0gNikuY29sX29mZnNldCldO1xuXHQgICAgICAgICAgICBuRWxpZi0tO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuRWxpZjsgKytpKSB7XG5cdCAgICAgICAgICAgIG9mZiA9IDUgKyAobkVsaWYgLSBpIC0gMSkgKiA0O1xuXHQgICAgICAgICAgICBvcmVsc2UgPSBbXG5cdCAgICAgICAgICAgICAgICBuZXcgSWZfKFxuXHQgICAgICAgICAgICAgICAgICAgIGFzdEZvckV4cHIoYywgQ0hJTEQobiwgb2ZmKSksXG5cdCAgICAgICAgICAgICAgICAgICAgYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgb2ZmICsgMikpLFxuXHQgICAgICAgICAgICAgICAgICAgIG9yZWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICBDSElMRChuLCBvZmYpLmxpbmVubyxcblx0ICAgICAgICAgICAgICAgICAgICBDSElMRChuLCBvZmYpLmNvbF9vZmZzZXQpXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBJZl8oXG5cdCAgICAgICAgICAgIGFzdEZvckV4cHIoYywgQ0hJTEQobiwgMSkpLFxuXHQgICAgICAgICAgICBhc3RGb3JTdWl0ZShjLCBDSElMRChuLCAzKSksXG5cdCAgICAgICAgICAgIG9yZWxzZSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICB9XG5cblx0ICAgIGdvb2cuYXNzZXJ0cy5mYWlsKFwidW5leHBlY3RlZCB0b2tlbiBpbiAnaWYnIHN0YXRlbWVudFwiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckV4cHJsaXN0IChjLCBuLCBjb250ZXh0KSB7XG5cdCAgICB2YXIgZTtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIHNlcTtcblx0ICAgIFJFUShuLCBTWU0uZXhwcmxpc3QpO1xuXHQgICAgc2VxID0gW107XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgTkNIKG4pOyBpICs9IDIpIHtcblx0ICAgICAgICBlID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCBpKSk7XG5cdCAgICAgICAgc2VxW2kgLyAyXSA9IGU7XG5cdCAgICAgICAgaWYgKGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgc2V0Q29udGV4dChjLCBlLCBjb250ZXh0LCBDSElMRChuLCBpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHNlcTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckRlbFN0bXQgKGMsIG4pIHtcblx0ICAgIC8qIGRlbF9zdG10OiAnZGVsJyBleHBybGlzdCAqL1xuXHQgICAgUkVRKG4sIFNZTS5kZWxfc3RtdCk7XG5cdCAgICByZXR1cm4gbmV3IERlbGV0ZV8oYXN0Rm9yRXhwcmxpc3QoYywgQ0hJTEQobiwgMSksIERlbCksIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yR2xvYmFsU3RtdCAoYywgbikge1xuXHQgICAgLyogZ2xvYmFsX3N0bXQ6ICdnbG9iYWwnIE5BTUUgKCcsJyBOQU1FKSogKi9cblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIHMgPSBbXTtcblx0ICAgIFJFUShuLCBTWU0uZ2xvYmFsX3N0bXQpO1xuXHQgICAgZm9yIChpID0gMTsgaSA8IE5DSChuKTsgaSArPSAyKSB7XG5cdCAgICAgICAgc1soaSAtIDEpIC8gMl0gPSBzdHJvYmooQ0hJTEQobiwgaSkudmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBHbG9iYWwocywgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JBc3NlcnRTdG10IChjLCBuKSB7XG5cdCAgICAvKiBhc3NlcnRfc3RtdDogJ2Fzc2VydCcgdGVzdCBbJywnIHRlc3RdICovXG5cdCAgICBSRVEobiwgU1lNLmFzc2VydF9zdG10KTtcblx0ICAgIGlmIChOQ0gobikgPT09IDIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IEFzc2VydChhc3RGb3JFeHByKGMsIENISUxEKG4sIDEpKSwgbnVsbCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChOQ0gobikgPT09IDQpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IEFzc2VydChhc3RGb3JFeHByKGMsIENISUxEKG4sIDEpKSwgYXN0Rm9yRXhwcihjLCBDSElMRChuLCAzKSksIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgfVxuXHQgICAgZ29vZy5hc3NlcnRzLmZhaWwoXCJpbXByb3BlciBudW1iZXIgb2YgcGFydHMgdG8gYXNzZXJ0IHN0bXRcIik7XG5cdH1cblxuXHRmdW5jdGlvbiBhbGlhc0ZvckltcG9ydE5hbWUgKGMsIG4pIHtcblx0ICAgIC8qXG5cdCAgICAgaW1wb3J0X2FzX25hbWU6IE5BTUUgWydhcycgTkFNRV1cblx0ICAgICBkb3R0ZWRfYXNfbmFtZTogZG90dGVkX25hbWUgWydhcycgTkFNRV1cblx0ICAgICBkb3R0ZWRfbmFtZTogTkFNRSAoJy4nIE5BTUUpKlxuXHQgICAgICovXG5cblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIGE7XG5cdCAgICB2YXIgbmFtZTtcblx0ICAgIHZhciBzdHI7XG5cdCAgICBsb29wOiB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgIHN3aXRjaCAobi50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmltcG9ydF9hc19uYW1lOlxuXHQgICAgICAgICAgICAgICAgc3RyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIG5hbWUgPSBzdHJvYmooQ0hJTEQobiwgMCkudmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKE5DSChuKSA9PT0gMykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0ciA9IENISUxEKG4sIDIpLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhbGlhcyhuYW1lLCBzdHIgPT0gbnVsbCA/IG51bGwgOiBzdHJvYmooc3RyKSk7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmRvdHRlZF9hc19uYW1lOlxuXHQgICAgICAgICAgICAgICAgaWYgKE5DSChuKSA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG4gPSBDSElMRChuLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYSA9IGFsaWFzRm9ySW1wb3J0TmFtZShjLCBDSElMRChuLCAwKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZ29vZy5hc3NlcnRzLmFzc2VydCghYS5hc25hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGEuYXNuYW1lID0gc3Ryb2JqKENISUxEKG4sIDIpLnZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFNZTS5kb3R0ZWRfbmFtZTpcblx0ICAgICAgICAgICAgICAgIGlmIChOQ0gobikgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFsaWFzKHN0cm9iaihDSElMRChuLCAwKS52YWx1ZSksIG51bGwpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgc3RyaW5nIG9mIHRoZSBmb3JtIGEuYi5jXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTkNIKG4pOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IENISUxEKG4sIGkpLnZhbHVlICsgXCIuXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYWxpYXMoc3Ryb2JqKHN0ci5zdWJzdHIoMCwgc3RyLmxlbmd0aCAtIDEpKSwgbnVsbCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBUT0suVF9TVEFSOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhbGlhcyhzdHJvYmooXCIqXCIpLCBudWxsKTtcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwidW5leHBlY3RlZCBpbXBvcnQgbmFtZVwiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JJbXBvcnRTdG10IChjLCBuKSB7XG5cdCAgICAvKlxuXHQgICAgIGltcG9ydF9zdG10OiBpbXBvcnRfbmFtZSB8IGltcG9ydF9mcm9tXG5cdCAgICAgaW1wb3J0X25hbWU6ICdpbXBvcnQnIGRvdHRlZF9hc19uYW1lc1xuXHQgICAgIGltcG9ydF9mcm9tOiAnZnJvbScgKCcuJyogZG90dGVkX25hbWUgfCAnLicpICdpbXBvcnQnXG5cdCAgICAgKCcqJyB8ICcoJyBpbXBvcnRfYXNfbmFtZXMgJyknIHwgaW1wb3J0X2FzX25hbWVzKVxuXHQgICAgICovXG5cdCAgICB2YXIgbW9kbmFtZTtcblx0ICAgIHZhciBpZHg7XG5cdCAgICB2YXIgbmNoaWxkcmVuO1xuXHQgICAgdmFyIG5kb3RzO1xuXHQgICAgdmFyIG1vZDtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIGFsaWFzZXM7XG5cdCAgICB2YXIgY29sX29mZnNldDtcblx0ICAgIHZhciBsaW5lbm87XG5cdCAgICBSRVEobiwgU1lNLmltcG9ydF9zdG10KTtcblx0ICAgIGxpbmVubyA9IG4ubGluZW5vO1xuXHQgICAgY29sX29mZnNldCA9IG4uY29sX29mZnNldDtcblx0ICAgIG4gPSBDSElMRChuLCAwKTtcblx0ICAgIGlmIChuLnR5cGUgPT09IFNZTS5pbXBvcnRfbmFtZSkge1xuXHQgICAgICAgIG4gPSBDSElMRChuLCAxKTtcblx0ICAgICAgICBSRVEobiwgU1lNLmRvdHRlZF9hc19uYW1lcyk7XG5cdCAgICAgICAgYWxpYXNlcyA9IFtdO1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBOQ0gobik7IGkgKz0gMikge1xuXHQgICAgICAgICAgICBhbGlhc2VzW2kgLyAyXSA9IGFsaWFzRm9ySW1wb3J0TmFtZShjLCBDSElMRChuLCBpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgSW1wb3J0XyhhbGlhc2VzLCBsaW5lbm8sIGNvbF9vZmZzZXQpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAobi50eXBlID09PSBTWU0uaW1wb3J0X2Zyb20pIHtcblx0ICAgICAgICBtb2QgPSBudWxsO1xuXHQgICAgICAgIG5kb3RzID0gMDtcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMTsgaWR4IDwgTkNIKG4pOyArK2lkeCkge1xuXHQgICAgICAgICAgICBpZiAoQ0hJTEQobiwgaWR4KS50eXBlID09PSBTWU0uZG90dGVkX25hbWUpIHtcblx0ICAgICAgICAgICAgICAgIG1vZCA9IGFsaWFzRm9ySW1wb3J0TmFtZShjLCBDSElMRChuLCBpZHgpKTtcblx0ICAgICAgICAgICAgICAgIGlkeCsrO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoQ0hJTEQobiwgaWR4KS50eXBlICE9PSBUT0suVF9ET1QpIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG5kb3RzKys7XG5cdCAgICAgICAgfVxuXHQgICAgICAgICsraWR4OyAvLyBza2lwIHRoZSBpbXBvcnQga2V5d29yZFxuXHQgICAgICAgIHN3aXRjaCAoQ0hJTEQobiwgaWR4KS50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgVE9LLlRfU1RBUjpcblx0ICAgICAgICAgICAgICAgIC8vIGZyb20gLi4uIGltcG9ydFxuXHQgICAgICAgICAgICAgICAgbiA9IENISUxEKG4sIGlkeCk7XG5cdCAgICAgICAgICAgICAgICBuY2hpbGRyZW4gPSAxO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgVE9LLlRfTFBBUjpcblx0ICAgICAgICAgICAgICAgIC8vIGZyb20gLi4uIGltcG9ydCAoeCwgeSwgeilcblx0ICAgICAgICAgICAgICAgIG4gPSBDSElMRChuLCBpZHggKyAxKTtcblx0ICAgICAgICAgICAgICAgIG5jaGlsZHJlbiA9IE5DSChuKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFNZTS5pbXBvcnRfYXNfbmFtZXM6XG5cdCAgICAgICAgICAgICAgICAvLyBmcm9tIC4uLiBpbXBvcnQgeCwgeSwgelxuXHQgICAgICAgICAgICAgICAgbiA9IENISUxEKG4sIGlkeCk7XG5cdCAgICAgICAgICAgICAgICBuY2hpbGRyZW4gPSBOQ0gobik7XG5cdCAgICAgICAgICAgICAgICBpZiAobmNoaWxkcmVuICUgMiA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwidHJhaWxpbmcgY29tbWEgbm90IGFsbG93ZWQgd2l0aG91dCBzdXJyb3VuZGluZyBwYXJlbnRoZXNlc1wiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUtdHlwZSBpbiBmcm9tLWltcG9ydFwiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYWxpYXNlcyA9IFtdO1xuXHQgICAgICAgIGlmIChuLnR5cGUgPT09IFRPSy5UX1NUQVIpIHtcblx0ICAgICAgICAgICAgYWxpYXNlc1swXSA9IGFsaWFzRm9ySW1wb3J0TmFtZShjLCBuKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBOQ0gobik7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgYWxpYXNlc1tpIC8gMl0gPSBhbGlhc0ZvckltcG9ydE5hbWUoYywgQ0hJTEQobiwgaSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG1vZG5hbWUgPSBtb2QgPyBtb2QubmFtZS52IDogXCJcIjtcblx0ICAgICAgICByZXR1cm4gbmV3IEltcG9ydEZyb20oc3Ryb2JqKG1vZG5hbWUpLCBhbGlhc2VzLCBuZG90cywgbGluZW5vLCBjb2xfb2Zmc2V0KTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwidW5rbm93biBpbXBvcnQgc3RhdGVtZW50XCIsIGMuY19maWxlbmFtZSwgbi5saW5lbm8pO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yVGVzdGxpc3RDb21wKGMsIG4pIHtcblx0ICAgIC8qIHRlc3RsaXN0X2NvbXA6IHRlc3QgKCBjb21wX2ZvciB8ICgnLCcgdGVzdCkqIFsnLCddICkgKi9cblx0ICAgIC8qIGFyZ3VtZW50OiB0ZXN0IFtjb21wX2Zvcl0gKi9cblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQobi50eXBlID09PSBTWU0udGVzdGxpc3RfY29tcCB8fCBuLnR5cGUgPT09IFNZTS5hcmd1bWVudCk7XG5cdCAgICBpZiAoTkNIKG4pID4gMSAmJiBDSElMRChuLCAxKS50eXBlID09PSBTWU0uY29tcF9mb3IpIHtcblx0ICAgICAgICByZXR1cm4gYXN0Rm9yR2VuRXhwcihjLCBuKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBhc3RGb3JUZXN0bGlzdChjLCBuKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckxpc3Rjb21wIChjLCBuKSB7XG5cdCAgICAvKiBsaXN0bWFrZXI6IHRlc3QgKCBsaXN0X2ZvciB8ICgnLCcgdGVzdCkqIFsnLCddIClcblx0ICAgICBsaXN0X2ZvcjogJ2ZvcicgZXhwcmxpc3QgJ2luJyB0ZXN0bGlzdF9zYWZlIFtsaXN0X2l0ZXJdXG5cdCAgICAgbGlzdF9pdGVyOiBsaXN0X2ZvciB8IGxpc3RfaWZcblx0ICAgICBsaXN0X2lmOiAnaWYnIHRlc3QgW2xpc3RfaXRlcl1cblx0ICAgICB0ZXN0bGlzdF9zYWZlOiB0ZXN0IFsoJywnIHRlc3QpKyBbJywnXV1cblx0ICAgICAqL1xuXG5cdCAgICBmdW5jdGlvbiBjb3VudExpc3RGb3JzIChjLCBuKSB7XG5cdCAgICAgICAgdmFyIG5mb3JzID0gMDtcblx0ICAgICAgICB2YXIgY2ggPSBDSElMRChuLCAxKTtcblx0ICAgICAgICBjb3VudF9saXN0X2Zvcjogd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgbmZvcnMrKztcblx0ICAgICAgICAgICAgUkVRKGNoLCBTWU0ubGlzdF9mb3IpO1xuXHQgICAgICAgICAgICBpZiAoTkNIKGNoKSA9PT0gNSkge1xuXHQgICAgICAgICAgICAgICAgY2ggPSBDSElMRChjaCwgNCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmZvcnM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY291bnRfbGlzdF9pdGVyOiB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgUkVRKGNoLCBTWU0ubGlzdF9pdGVyKTtcblx0ICAgICAgICAgICAgICAgIGNoID0gQ0hJTEQoY2gsIDApO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoLnR5cGUgPT09IFNZTS5saXN0X2Zvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGNvdW50X2xpc3RfZm9yO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2gudHlwZSA9PT0gU1lNLmxpc3RfaWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoTkNIKGNoKSA9PT0gMykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IENISUxEKGNoLCAyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgY291bnRfbGlzdF9pdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5mb3JzO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY291bnRMaXN0SWZzIChjLCBuKSB7XG5cdCAgICAgICAgdmFyIG5pZnMgPSAwO1xuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgICAgIFJFUShuLCBTWU0ubGlzdF9pdGVyKTtcblx0ICAgICAgICAgICAgaWYgKENISUxEKG4sIDApLnR5cGUgPT09IFNZTS5saXN0X2Zvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5pZnM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbiA9IENISUxEKG4sIDApO1xuXHQgICAgICAgICAgICBSRVEobiwgU1lNLmxpc3RfaWYpO1xuXHQgICAgICAgICAgICBuaWZzKys7XG5cdCAgICAgICAgICAgIGlmIChOQ0gobikgPT0gMikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5pZnM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbiA9IENISUxEKG4sIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGo7XG5cdCAgICB2YXIgaWZzO1xuXHQgICAgdmFyIG5pZnM7XG5cdCAgICB2YXIgbGM7XG5cdCAgICB2YXIgZXhwcmVzc2lvbjtcblx0ICAgIHZhciB0O1xuXHQgICAgdmFyIGZvcmNoO1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgY2g7XG5cdCAgICB2YXIgbGlzdGNvbXBzO1xuXHQgICAgdmFyIG5mb3JzO1xuXHQgICAgdmFyIGVsdDtcblx0ICAgIFJFUShuLCBTWU0ubGlzdG1ha2VyKTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoTkNIKG4pID4gMSk7XG5cdCAgICBlbHQgPSBhc3RGb3JFeHByKGMsIENISUxEKG4sIDApKTtcblx0ICAgIG5mb3JzID0gY291bnRMaXN0Rm9ycyhjLCBuKTtcblx0ICAgIGxpc3Rjb21wcyA9IFtdO1xuXHQgICAgY2ggPSBDSElMRChuLCAxKTtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBuZm9yczsgKytpKSB7XG5cdCAgICAgICAgUkVRKGNoLCBTWU0ubGlzdF9mb3IpO1xuXHQgICAgICAgIGZvcmNoID0gQ0hJTEQoY2gsIDEpO1xuXHQgICAgICAgIHQgPSBhc3RGb3JFeHBybGlzdChjLCBmb3JjaCwgU3RvcmUpO1xuXHQgICAgICAgIGV4cHJlc3Npb24gPSBhc3RGb3JUZXN0bGlzdChjLCBDSElMRChjaCwgMykpO1xuXHQgICAgICAgIGlmIChOQ0goZm9yY2gpID09PSAxKSB7XG5cdCAgICAgICAgICAgIGxjID0gbmV3IGNvbXByZWhlbnNpb24odFswXSwgZXhwcmVzc2lvbiwgW10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbGMgPSBuZXcgY29tcHJlaGVuc2lvbihuZXcgVHVwbGUodCwgU3RvcmUsIGNoLmxpbmVubywgY2guY29sX29mZnNldCksIGV4cHJlc3Npb24sIFtdKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoTkNIKGNoKSA9PT0gNSkge1xuXHQgICAgICAgICAgICBjaCA9IENISUxEKGNoLCA0KTtcblx0ICAgICAgICAgICAgbmlmcyA9IGNvdW50TGlzdElmcyhjLCBjaCk7XG5cdCAgICAgICAgICAgIGlmcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmlmczsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICBSRVEoY2gsIFNZTS5saXN0X2l0ZXIpO1xuXHQgICAgICAgICAgICAgICAgY2ggPSBDSElMRChjaCwgMCk7XG5cdCAgICAgICAgICAgICAgICBSRVEoY2gsIFNZTS5saXN0X2lmKTtcblx0ICAgICAgICAgICAgICAgIGlmc1tqXSA9IGFzdEZvckV4cHIoYywgQ0hJTEQoY2gsIDEpKTtcblx0ICAgICAgICAgICAgICAgIGlmIChOQ0goY2gpID09PSAzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2ggPSBDSElMRChjaCwgMik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNoLnR5cGUgPT09IFNZTS5saXN0X2l0ZXIpIHtcblx0ICAgICAgICAgICAgICAgIGNoID0gQ0hJTEQoY2gsIDApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGxjLmlmcyA9IGlmcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGlzdGNvbXBzW2ldID0gbGM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IExpc3RDb21wKGVsdCwgbGlzdGNvbXBzLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckZhY3RvciAoYywgbikge1xuXHQgICAgLyogc29tZSByYW5kb20gcGVlcGhvbGUgdGhpbmcgdGhhdCBjcHkgZG9lcyAqL1xuXHQgICAgdmFyIGV4cHJlc3Npb247XG5cdCAgICB2YXIgcG51bTtcblx0ICAgIHZhciBwYXRvbTtcblx0ICAgIHZhciBwcG93ZXI7XG5cdCAgICB2YXIgcGZhY3Rvcjtcblx0ICAgIGlmIChDSElMRChuLCAwKS50eXBlID09PSBUT0suVF9NSU5VUyAmJiBOQ0gobikgPT09IDIpIHtcblx0ICAgICAgICBwZmFjdG9yID0gQ0hJTEQobiwgMSk7XG5cdCAgICAgICAgaWYgKHBmYWN0b3IudHlwZSA9PT0gU1lNLmZhY3RvciAmJiBOQ0gocGZhY3RvcikgPT09IDEpIHtcblx0ICAgICAgICAgICAgcHBvd2VyID0gQ0hJTEQocGZhY3RvciwgMCk7XG5cdCAgICAgICAgICAgIGlmIChwcG93ZXIudHlwZSA9PT0gU1lNLnBvd2VyICYmIE5DSChwcG93ZXIpID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICBwYXRvbSA9IENISUxEKHBwb3dlciwgMCk7XG5cdCAgICAgICAgICAgICAgICBpZiAocGF0b20udHlwZSA9PT0gU1lNLmF0b20pIHtcblx0ICAgICAgICAgICAgICAgICAgICBwbnVtID0gQ0hJTEQocGF0b20sIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwbnVtLnR5cGUgPT09IFRPSy5UX05VTUJFUikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwbnVtLnZhbHVlID0gXCItXCIgKyBwbnVtLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN0Rm9yQXRvbShjLCBwYXRvbSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBleHByZXNzaW9uID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCAxKSk7XG5cdCAgICBzd2l0Y2ggKENISUxEKG4sIDApLnR5cGUpIHtcblx0ICAgICAgICBjYXNlIFRPSy5UX1BMVVM6XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVW5hcnlPcChVQWRkLCBleHByZXNzaW9uLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgICAgICBjYXNlIFRPSy5UX01JTlVTOlxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVuYXJ5T3AoVVN1YiwgZXhwcmVzc2lvbiwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgY2FzZSBUT0suVF9USUxERTpcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmFyeU9wKEludmVydCwgZXhwcmVzc2lvbiwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICB9XG5cblx0ICAgIGdvb2cuYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGZhY3RvclwiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckZvclN0bXQgKGMsIG4pIHtcblx0ICAgIC8qIGZvcl9zdG10OiAnZm9yJyBleHBybGlzdCAnaW4nIHRlc3RsaXN0ICc6JyBzdWl0ZSBbJ2Vsc2UnICc6JyBzdWl0ZV0gKi9cblx0ICAgIHZhciB0YXJnZXQ7XG5cdCAgICB2YXIgX3RhcmdldDtcblx0ICAgIHZhciBub2RlVGFyZ2V0O1xuXHQgICAgdmFyIHNlcSA9IFtdO1xuXHQgICAgUkVRKG4sIFNZTS5mb3Jfc3RtdCk7XG5cdCAgICBpZiAoTkNIKG4pID09PSA5KSB7XG5cdCAgICAgICAgc2VxID0gYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgOCkpO1xuXHQgICAgfVxuXHQgICAgbm9kZVRhcmdldCA9IENISUxEKG4sIDEpO1xuXHQgICAgX3RhcmdldCA9IGFzdEZvckV4cHJsaXN0KGMsIG5vZGVUYXJnZXQsIFN0b3JlKTtcblx0ICAgIGlmIChOQ0gobm9kZVRhcmdldCkgPT09IDEpIHtcblx0ICAgICAgICB0YXJnZXQgPSBfdGFyZ2V0WzBdO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgdGFyZ2V0ID0gbmV3IFR1cGxlKF90YXJnZXQsIFN0b3JlLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5ldyBGb3JfKHRhcmdldCxcblx0ICAgICAgICBhc3RGb3JUZXN0bGlzdChjLCBDSElMRChuLCAzKSksXG5cdCAgICAgICAgYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgNSkpLFxuXHQgICAgICAgIHNlcSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JDYWxsIChjLCBuLCBmdW5jKSB7XG5cdCAgICAvKlxuXHQgICAgICBhcmdsaXN0OiAoYXJndW1lbnQgJywnKSogKGFyZ3VtZW50IFsnLCddfCAnKicgdGVzdCBbJywnICcqKicgdGVzdF1cblx0ICAgICAgICAgICAgICAgfCAnKionIHRlc3QpXG5cdCAgICAgIGFyZ3VtZW50OiB0ZXN0IFtjb21wX2Zvcl0gfCB0ZXN0ICc9JyB0ZXN0ICAgICAgICMgUmVhbGx5IFtrZXl3b3JkICc9J10gdGVzdFxuXHQgICAgKi9cblx0ICAgIHZhciB0bXA7XG5cdCAgICB2YXIgaztcblx0ICAgIHZhciBrZXk7XG5cdCAgICB2YXIgZTtcblx0ICAgIHZhciBrd2FyZztcblx0ICAgIHZhciB2YXJhcmc7XG5cdCAgICB2YXIga2V5d29yZHM7XG5cdCAgICB2YXIgYXJncztcblx0ICAgIHZhciBjaDtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIG5nZW5zO1xuXHQgICAgdmFyIG5rZXl3b3Jkcztcblx0ICAgIHZhciBuYXJncztcblxuXHQgICAgUkVRKG4sIFNZTS5hcmdsaXN0KTtcblx0ICAgIG5hcmdzID0gMDtcblx0ICAgIG5rZXl3b3JkcyA9IDA7XG5cdCAgICBuZ2VucyA9IDA7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgTkNIKG4pOyBpKyspIHtcblx0ICAgICAgICBjaCA9IENISUxEKG4sIGkpO1xuXHQgICAgICAgIGlmIChjaC50eXBlID09PSBTWU0uYXJndW1lbnQpIHtcblx0ICAgICAgICAgICAgaWYgKE5DSChjaCkgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIG5hcmdzKys7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoQ0hJTEQoY2gsIDEpLnR5cGUgPT09IFNZTS5jb21wX2Zvcikge1xuXHQgICAgICAgICAgICAgICAgbmdlbnMrKztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5rZXl3b3JkcysrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKG5nZW5zID4gMSB8fCAobmdlbnMgJiYgKG5hcmdzIHx8IG5rZXl3b3JkcykpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJHZW5lcmF0b3IgZXhwcmVzc2lvbiBtdXN0IGJlIHBhcmVudGhlc2l6ZWQgaWYgbm90IHNvbGUgYXJndW1lbnRcIiwgYy5jX2ZpbGVuYW1lLCBuLmxpbmVubyk7XG5cdCAgICB9XG5cdCAgICBpZiAobmFyZ3MgKyBua2V5d29yZHMgKyBuZ2VucyA+IDI1NSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwibW9yZSB0aGFuIDI1NSBhcmd1bWVudHNcIiwgYy5jX2ZpbGVuYW1lLCBuLmxpbmVubyk7XG5cdCAgICB9XG5cdCAgICBhcmdzID0gW107XG5cdCAgICBrZXl3b3JkcyA9IFtdO1xuXHQgICAgbmFyZ3MgPSAwO1xuXHQgICAgbmtleXdvcmRzID0gMDtcblx0ICAgIHZhcmFyZyA9IG51bGw7XG5cdCAgICBrd2FyZyA9IG51bGw7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgTkNIKG4pOyBpKyspIHtcblx0ICAgICAgICBjaCA9IENISUxEKG4sIGkpO1xuXHQgICAgICAgIGlmIChjaC50eXBlID09PSBTWU0uYXJndW1lbnQpIHtcblx0ICAgICAgICAgICAgaWYgKE5DSChjaCkgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChua2V5d29yZHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm5vbi1rZXl3b3JkIGFyZyBhZnRlciBrZXl3b3JkIGFyZ1wiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh2YXJhcmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm9ubHkgbmFtZWQgYXJndW1lbnRzIG1heSBmb2xsb3cgKmV4cHJlc3Npb25cIiwgYy5jX2ZpbGVuYW1lLCBuLmxpbmVubyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBhcmdzW25hcmdzKytdID0gYXN0Rm9yRXhwcihjLCBDSElMRChjaCwgMCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKENISUxEKGNoLCAxKS50eXBlID09PSBTWU0uY29tcF9mb3IpIHtcblx0ICAgICAgICAgICAgICAgIGFyZ3NbbmFyZ3MrK10gPSBhc3RGb3JHZW5FeHByKGMsIGNoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGUgPSBhc3RGb3JFeHByKGMsIENISUxEKGNoLCAwKSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZS5jb25zdHJ1Y3RvciA9PT0gTGFtYmRhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJsYW1iZGEgY2Fubm90IGNvbnRhaW4gYXNzaWdubWVudFwiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuY29uc3RydWN0b3IgIT09IE5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImtleXdvcmQgY2FuJ3QgYmUgYW4gZXhwcmVzc2lvblwiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGtleSA9IGUuaWQ7XG5cdCAgICAgICAgICAgICAgICBmb3JiaWRkZW5DaGVjayhjLCBDSElMRChjaCwgMCksIGtleSwgbi5saW5lbm8pO1xuXHQgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG5rZXl3b3JkczsgKytrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG1wID0ga2V5d29yZHNba10uYXJnO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0bXAgPT09IGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImtleXdvcmQgYXJndW1lbnQgcmVwZWF0ZWRcIiwgYy5jX2ZpbGVuYW1lLCBuLmxpbmVubyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAga2V5d29yZHNbbmtleXdvcmRzKytdID0gbmV3IGtleXdvcmQoa2V5LCBhc3RGb3JFeHByKGMsIENISUxEKGNoLCAyKSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGNoLnR5cGUgPT09IFRPSy5UX1NUQVIpIHtcblx0ICAgICAgICAgICAgdmFyYXJnID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCArK2kpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoY2gudHlwZSA9PT0gVE9LLlRfRE9VQkxFU1RBUikge1xuXHQgICAgICAgICAgICBrd2FyZyA9IGFzdEZvckV4cHIoYywgQ0hJTEQobiwgKytpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBDYWxsKGZ1bmMsIGFyZ3MsIGtleXdvcmRzLCB2YXJhcmcsIGt3YXJnLCBmdW5jLmxpbmVubywgZnVuYy5jb2xfb2Zmc2V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvclRyYWlsZXIgKGMsIG4sIGxlZnRFeHByKSB7XG5cdCAgICAvKiB0cmFpbGVyOiAnKCcgW2FyZ2xpc3RdICcpJyB8ICdbJyBzdWJzY3JpcHRsaXN0ICddJyB8ICcuJyBOQU1FIFxuXHQgICAgIHN1YnNjcmlwdGxpc3Q6IHN1YnNjcmlwdCAoJywnIHN1YnNjcmlwdCkqIFsnLCddXG5cdCAgICAgc3Vic2NyaXB0OiAnLicgJy4nICcuJyB8IHRlc3QgfCBbdGVzdF0gJzonIFt0ZXN0XSBbc2xpY2VvcF1cblx0ICAgICAqL1xuXHQgICAgdmFyIGU7XG5cdCAgICB2YXIgZWx0cztcblx0ICAgIHZhciBzbGM7XG5cdCAgICB2YXIgajtcblx0ICAgIHZhciBzbGljZXM7XG5cdCAgICB2YXIgc2ltcGxlO1xuXHQgICAgUkVRKG4sIFNZTS50cmFpbGVyKTtcblx0ICAgIGlmIChDSElMRChuLCAwKS50eXBlID09PSBUT0suVF9MUEFSKSB7XG5cdCAgICAgICAgaWYgKE5DSChuKSA9PT0gMikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IENhbGwobGVmdEV4cHIsIFtdLCBbXSwgbnVsbCwgbnVsbCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gYXN0Rm9yQ2FsbChjLCBDSElMRChuLCAxKSwgbGVmdEV4cHIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKENISUxEKG4sIDApLnR5cGUgPT09IFRPSy5UX0RPVCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlKGxlZnRFeHByLCBzdHJvYmooQ0hJTEQobiwgMSkudmFsdWUpLCBMb2FkLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIFJFUShDSElMRChuLCAwKSwgVE9LLlRfTFNRQik7XG5cdCAgICAgICAgUkVRKENISUxEKG4sIDIpLCBUT0suVF9SU1FCKTtcblx0ICAgICAgICBuID0gQ0hJTEQobiwgMSk7XG5cdCAgICAgICAgaWYgKE5DSChuKSA9PT0gMSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdChsZWZ0RXhwciwgYXN0Rm9yU2xpY2UoYywgQ0hJTEQobiwgMCkpLCBMb2FkLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIC8qIFRoZSBncmFtbWFyIGlzIGFtYmlndW91cyBoZXJlLiBUaGUgYW1iaWd1aXR5IGlzIHJlc29sdmVkIFxuXHQgICAgICAgICAgICAgYnkgdHJlYXRpbmcgdGhlIHNlcXVlbmNlIGFzIGEgdHVwbGUgbGl0ZXJhbCBpZiB0aGVyZSBhcmVcblx0ICAgICAgICAgICAgIG5vIHNsaWNlIGZlYXR1cmVzLlxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgc2ltcGxlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgc2xpY2VzID0gW107XG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBOQ0gobik7IGogKz0gMikge1xuXHQgICAgICAgICAgICAgICAgc2xjID0gYXN0Rm9yU2xpY2UoYywgQ0hJTEQobiwgaikpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHNsYy5jb25zdHJ1Y3RvciAhPT0gSW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHNsaWNlc1tqIC8gMl0gPSBzbGM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFzaW1wbGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0KGxlZnRFeHByLCBuZXcgRXh0U2xpY2Uoc2xpY2VzKSwgTG9hZCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWx0cyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc2xpY2VzLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICBzbGMgPSBzbGljZXNbal07XG5cdCAgICAgICAgICAgICAgICBnb29nLmFzc2VydHMuYXNzZXJ0KHNsYy5jb25zdHJ1Y3RvciA9PT0gSW5kZXggJiYgc2xjLnZhbHVlICE9PSBudWxsICYmIHNsYy52YWx1ZSAhPT0gdW5kZWZpbmVkKTtcblx0ICAgICAgICAgICAgICAgIGVsdHNbal0gPSBzbGMudmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZSA9IG5ldyBUdXBsZShlbHRzLCBMb2FkLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpcHQobGVmdEV4cHIsIG5ldyBJbmRleChlKSwgTG9hZCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yRmxvd1N0bXQgKGMsIG4pIHtcblx0ICAgIC8qXG5cdCAgICAgZmxvd19zdG10OiBicmVha19zdG10IHwgY29udGludWVfc3RtdCB8IHJldHVybl9zdG10IHwgcmFpc2Vfc3RtdFxuXHQgICAgIHwgeWllbGRfc3RtdFxuXHQgICAgIGJyZWFrX3N0bXQ6ICdicmVhaydcblx0ICAgICBjb250aW51ZV9zdG10OiAnY29udGludWUnXG5cdCAgICAgcmV0dXJuX3N0bXQ6ICdyZXR1cm4nIFt0ZXN0bGlzdF1cblx0ICAgICB5aWVsZF9zdG10OiB5aWVsZF9leHByXG5cdCAgICAgeWllbGRfZXhwcjogJ3lpZWxkJyB0ZXN0bGlzdFxuXHQgICAgIHJhaXNlX3N0bXQ6ICdyYWlzZScgW3Rlc3QgWycsJyB0ZXN0IFsnLCcgdGVzdF1dXVxuXHQgICAgICovXG5cdCAgICB2YXIgY2g7XG5cdCAgICBSRVEobiwgU1lNLmZsb3dfc3RtdCk7XG5cdCAgICBjaCA9IENISUxEKG4sIDApO1xuXHQgICAgc3dpdGNoIChjaC50eXBlKSB7XG5cdCAgICAgICAgY2FzZSBTWU0uYnJlYWtfc3RtdDpcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBCcmVha18obi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgY2FzZSBTWU0uY29udGludWVfc3RtdDpcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250aW51ZV8obi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgY2FzZSBTWU0ueWllbGRfc3RtdDpcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByKGFzdEZvckV4cHIoYywgQ0hJTEQoY2gsIDApKSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgY2FzZSBTWU0ucmV0dXJuX3N0bXQ6XG5cdCAgICAgICAgICAgIGlmIChOQ0goY2gpID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJldHVybl8obnVsbCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJldHVybl8oYXN0Rm9yVGVzdGxpc3QoYywgQ0hJTEQoY2gsIDEpKSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSBTWU0ucmFpc2Vfc3RtdDpcblx0ICAgICAgICAgICAgaWYgKE5DSChjaCkgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmFpc2UobnVsbCwgbnVsbCwgbnVsbCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoTkNIKGNoKSA9PT0gMikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWlzZShhc3RGb3JFeHByKGMsIENISUxEKGNoLCAxKSksIG51bGwsIG51bGwsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKE5DSChjaCkgPT09IDQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmFpc2UoXG5cdCAgICAgICAgICAgICAgICAgICAgYXN0Rm9yRXhwcihjLCBDSElMRChjaCwgMSkpLFxuXHQgICAgICAgICAgICAgICAgICAgIGFzdEZvckV4cHIoYywgQ0hJTEQoY2gsIDMpKSxcblx0ICAgICAgICAgICAgICAgICAgICBudWxsLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChOQ0goY2gpID09PSA2KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhaXNlKFxuXHQgICAgICAgICAgICAgICAgICAgIGFzdEZvckV4cHIoYywgQ0hJTEQoY2gsIDEpKSxcblx0ICAgICAgICAgICAgICAgICAgICBhc3RGb3JFeHByKGMsIENISUxEKGNoLCAzKSksXG5cdCAgICAgICAgICAgICAgICAgICAgYXN0Rm9yRXhwcihjLCBDSElMRChjaCwgNSkpLFxuXHQgICAgICAgICAgICAgICAgICAgIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIGdvb2cuYXNzZXJ0cy5mYWlsKFwidW5leHBlY3RlZCBmbG93X3N0bXRcIik7XG5cdCAgICB9XG5cdCAgICBnb29nLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBmbG93IHN0YXRlbWVudFwiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckFyZ3VtZW50cyAoYywgbikge1xuXHQgICAgLyogcGFyYW1ldGVyczogJygnIFt2YXJhcmdzbGlzdF0gJyknXG5cdCAgICAgdmFyYXJnc2xpc3Q6IChmcGRlZiBbJz0nIHRlc3RdICcsJykqICgnKicgTkFNRSBbJywnICcqKicgTkFNRV1cblx0ICAgICB8ICcqKicgTkFNRSkgfCBmcGRlZiBbJz0nIHRlc3RdICgnLCcgZnBkZWYgWyc9JyB0ZXN0XSkqIFsnLCddXG5cdCAgICAgKi9cblx0ICAgIHZhciBwYXJlbnRoZXNpemVkO1xuXHQgICAgdmFyIGlkO1xuXHQgICAgdmFyIGNvbXBsZXhBcmdzO1xuXHQgICAgdmFyIGs7XG5cdCAgICB2YXIgajtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIGZvdW5kRGVmYXVsdDtcblx0ICAgIHZhciBkZWZhdWx0cztcblx0ICAgIHZhciBhcmdzO1xuXHQgICAgdmFyIGNoO1xuXHQgICAgdmFyIHZhcmFyZyA9IG51bGw7XG5cdCAgICB2YXIga3dhcmcgPSBudWxsO1xuXHQgICAgaWYgKG4udHlwZSA9PT0gU1lNLnBhcmFtZXRlcnMpIHtcblx0ICAgICAgICBpZiAoTkNIKG4pID09PSAyKSAvLyAoKSBhcyBhcmdsaXN0XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IGFyZ3VtZW50c18oW10sIG51bGwsIG51bGwsIFtdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbiA9IENISUxEKG4sIDEpO1xuXHQgICAgfVxuXHQgICAgUkVRKG4sIFNZTS52YXJhcmdzbGlzdCk7XG5cblx0ICAgIGFyZ3MgPSBbXTtcblx0ICAgIGRlZmF1bHRzID0gW107XG5cblx0ICAgIC8qIGZwZGVmOiBOQU1FIHwgJygnIGZwbGlzdCAnKSdcblx0ICAgICBmcGxpc3Q6IGZwZGVmICgnLCcgZnBkZWYpKiBbJywnXVxuXHQgICAgICovXG5cdCAgICBmb3VuZERlZmF1bHQgPSBmYWxzZTtcblx0ICAgIGkgPSAwO1xuXHQgICAgaiA9IDA7IC8vIGluZGV4IGZvciBkZWZhdWx0c1xuXHQgICAgayA9IDA7IC8vIGluZGV4IGZvciBhcmdzXG5cdCAgICB3aGlsZSAoaSA8IE5DSChuKSkge1xuXHQgICAgICAgIGNoID0gQ0hJTEQobiwgaSk7XG5cdCAgICAgICAgc3dpdGNoIChjaC50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmZwZGVmOlxuXHQgICAgICAgICAgICAgICAgY29tcGxleEFyZ3MgPSAwO1xuXHQgICAgICAgICAgICAgICAgcGFyZW50aGVzaXplZCA9IDA7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVfZnBkZWY6IHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgTkNIKG4pICYmIENISUxEKG4sIGkgKyAxKS50eXBlID09PSBUT0suVF9FUVVBTCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0c1tqKytdID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCBpICsgMikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRGVmYXVsdCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvdW5kRGVmYXVsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBkZWYgZigoeCk9NCk6IHBhc3Mgc2hvdWxkIHJhaXNlIGFuIGVycm9yLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgZGVmIGYoKHgsICh5KSkpOiBwYXNzIHdpbGwganVzdCBpbmN1ciB0aGUgdHVwbGUgdW5wYWNraW5nIHdhcm5pbmcuICovXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRoZXNpemVkICYmICFjb21wbGV4QXJncykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJwYXJlbnRoZXNpemVkIGFyZyB3aXRoIGRlZmF1bHRcIiwgYy5jX2ZpbGVuYW1lLCBuLmxpbmVubyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJub24tZGVmYXVsdCBhcmd1bWVudCBmb2xsb3dzIGRlZmF1bHQgYXJndW1lbnRcIiwgYy5jX2ZpbGVuYW1lLCBuLmxpbmVubyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKE5DSChjaCkgPT09IDMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBDSElMRChjaCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZiBmb28oKHgpKTogaXMgbm90IGNvbXBsZXgsIHNwZWNpYWwgY2FzZS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5DSChjaCkgIT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwidHVwbGUgcGFyYW1ldGVyIHVucGFja2luZyBoYXMgYmVlbiByZW1vdmVkXCIsIGMuY19maWxlbmFtZSwgbi5saW5lbm8pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZGVmIGZvbygoeCkpOiBzZXR1cCBmb3IgY2hlY2tpbmcgTkFNRSBiZWxvdy4gKi9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIExvb3AgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSBwYXJlbnMgYW5kIHR1cGxlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5wYWNraW5nIG1peGVkIGluLiAqL1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50aGVzaXplZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IENISUxEKGNoLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoY2gudHlwZSA9PT0gU1lNLmZwZGVmKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGhhbmRsZV9mcGRlZjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoQ0hJTEQoY2gsIDApLnR5cGUgPT09IFRPSy5UX05BTUUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yYmlkZGVuQ2hlY2soYywgbiwgQ0hJTEQoY2gsIDApLnZhbHVlLCBuLmxpbmVubyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gc3Ryb2JqKENISUxEKGNoLCAwKS52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbaysrXSA9IG5ldyBOYW1lKGlkLCBQYXJhbSwgY2gubGluZW5vLCBjaC5jb2xfb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRoZXNpemVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwicGFyZW50aGVzaXplZCBhcmd1bWVudCBuYW1lcyBhcmUgaW52YWxpZFwiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBUT0suVF9TVEFSOlxuXHQgICAgICAgICAgICAgICAgZm9yYmlkZGVuQ2hlY2soYywgQ0hJTEQobiwgaSArIDEpLCBDSElMRChuLCBpICsgMSkudmFsdWUsIG4ubGluZW5vKTtcblx0ICAgICAgICAgICAgICAgIHZhcmFyZyA9IHN0cm9iaihDSElMRChuLCBpICsgMSkudmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgaSArPSAzO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgVE9LLlRfRE9VQkxFU1RBUjpcblx0ICAgICAgICAgICAgICAgIGZvcmJpZGRlbkNoZWNrKGMsIENISUxEKG4sIGkgKyAxKSwgQ0hJTEQobiwgaSArIDEpLnZhbHVlLCBuLmxpbmVubyk7XG5cdCAgICAgICAgICAgICAgICBrd2FyZyA9IHN0cm9iaihDSElMRChuLCBpICsgMSkudmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgaSArPSAzO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBnb29nLmFzc2VydHMuZmFpbChcInVuZXhwZWN0ZWQgbm9kZSBpbiB2YXJhcmdzbGlzdFwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IGFyZ3VtZW50c18oYXJncywgdmFyYXJnLCBrd2FyZywgZGVmYXVsdHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yRnVuY2RlZiAoYywgbiwgZGVjb3JhdG9yU2VxKSB7XG5cdCAgICAvKiBmdW5jZGVmOiAnZGVmJyBOQU1FIHBhcmFtZXRlcnMgJzonIHN1aXRlICovXG5cdCAgICB2YXIgYm9keTtcblx0ICAgIHZhciBhcmdzO1xuXHQgICAgdmFyIG5hbWU7XG5cdCAgICBSRVEobiwgU1lNLmZ1bmNkZWYpO1xuXHQgICAgbmFtZSA9IHN0cm9iaihDSElMRChuLCAxKS52YWx1ZSk7XG5cdCAgICBmb3JiaWRkZW5DaGVjayhjLCBDSElMRChuLCAxKSwgQ0hJTEQobiwgMSkudmFsdWUsIG4ubGluZW5vKTtcblx0ICAgIGFyZ3MgPSBhc3RGb3JBcmd1bWVudHMoYywgQ0hJTEQobiwgMikpO1xuXHQgICAgYm9keSA9IGFzdEZvclN1aXRlKGMsIENISUxEKG4sIDQpKTtcblx0ICAgIHJldHVybiBuZXcgRnVuY3Rpb25EZWYobmFtZSwgYXJncywgYm9keSwgZGVjb3JhdG9yU2VxLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckNsYXNzQmFzZXMgKGMsIG4pIHtcblx0ICAgIC8qIHRlc3RsaXN0OiB0ZXN0ICgnLCcgdGVzdCkqIFsnLCddICovXG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KE5DSChuKSA+IDApO1xuXHQgICAgUkVRKG4sIFNZTS50ZXN0bGlzdCk7XG5cdCAgICBpZiAoTkNIKG4pID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIFsgYXN0Rm9yRXhwcihjLCBDSElMRChuLCAwKSkgXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzZXFGb3JUZXN0bGlzdChjLCBuKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckNsYXNzZGVmIChjLCBuLCBkZWNvcmF0b3JTZXEpIHtcblx0ICAgIC8qIGNsYXNzZGVmOiAnY2xhc3MnIE5BTUUgWycoJyB0ZXN0bGlzdCAnKSddICc6JyBzdWl0ZSAqL1xuXHQgICAgdmFyIHM7XG5cdCAgICB2YXIgYmFzZXM7XG5cdCAgICB2YXIgY2xhc3NuYW1lO1xuXHQgICAgUkVRKG4sIFNZTS5jbGFzc2RlZik7XG5cdCAgICBmb3JiaWRkZW5DaGVjayhjLCBuLCBDSElMRChuLCAxKS52YWx1ZSwgbi5saW5lbm8pO1xuXHQgICAgY2xhc3NuYW1lID0gc3Ryb2JqKENISUxEKG4sIDEpLnZhbHVlKTtcblx0ICAgIGlmIChOQ0gobikgPT09IDQpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IENsYXNzRGVmKGNsYXNzbmFtZSwgW10sIGFzdEZvclN1aXRlKGMsIENISUxEKG4sIDMpKSwgZGVjb3JhdG9yU2VxLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgIH1cblx0ICAgIGlmIChDSElMRChuLCAzKS50eXBlID09PSBUT0suVF9SUEFSKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBDbGFzc0RlZihjbGFzc25hbWUsIFtdLCBhc3RGb3JTdWl0ZShjLCBDSElMRChuLCA1KSksIGRlY29yYXRvclNlcSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICB9XG5cblx0ICAgIGJhc2VzID0gYXN0Rm9yQ2xhc3NCYXNlcyhjLCBDSElMRChuLCAzKSk7XG5cdCAgICBzID0gYXN0Rm9yU3VpdGUoYywgQ0hJTEQobiwgNikpO1xuXHQgICAgcmV0dXJuIG5ldyBDbGFzc0RlZihjbGFzc25hbWUsIGJhc2VzLCBzLCBkZWNvcmF0b3JTZXEsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yTGFtYmRlZiAoYywgbikge1xuXHQgICAgLyogbGFtYmRlZjogJ2xhbWJkYScgW3ZhcmFyZ3NsaXN0XSAnOicgdGVzdCAqL1xuXHQgICAgdmFyIGFyZ3M7XG5cdCAgICB2YXIgZXhwcmVzc2lvbjtcblx0ICAgIGlmIChOQ0gobikgPT09IDMpIHtcblx0ICAgICAgICBhcmdzID0gbmV3IGFyZ3VtZW50c18oW10sIG51bGwsIG51bGwsIFtdKTtcblx0ICAgICAgICBleHByZXNzaW9uID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCAyKSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBhcmdzID0gYXN0Rm9yQXJndW1lbnRzKGMsIENISUxEKG4sIDEpKTtcblx0ICAgICAgICBleHByZXNzaW9uID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCAzKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IExhbWJkYShhcmdzLCBleHByZXNzaW9uLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckNvbXByZWhlbnNpb24oYywgbikge1xuXHQgICAgLyogdGVzdGxpc3RfY29tcDogdGVzdCAoIGNvbXBfZm9yIHwgKCcsJyB0ZXN0KSogWycsJ10gKVxuXHQgICAgICAgYXJndW1lbnQ6IHRlc3QgW2NvbXBfZm9yXSB8IHRlc3QgJz0nIHRlc3QgICAgICAgIyBSZWFsbHkgW2tleXdvcmQgJz0nXSB0ZXN0ICovXG5cdCAgICBcblx0ICAgIHZhciBqO1xuXHQgICAgdmFyIGlmcztcblx0ICAgIHZhciBuaWZzO1xuXHQgICAgdmFyIGdlO1xuXHQgICAgdmFyIGV4cHJlc3Npb247XG5cdCAgICB2YXIgdDtcblx0ICAgIHZhciBmb3JjaDtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIGNoO1xuXHQgICAgdmFyIGdlbmV4cHM7XG5cdCAgICB2YXIgbmZvcnM7XG5cdCAgICB2YXIgZWx0O1xuXHQgICAgdmFyIGNvbXBzO1xuXHQgICAgdmFyIGNvbXA7XG5cblx0ICAgIGZ1bmN0aW9uIGNvdW50Q29tcEZvcnMoYywgbikge1xuXHQgICAgICAgIHZhciBuZm9ycyA9IDA7XG5cdCAgICAgICAgY291bnRfY29tcF9mb3I6IHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgICAgIG5mb3JzKys7XG5cdCAgICAgICAgICAgIFJFUShuLCBTWU0uY29tcF9mb3IpO1xuXHQgICAgICAgICAgICBpZiAoTkNIKG4pID09PSA1KSB7XG5cdCAgICAgICAgICAgICAgICBuID0gQ0hJTEQobiwgNCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmZvcnM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY291bnRfY29tcF9pdGVyOiB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgUkVRKG4sIFNZTS5jb21wX2l0ZXIpO1xuXHQgICAgICAgICAgICAgICAgbiA9IENISUxEKG4sIDApO1xuXHQgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gU1lNLmNvbXBfZm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGludWUgY291bnRfY29tcF9mb3I7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG4udHlwZSA9PT0gU1lNLmNvbXBfaWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoTkNIKG4pID09PSAzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBDSElMRChuLCAyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgY291bnRfY29tcF9pdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZm9ycztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgZ29vZy5hc3NlcnRzLmZhaWwoXCJsb2dpYyBlcnJvciBpbiBjb3VudENvbXBGb3JzXCIpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjb3VudENvbXBJZnMoYywgbikge1xuXHQgICAgICAgIHZhciBuaWZzID0gMDtcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgICAgICBSRVEobiwgU1lNLmNvbXBfaXRlcik7XG5cdCAgICAgICAgICAgIGlmIChDSElMRChuLCAwKS50eXBlID09PSBTWU0uY29tcF9mb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuaWZzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG4gPSBDSElMRChuLCAwKTtcblx0ICAgICAgICAgICAgUkVRKG4sIFNZTS5jb21wX2lmKTtcblx0ICAgICAgICAgICAgbmlmcysrO1xuXHQgICAgICAgICAgICBpZiAoTkNIKG4pID09IDIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuaWZzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG4gPSBDSElMRChuLCAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIG5mb3JzID0gY291bnRDb21wRm9ycyhjLCBuKTtcblx0ICAgIGNvbXBzID0gW107XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbmZvcnM7ICsraSkge1xuXHQgICAgICAgIFJFUShuLCBTWU0uY29tcF9mb3IpO1xuXHQgICAgICAgIGZvcmNoID0gQ0hJTEQobiwgMSk7XG5cdCAgICAgICAgdCA9IGFzdEZvckV4cHJsaXN0KGMsIGZvcmNoLCBTdG9yZSk7XG5cdCAgICAgICAgZXhwcmVzc2lvbiA9IGFzdEZvckV4cHIoYywgQ0hJTEQobiwgMykpO1xuXHQgICAgICAgIGlmIChOQ0goZm9yY2gpID09PSAxKSB7XG5cdCAgICAgICAgICAgIGNvbXAgPSBuZXcgY29tcHJlaGVuc2lvbih0WzBdLCBleHByZXNzaW9uLCBbXSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY29tcCA9IG5ldyBjb21wcmVoZW5zaW9uKG5ldyBUdXBsZSh0LCBTdG9yZSwgbi5saW5lbm8sIG4uY29sX29mZnNldCksIGV4cHJlc3Npb24sIFtdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKE5DSChuKSA9PT0gNSkge1xuXHQgICAgICAgICAgICBuID0gQ0hJTEQobiwgNCk7XG5cdCAgICAgICAgICAgIG5pZnMgPSBjb3VudENvbXBJZnMoYywgbik7XG5cdCAgICAgICAgICAgIGlmcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmlmczsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICBSRVEobiwgU1lNLmNvbXBfaXRlcik7XG5cdCAgICAgICAgICAgICAgICBuID0gQ0hJTEQobiwgMCk7XG5cdCAgICAgICAgICAgICAgICBSRVEobiwgU1lNLmNvbXBfaWYpO1xuXHQgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGFzdEZvckV4cHIoYywgQ0hJTEQobiwgMSkpO1xuXHQgICAgICAgICAgICAgICAgaWZzW2pdID0gZXhwcmVzc2lvbjtcblx0ICAgICAgICAgICAgICAgIGlmIChOQ0gobikgPT09IDMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBuID0gQ0hJTEQobiwgMik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gU1lNLmNvbXBfaXRlcikge1xuXHQgICAgICAgICAgICAgICAgbiA9IENISUxEKG4sIDApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNvbXAuaWZzID0gaWZzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb21wc1tpXSA9IGNvbXA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY29tcHM7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JJdGVyQ29tcChjLCBuLCB0eXBlKSB7XG5cdCAgICB2YXIgZWx0LCBjb21wcztcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoTkNIKG4pID4gMSk7XG5cdCAgICBlbHQgPSBhc3RGb3JFeHByKGMsIENISUxEKG4sIDApKTtcblx0ICAgIGNvbXBzID0gYXN0Rm9yQ29tcHJlaGVuc2lvbihjLCBDSElMRChuLCAxKSk7XG5cdCAgICBpZiAodHlwZSA9PT0gQ09NUF9HRU5FWFApIHtcblx0ICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRvckV4cChlbHQsIGNvbXBzLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQ09NUF9TRVRDT01QKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBTZXRDb21wKGVsdCwgY29tcHMsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yRGljdENvbXAoYywgbikge1xuXHQgICAgdmFyIGtleSwgdmFsdWU7XG5cdCAgICB2YXIgY29tcHMgPSBbXTtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoTkNIKG4pID4gMyk7XG5cdCAgICBSRVEoQ0hJTEQobiwgMSksIFRPSy5UX0NPTE9OKTtcblx0ICAgIGtleSA9IGFzdEZvckV4cHIoYywgQ0hJTEQobiwgMCkpO1xuXHQgICAgdmFsdWUgPSBhc3RGb3JFeHByKGMsIENISUxEKG4sIDIpKTtcblx0ICAgIGNvbXBzID0gYXN0Rm9yQ29tcHJlaGVuc2lvbihjLCBDSElMRChuLCAzKSk7XG5cdCAgICByZXR1cm4gbmV3IERpY3RDb21wKGtleSwgdmFsdWUsIGNvbXBzLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckdlbkV4cHIoYywgbikge1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChuLnR5cGUgPT09IFNZTS50ZXN0bGlzdF9jb21wIHx8IG4udHlwZSA9PT0gU1lNLmFyZ3VtZW50KTtcblx0ICAgIHJldHVybiBhc3RGb3JJdGVyQ29tcChjLCBuLCBDT01QX0dFTkVYUCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JTZXRDb21wKGMsIG4pIHtcblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQobi50eXBlID09PSBTWU0uZGljdG9yc2V0bWFrZXIpO1xuXHQgICAgcmV0dXJuIGFzdEZvckl0ZXJDb21wKGMsIG4sIENPTVBfU0VUQ09NUCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhc3RGb3JXaGlsZVN0bXQgKGMsIG4pIHtcblx0ICAgIC8qIHdoaWxlX3N0bXQ6ICd3aGlsZScgdGVzdCAnOicgc3VpdGUgWydlbHNlJyAnOicgc3VpdGVdICovXG5cdCAgICBSRVEobiwgU1lNLndoaWxlX3N0bXQpO1xuXHQgICAgaWYgKE5DSChuKSA9PT0gNCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgV2hpbGVfKGFzdEZvckV4cHIoYywgQ0hJTEQobiwgMSkpLCBhc3RGb3JTdWl0ZShjLCBDSElMRChuLCAzKSksIFtdLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKE5DSChuKSA9PT0gNykge1xuXHQgICAgICAgIHJldHVybiBuZXcgV2hpbGVfKGFzdEZvckV4cHIoYywgQ0hJTEQobiwgMSkpLCBhc3RGb3JTdWl0ZShjLCBDSElMRChuLCAzKSksIGFzdEZvclN1aXRlKGMsIENISUxEKG4sIDYpKSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICB9XG5cdCAgICBnb29nLmFzc2VydHMuZmFpbChcIndyb25nIG51bWJlciBvZiB0b2tlbnMgZm9yICd3aGlsZScgc3RtdFwiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckF1Z2Fzc2lnbiAoYywgbikge1xuXHQgICAgUkVRKG4sIFNZTS5hdWdhc3NpZ24pO1xuXHQgICAgbiA9IENISUxEKG4sIDApO1xuXHQgICAgc3dpdGNoIChuLnZhbHVlLmNoYXJBdCgwKSkge1xuXHQgICAgICAgIGNhc2UgXCIrXCI6XG5cdCAgICAgICAgICAgIHJldHVybiBBZGQ7XG5cdCAgICAgICAgY2FzZSBcIi1cIjpcblx0ICAgICAgICAgICAgcmV0dXJuIFN1Yjtcblx0ICAgICAgICBjYXNlIFwiL1wiOlxuXHQgICAgICAgICAgICBpZiAobi52YWx1ZS5jaGFyQXQoMSkgPT09IFwiL1wiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRmxvb3JEaXY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIERpdjtcblx0ICAgICAgICBjYXNlIFwiJVwiOlxuXHQgICAgICAgICAgICByZXR1cm4gTW9kO1xuXHQgICAgICAgIGNhc2UgXCI8XCI6XG5cdCAgICAgICAgICAgIHJldHVybiBMU2hpZnQ7XG5cdCAgICAgICAgY2FzZSBcIj5cIjpcblx0ICAgICAgICAgICAgcmV0dXJuIFJTaGlmdDtcblx0ICAgICAgICBjYXNlIFwiJlwiOlxuXHQgICAgICAgICAgICByZXR1cm4gQml0QW5kO1xuXHQgICAgICAgIGNhc2UgXCJeXCI6XG5cdCAgICAgICAgICAgIHJldHVybiBCaXRYb3I7XG5cdCAgICAgICAgY2FzZSBcInxcIjpcblx0ICAgICAgICAgICAgcmV0dXJuIEJpdE9yO1xuXHQgICAgICAgIGNhc2UgXCIqXCI6XG5cdCAgICAgICAgICAgIGlmIChuLnZhbHVlLmNoYXJBdCgxKSA9PT0gXCIqXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBQb3c7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIE11bHQ7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgZ29vZy5hc3NlcnRzLmZhaWwoXCJpbnZhbGlkIGF1Z2Fzc2lnblwiKTtcblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckJpbm9wIChjLCBuKSB7XG5cdCAgICAvKiBNdXN0IGFjY291bnQgZm9yIGEgc2VxdWVuY2Ugb2YgZXhwcmVzc2lvbnMuXG5cdCAgICAgSG93IHNob3VsZCBBIG9wIEIgb3AgQyBieSByZXByZXNlbnRlZD9cblx0ICAgICBCaW5PcChCaW5PcChBLCBvcCwgQiksIG9wLCBDKS5cblx0ICAgICAqL1xuXHQgICAgdmFyIHRtcDtcblx0ICAgIHZhciBuZXdvcGVyYXRvcjtcblx0ICAgIHZhciBuZXh0T3Blcjtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIHJlc3VsdCA9IG5ldyBCaW5PcChcblx0ICAgICAgICBhc3RGb3JFeHByKGMsIENISUxEKG4sIDApKSxcblx0ICAgICAgICBnZXRPcGVyYXRvcihDSElMRChuLCAxKSksXG5cdCAgICAgICAgYXN0Rm9yRXhwcihjLCBDSElMRChuLCAyKSksXG5cdCAgICAgICAgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICB2YXIgbm9wcyA9IChOQ0gobikgLSAxKSAvIDI7XG5cdCAgICBmb3IgKGkgPSAxOyBpIDwgbm9wczsgKytpKSB7XG5cdCAgICAgICAgbmV4dE9wZXIgPSBDSElMRChuLCBpICogMiArIDEpO1xuXHQgICAgICAgIG5ld29wZXJhdG9yID0gZ2V0T3BlcmF0b3IobmV4dE9wZXIpO1xuXHQgICAgICAgIHRtcCA9IGFzdEZvckV4cHIoYywgQ0hJTEQobiwgaSAqIDIgKyAyKSk7XG5cdCAgICAgICAgcmVzdWx0ID0gbmV3IEJpbk9wKHJlc3VsdCwgbmV3b3BlcmF0b3IsIHRtcCwgbmV4dE9wZXIubGluZW5vLCBuZXh0T3Blci5jb2xfb2Zmc2V0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cblx0ZnVuY3Rpb24gYXN0Rm9yVGVzdGxpc3QoYywgbikge1xuXHQgICAgLyogdGhpcyBkb2Vzbid0IHNob3cgdXAgaW4gR3JhbW1hci50eHQgbmV2ZXIgZGlkOiB0ZXN0bGlzdF9nZXhwOiB0ZXN0ICgnLCcgdGVzdCkqIFsnLCddICovXG5cdCAgICAvKiB0ZXN0bGlzdF9jb21wOiB0ZXN0ICgnLCcgdGVzdCkqIFsnLCddICovXG5cdCAgICAvKiB0ZXN0bGlzdDogdGVzdCAoJywnIHRlc3QpKiBbJywnXSAqL1xuXHQgICAgLyogdGVzdGxpc3Rfc2FmZTogdGVzdCAoJywnIHRlc3QpKyBbJywnXSAqL1xuXHQgICAgLyogdGVzdGxpc3QxOiB0ZXN0ICgnLCcgdGVzdCkqICovXG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KE5DSChuKSA+IDApO1xuXHQgICAgaWYgKG4udHlwZSA9PT0gU1lNLnRlc3RsaXN0X2NvbXApIHtcblx0ICAgICAgICBpZiAoTkNIKG4pID4gMSkge1xuXHQgICAgICAgICAgICBnb29nLmFzc2VydHMuYXNzZXJ0KENISUxEKG4sIDEpLnR5cGUgIT09IFNZTS5jb21wX2Zvcik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgZ29vZy5hc3NlcnRzLmFzc2VydChuLnR5cGUgPT09IFNZTS50ZXN0bGlzdCB8fCBuLnR5cGUgPT09IFNZTS50ZXN0bGlzdF9zYWZlIHx8IG4udHlwZSA9PT0gU1lNLnRlc3RsaXN0MSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChOQ0gobikgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4gYXN0Rm9yRXhwcihjLCBDSElMRChuLCAwKSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFR1cGxlKHNlcUZvclRlc3RsaXN0KGMsIG4pLCBMb2FkLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgIH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yRXhwclN0bXQgKGMsIG4pIHtcblx0ICAgIHZhciBleHByZXNzaW9uO1xuXHQgICAgdmFyIHZhbHVlO1xuXHQgICAgdmFyIGU7XG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciB0YXJnZXRzO1xuXHQgICAgdmFyIGV4cHIyO1xuXHQgICAgdmFyIHZhck5hbWU7XG5cdCAgICB2YXIgZXhwcjE7XG5cdCAgICB2YXIgY2g7XG5cdCAgICBSRVEobiwgU1lNLmV4cHJfc3RtdCk7XG5cdCAgICAvKiBleHByX3N0bXQ6IHRlc3RsaXN0IChhdWdhc3NpZ24gKHlpZWxkX2V4cHJ8dGVzdGxpc3QpIFxuXHQgICAgIHwgKCc9JyAoeWllbGRfZXhwcnx0ZXN0bGlzdCkpKilcblx0ICAgICB0ZXN0bGlzdDogdGVzdCAoJywnIHRlc3QpKiBbJywnXVxuXHQgICAgIGF1Z2Fzc2lnbjogJys9JyB8ICctPScgfCAnKj0nIHwgJy89JyB8ICclPScgfCAnJj0nIHwgJ3w9JyB8ICdePSdcblx0ICAgICB8ICc8PD0nIHwgJz4+PScgfCAnKio9JyB8ICcvLz0nXG5cdCAgICAgdGVzdDogLi4uIGhlcmUgc3RhcnRzIHRoZSBvcGVyYXRvciBwcmVjZW5kZW5jZSBkYW5jZVxuXHQgICAgICovXG5cdCAgICBpZiAoTkNIKG4pID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBFeHByKGFzdEZvclRlc3RsaXN0KGMsIENISUxEKG4sIDApKSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChDSElMRChuLCAxKS50eXBlID09PSBTWU0uYXVnYXNzaWduKSB7XG5cdCAgICAgICAgY2ggPSBDSElMRChuLCAwKTtcblx0ICAgICAgICBleHByMSA9IGFzdEZvclRlc3RsaXN0KGMsIGNoKTtcblx0ICAgICAgICBzd2l0Y2ggKGV4cHIxLmNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgIGNhc2UgR2VuZXJhdG9yRXhwOlxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhdWdtZW50ZWQgYXNzaWdubWVudCB0byBnZW5lcmF0b3IgZXhwcmVzc2lvbiBub3QgcG9zc2libGVcIiwgYy5jX2ZpbGVuYW1lLCBuLmxpbmVubyk7XG5cdCAgICAgICAgICAgIGNhc2UgWWllbGQ6XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImF1Z21lbnRlZCBhc3NpZ25tZW50IHRvIHlpZWxkIGV4cHJlc3Npb24gbm90IHBvc3NpYmxlXCIsIGMuY19maWxlbmFtZSwgbi5saW5lbm8pO1xuXHQgICAgICAgICAgICBjYXNlIE5hbWU6XG5cdCAgICAgICAgICAgICAgICB2YXJOYW1lID0gZXhwcjEuaWQ7XG5cdCAgICAgICAgICAgICAgICBmb3JiaWRkZW5DaGVjayhjLCBjaCwgdmFyTmFtZSwgbi5saW5lbm8pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgQXR0cmlidXRlOlxuXHQgICAgICAgICAgICBjYXNlIFN1YnNjcmlwdDpcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJpbGxlZ2FsIGV4cHJlc3Npb24gZm9yIGF1Z21lbnRlZCBhc3NpZ25tZW50XCIsIGMuY19maWxlbmFtZSwgbi5saW5lbm8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzZXRDb250ZXh0KGMsIGV4cHIxLCBTdG9yZSwgY2gpO1xuXG5cdCAgICAgICAgY2ggPSBDSElMRChuLCAyKTtcblx0ICAgICAgICBpZiAoY2gudHlwZSA9PT0gU1lNLnRlc3RsaXN0KSB7XG5cdCAgICAgICAgICAgIGV4cHIyID0gYXN0Rm9yVGVzdGxpc3QoYywgY2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgZXhwcjIgPSBhc3RGb3JFeHByKGMsIGNoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbmV3IEF1Z0Fzc2lnbihleHByMSwgYXN0Rm9yQXVnYXNzaWduKGMsIENISUxEKG4sIDEpKSwgZXhwcjIsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgLy8gbm9ybWFsIGFzc2lnbm1lbnRcblx0ICAgICAgICBSRVEoQ0hJTEQobiwgMSksIFRPSy5UX0VRVUFMKTtcblx0ICAgICAgICB0YXJnZXRzID0gW107XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IE5DSChuKSAtIDI7IGkgKz0gMikge1xuXHQgICAgICAgICAgICBjaCA9IENISUxEKG4sIGkpO1xuXHQgICAgICAgICAgICBpZiAoY2gudHlwZSA9PT0gU1lNLnlpZWxkX2V4cHIpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYXNzaWdubWVudCB0byB5aWVsZCBleHByZXNzaW9uIG5vdCBwb3NzaWJsZVwiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlID0gYXN0Rm9yVGVzdGxpc3QoYywgY2gpO1xuXHQgICAgICAgICAgICBzZXRDb250ZXh0KGMsIGUsIFN0b3JlLCBDSElMRChuLCBpKSk7XG5cdCAgICAgICAgICAgIHRhcmdldHNbaSAvIDJdID0gZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFsdWUgPSBDSElMRChuLCBOQ0gobikgLSAxKTtcblx0ICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gU1lNLnRlc3RsaXN0KSB7XG5cdCAgICAgICAgICAgIGV4cHJlc3Npb24gPSBhc3RGb3JUZXN0bGlzdChjLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBleHByZXNzaW9uID0gYXN0Rm9yRXhwcihjLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgQXNzaWduKHRhcmdldHMsIGV4cHJlc3Npb24sIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9ySWZleHByIChjLCBuKSB7XG5cdCAgICAvKiB0ZXN0OiBvcl90ZXN0ICdpZicgb3JfdGVzdCAnZWxzZScgdGVzdCAqL1xuXHQgICAgZ29vZy5hc3NlcnRzLmFzc2VydChOQ0gobikgPT09IDUpO1xuXHQgICAgcmV0dXJuIG5ldyBJZkV4cChcblx0ICAgICAgICBhc3RGb3JFeHByKGMsIENISUxEKG4sIDIpKSxcblx0ICAgICAgICBhc3RGb3JFeHByKGMsIENISUxEKG4sIDApKSxcblx0ICAgICAgICBhc3RGb3JFeHByKGMsIENISUxEKG4sIDQpKSxcblx0ICAgICAgICBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBzIGlzIGEgcHl0aG9uLXN0eWxlIHN0cmluZyBsaXRlcmFsLCBpbmNsdWRpbmcgcXVvdGUgY2hhcmFjdGVycyBhbmQgdS9yL2Jcblx0ICogcHJlZml4ZXMuIFJldHVybnMgZGVjb2RlZCBzdHJpbmcgb2JqZWN0LlxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VzdHIgKGMsIHMpIHtcblx0ICAgIHZhciBlbmNvZGVVdGY4ID0gZnVuY3Rpb24gKHMpIHtcblx0ICAgICAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHMpKTtcblx0ICAgIH07XG5cdCAgICB2YXIgZGVjb2RlVXRmOCA9IGZ1bmN0aW9uIChzKSB7XG5cdCAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUocykpO1xuXHQgICAgfTtcblx0ICAgIHZhciBkZWNvZGVFc2NhcGUgPSBmdW5jdGlvbiAocywgcXVvdGUpIHtcblx0ICAgICAgICB2YXIgZDM7XG5cdCAgICAgICAgdmFyIGQyO1xuXHQgICAgICAgIHZhciBkMTtcblx0ICAgICAgICB2YXIgZDA7XG5cdCAgICAgICAgdmFyIGM7XG5cdCAgICAgICAgdmFyIGk7XG5cdCAgICAgICAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuXHQgICAgICAgIHZhciByZXQgPSBcIlwiO1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuXHQgICAgICAgICAgICBjID0gcy5jaGFyQXQoaSk7XG5cdCAgICAgICAgICAgIGlmIChjID09PSBcIlxcXFxcIikge1xuXHQgICAgICAgICAgICAgICAgKytpO1xuXHQgICAgICAgICAgICAgICAgYyA9IHMuY2hhckF0KGkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiblwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0ICs9IFwiXFxuXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIlxcXFxcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldCArPSBcIlxcXFxcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwidFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0ICs9IFwiXFx0XCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcInJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldCArPSBcIlxcclwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCJiXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXQgKz0gXCJcXGJcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiZlwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0ICs9IFwiXFxmXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcInZcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldCArPSBcIlxcdlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIwXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXQgKz0gXCJcXDBcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdcIicpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXQgKz0gJ1wiJztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdcXCcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0ICs9ICdcXCcnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCJcXG5cIikgLyogZXNjYXBlZCBuZXdsaW5lLCBqb2luIGxpbmVzICovIHtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwieFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZDAgPSBzLmNoYXJBdCgrK2kpO1xuXHQgICAgICAgICAgICAgICAgICAgIGQxID0gcy5jaGFyQXQoKytpKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChkMCArIGQxLCAxNikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCJ1XCIgfHwgYyA9PT0gXCJVXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkMCA9IHMuY2hhckF0KCsraSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZDEgPSBzLmNoYXJBdCgrK2kpO1xuXHQgICAgICAgICAgICAgICAgICAgIGQyID0gcy5jaGFyQXQoKytpKTtcblx0ICAgICAgICAgICAgICAgICAgICBkMyA9IHMuY2hhckF0KCsraSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoZDAgKyBkMSwgMTYpLCBwYXJzZUludChkMiArIGQzLCAxNikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTGVhdmUgaXQgYWxvbmVcblx0ICAgICAgICAgICAgICAgICAgICByZXQgKz0gXCJcXFxcXCIgKyBjO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIGdvb2cuYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGVzY2FwZTogJ1wiICsgYy5jaGFyQ29kZUF0KDApICsgXCInXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0ICs9IGM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgIH07XG5cblx0ICAgIC8vcHJpbnQoXCJwYXJzZXN0clwiLCBzKTtcblxuXHQgICAgdmFyIHF1b3RlID0gcy5jaGFyQXQoMCk7XG5cdCAgICB2YXIgcmF3bW9kZSA9IGZhbHNlO1xuXHQgICAgdmFyIHVuaWNvZGUgPSBmYWxzZTtcblxuXHQgICAgLy8gdHJlYXRzIGV2ZXJ5IHNlcXVlbmNlIGFzIHVuaWNvZGVzIGV2ZW4gaWYgdGhleSBhcmUgbm90IHRyZWF0ZWQgd2l0aCB1VSBwcmVmaXhcblx0ICAgIC8vIGtpbmRhIGhhY2tpbmcgdGhvdWdoIHdvcmtpbmcgZm9yIG1vc3QgcHVycG9zZXNcblx0ICAgIGlmKChjLmNfZmxhZ3MgJiBQYXJzZXIuQ09fRlVUVVJFX1VOSUNPREVfTElURVJBTFMgfHwgU2sucHl0aG9uMyA9PT0gdHJ1ZSkpIHtcblx0ICAgICAgICB1bmljb2RlID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHF1b3RlID09PSBcInVcIiB8fCBxdW90ZSA9PT0gXCJVXCIpIHtcblx0ICAgICAgICBzID0gcy5zdWJzdHIoMSk7XG5cdCAgICAgICAgcXVvdGUgPSBzLmNoYXJBdCgwKTtcblx0ICAgICAgICB1bmljb2RlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHF1b3RlID09PSBcInJcIiB8fCBxdW90ZSA9PT0gXCJSXCIpIHtcblx0ICAgICAgICBzID0gcy5zdWJzdHIoMSk7XG5cdCAgICAgICAgcXVvdGUgPSBzLmNoYXJBdCgwKTtcblx0ICAgICAgICByYXdtb2RlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQocXVvdGUgIT09IFwiYlwiICYmIHF1b3RlICE9PSBcIkJcIiwgXCJ0b2RvOyBoYXZlbid0IGRvbmUgYicnIHN0cmluZ3MgeWV0XCIpO1xuXG5cdCAgICBnb29nLmFzc2VydHMuYXNzZXJ0KHF1b3RlID09PSBcIidcIiB8fCBxdW90ZSA9PT0gJ1wiJyAmJiBzLmNoYXJBdChzLmxlbmd0aCAtIDEpID09PSBxdW90ZSk7XG5cdCAgICBzID0gcy5zdWJzdHIoMSwgcy5sZW5ndGggLSAyKTtcblx0ICAgIGlmICh1bmljb2RlKSB7XG5cdCAgICAgICAgcyA9IGVuY29kZVV0Zjgocyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzLmxlbmd0aCA+PSA0ICYmIHMuY2hhckF0KDApID09PSBxdW90ZSAmJiBzLmNoYXJBdCgxKSA9PT0gcXVvdGUpIHtcblx0ICAgICAgICBnb29nLmFzc2VydHMuYXNzZXJ0KHMuY2hhckF0KHMubGVuZ3RoIC0gMSkgPT09IHF1b3RlICYmIHMuY2hhckF0KHMubGVuZ3RoIC0gMikgPT09IHF1b3RlKTtcblx0ICAgICAgICBzID0gcy5zdWJzdHIoMiwgcy5sZW5ndGggLSA0KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHJhd21vZGUgfHwgcy5pbmRleE9mKFwiXFxcXFwiKSA9PT0gLTEpIHtcblx0ICAgICAgICByZXR1cm4gc3Ryb2JqKGRlY29kZVV0ZjgocykpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHN0cm9iaihkZWNvZGVFc2NhcGUocywgcXVvdGUpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlc3RycGx1cyAoYywgbikge1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgcmV0O1xuXHQgICAgUkVRKENISUxEKG4sIDApLCBUT0suVF9TVFJJTkcpO1xuXHQgICAgcmV0ID0gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIpO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IE5DSChuKTsgKytpKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0ID0gcmV0LnNxJGNvbmNhdChwYXJzZXN0cihjLCBDSElMRChuLCBpKS52YWx1ZSkpO1xuXHQgICAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJpbnZhbGlkIHN0cmluZyAocG9zc2libHkgY29udGFpbnMgYSB1bmljb2RlIGNoYXJhY3RlcilcIiwgYy5jX2ZpbGVuYW1lLCBDSElMRChuLCBpKS5saW5lbm8pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZW51bWJlciAoYywgcywgbGluZW5vKSB7XG5cdCAgICB2YXIgbmVnO1xuXHQgICAgdmFyIHZhbDtcblx0ICAgIHZhciB0bXA7XG5cdCAgICB2YXIgZW5kID0gcy5jaGFyQXQocy5sZW5ndGggLSAxKTtcblxuXHQgICAgLy8gY2FsbCBpbnRlcm5hbCBjb21wbGV4IHR5cGUgY29uc3RydWN0b3IgZm9yIGNvbXBsZXggc3RyaW5nc1xuXHQgICAgaWYgKGVuZCA9PT0gXCJqXCIgfHwgZW5kID09PSBcIkpcIikge1xuXHQgICAgICAgIHJldHVybiBTay5idWlsdGluLmNvbXBsZXguY29tcGxleF9zdWJ0eXBlX2Zyb21fc3RyaW5nKHMpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBIYW5kbGUgbG9uZ3Ncblx0ICAgIGlmIChlbmQgPT09IFwibFwiIHx8IGVuZCA9PT0gXCJMXCIpIHtcblx0ICAgICAgICByZXR1cm4gU2subG9uZ0Zyb21TdHIocy5zdWJzdHIoMCwgcy5sZW5ndGggLSAxKSwgMCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIHRvZG87IHdlIGRvbid0IGN1cnJlbnRseSBkaXN0aW5ndWlzaCBiZXR3ZWVuIGludCBhbmQgZmxvYXQgc29cblx0ICAgIC8vIHN0ciBpcyB3cm9uZyBmb3IgdGhlc2UuXG5cdCAgICBpZiAocy5pbmRleE9mKFwiLlwiKSAhPT0gLTEpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHBhcnNlRmxvYXQocykpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBIYW5kbGUgaW50ZWdlcnMgb2YgdmFyaW91cyBiYXNlc1xuXHQgICAgdG1wID0gcztcblx0ICAgIG5lZyA9IGZhbHNlO1xuXHQgICAgaWYgKHMuY2hhckF0KDApID09PSBcIi1cIikge1xuXHQgICAgICAgIHRtcCA9IHMuc3Vic3RyKDEpO1xuXHQgICAgICAgIG5lZyA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0bXAuY2hhckF0KDApID09PSBcIjBcIiAmJiAodG1wLmNoYXJBdCgxKSA9PT0gXCJ4XCIgfHwgdG1wLmNoYXJBdCgxKSA9PT0gXCJYXCIpKSB7XG5cdCAgICAgICAgLy8gSGV4XG5cdCAgICAgICAgdG1wID0gdG1wLnN1YnN0cmluZygyKTtcblx0ICAgICAgICB2YWwgPSBwYXJzZUludCh0bXAsIDE2KTtcblx0ICAgIH0gZWxzZSBpZiAoKHMuaW5kZXhPZihcImVcIikgIT09IC0xKSB8fCAocy5pbmRleE9mKFwiRVwiKSAhPT0gLTEpKSB7XG5cdCAgICAgICAgLy8gRmxvYXQgd2l0aCBleHBvbmVudCAobmVlZGVkIHRvIG1ha2Ugc3VyZSBlL0Ugd2Fzbid0IGhleCBmaXJzdClcblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHBhcnNlRmxvYXQocykpO1xuXHQgICAgfSBlbHNlIGlmICh0bXAuY2hhckF0KDApID09PSBcIjBcIiAmJiAodG1wLmNoYXJBdCgxKSA9PT0gXCJiXCIgfHwgdG1wLmNoYXJBdCgxKSA9PT0gXCJCXCIpKSB7XG5cdCAgICAgICAgLy8gQmluYXJ5XG5cdCAgICAgICAgdG1wID0gdG1wLnN1YnN0cmluZygyKTtcblx0ICAgICAgICB2YWwgPSBwYXJzZUludCh0bXAsIDIpO1xuXHQgICAgfSBlbHNlIGlmICh0bXAuY2hhckF0KDApID09PSBcIjBcIikge1xuXHQgICAgICAgIGlmICh0bXAgPT09IFwiMFwiKSB7XG5cdCAgICAgICAgICAgIC8vIFplcm9cblx0ICAgICAgICAgICAgdmFsID0gMDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBPY3RhbFxuXHQgICAgICAgICAgICB0bXAgPSB0bXAuc3Vic3RyaW5nKDEpO1xuXHQgICAgICAgICAgICBpZiAoKHRtcC5jaGFyQXQoMCkgPT09IFwib1wiKSB8fCAodG1wLmNoYXJBdCgwKSA9PT0gXCJPXCIpKSB7XG5cdCAgICAgICAgICAgICAgICB0bXAgPSB0bXAuc3Vic3RyaW5nKDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhbCA9IHBhcnNlSW50KHRtcCwgOCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgLy8gRGVjaW1hbFxuXHQgICAgICAgIHZhbCA9IHBhcnNlSW50KHRtcCwgMTApO1xuXHQgICAgfVxuXG5cdCAgICAvLyBDb252ZXJ0IHRvIGxvbmdcblx0ICAgIGlmICh2YWwgPiBTay5idWlsdGluLmludF8udGhyZXNob2xkJCAmJlxuXHQgICAgICAgIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsICYmXG5cdCAgICAgICAgKHMuaW5kZXhPZihcImVcIikgPT09IC0xICYmIHMuaW5kZXhPZihcIkVcIikgPT09IC0xKSkge1xuXHQgICAgICAgIHJldHVybiBTay5sb25nRnJvbVN0cihzLCAwKTtcblx0ICAgIH1cblxuXHQgICAgLy8gU21hbGwgZW5vdWdoLCByZXR1cm4gcGFyc2VkIG51bWJlclxuXHQgICAgaWYgKG5lZykge1xuXHQgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKC12YWwpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh2YWwpO1xuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yU2xpY2UgKGMsIG4pIHtcblx0ICAgIHZhciBuMjtcblx0ICAgIHZhciBzdGVwO1xuXHQgICAgdmFyIHVwcGVyO1xuXHQgICAgdmFyIGxvd2VyO1xuXHQgICAgdmFyIGNoO1xuXHQgICAgUkVRKG4sIFNZTS5zdWJzY3JpcHQpO1xuXG5cdCAgICAvKlxuXHQgICAgIHN1YnNjcmlwdDogJy4nICcuJyAnLicgfCB0ZXN0IHwgW3Rlc3RdICc6JyBbdGVzdF0gW3NsaWNlb3BdXG5cdCAgICAgc2xpY2VvcDogJzonIFt0ZXN0XVxuXHQgICAgICovXG5cdCAgICBjaCA9IENISUxEKG4sIDApO1xuXHQgICAgbG93ZXIgPSBudWxsO1xuXHQgICAgdXBwZXIgPSBudWxsO1xuXHQgICAgc3RlcCA9IG51bGw7XG5cdCAgICBpZiAoY2gudHlwZSA9PT0gVE9LLlRfRE9UKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBFbGxpcHNpcygpO1xuXHQgICAgfVxuXHQgICAgaWYgKE5DSChuKSA9PT0gMSAmJiBjaC50eXBlID09PSBTWU0udGVzdCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgSW5kZXgoYXN0Rm9yRXhwcihjLCBjaCkpO1xuXHQgICAgfVxuXHQgICAgaWYgKGNoLnR5cGUgPT09IFNZTS50ZXN0KSB7XG5cdCAgICAgICAgbG93ZXIgPSBhc3RGb3JFeHByKGMsIGNoKTtcblx0ICAgIH1cblx0ICAgIGlmIChjaC50eXBlID09PSBUT0suVF9DT0xPTikge1xuXHQgICAgICAgIGlmIChOQ0gobikgPiAxKSB7XG5cdCAgICAgICAgICAgIG4yID0gQ0hJTEQobiwgMSk7XG5cdCAgICAgICAgICAgIGlmIChuMi50eXBlID09PSBTWU0udGVzdCkge1xuXHQgICAgICAgICAgICAgICAgdXBwZXIgPSBhc3RGb3JFeHByKGMsIG4yKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKE5DSChuKSA+IDIpIHtcblx0ICAgICAgICBuMiA9IENISUxEKG4sIDIpO1xuXHQgICAgICAgIGlmIChuMi50eXBlID09PSBTWU0udGVzdCkge1xuXHQgICAgICAgICAgICB1cHBlciA9IGFzdEZvckV4cHIoYywgbjIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgY2ggPSBDSElMRChuLCBOQ0gobikgLSAxKTtcblx0ICAgIGlmIChjaC50eXBlID09PSBTWU0uc2xpY2VvcCkge1xuXHQgICAgICAgIGlmIChOQ0goY2gpID09PSAxKSB7XG5cdCAgICAgICAgICAgIGNoID0gQ0hJTEQoY2gsIDApO1xuXHQgICAgICAgICAgICBzdGVwID0gbmV3IE5hbWUoc3Ryb2JqKFwiTm9uZVwiKSwgTG9hZCwgY2gubGluZW5vLCBjaC5jb2xfb2Zmc2V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGNoID0gQ0hJTEQoY2gsIDEpO1xuXHQgICAgICAgICAgICBpZiAoY2gudHlwZSA9PT0gU1lNLnRlc3QpIHtcblx0ICAgICAgICAgICAgICAgIHN0ZXAgPSBhc3RGb3JFeHByKGMsIGNoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgU2xpY2UobG93ZXIsIHVwcGVyLCBzdGVwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvckF0b20oYywgbikge1xuXHQgICAgLyogYXRvbTogKCcoJyBbeWllbGRfZXhwcnx0ZXN0bGlzdF9jb21wXSAnKScgfFxuXHQgICAgICAgJ1snIFtsaXN0bWFrZXJdICddJyB8XG5cdCAgICAgICAneycgW2RpY3RvcnNldG1ha2VyXSAnfScgfFxuXHQgICAgICAgJ2AnIHRlc3RsaXN0MSAnYCcgfFxuXHQgICAgICAgTkFNRSB8IE5VTUJFUiB8IFNUUklORyspXG5cdCAgICAqL1xuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgdmFsdWVzO1xuXHQgICAgdmFyIGtleXM7XG5cdCAgICB2YXIgc2l6ZTtcblx0ICAgIHZhciBjaCA9IENISUxEKG4sIDApO1xuXHQgICAgdmFyIGVsdHM7XG5cdCAgICBzd2l0Y2ggKGNoLnR5cGUpIHtcblx0ICAgICAgICBjYXNlIFRPSy5UX05BTUU6XG5cdCAgICAgICAgICAgIC8vIEFsbCBuYW1lcyBzdGFydCBpbiBMb2FkIGNvbnRleHQsIGJ1dCBtYXkgYmUgY2hhbmdlZCBsYXRlclxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IE5hbWUoc3Ryb2JqKGNoLnZhbHVlKSwgTG9hZCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgY2FzZSBUT0suVF9TVFJJTkc6XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgU3RyKHBhcnNlc3RycGx1cyhjLCBuKSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgY2FzZSBUT0suVF9OVU1CRVI6XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgTnVtKHBhcnNlbnVtYmVyKGMsIGNoLnZhbHVlLCBuLmxpbmVubyksIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgIGNhc2UgVE9LLlRfTFBBUjogLy8gdmFyaW91cyB1c2VzIGZvciBwYXJlbnNcblx0ICAgICAgICAgICAgY2ggPSBDSElMRChuLCAxKTtcblx0ICAgICAgICAgICAgaWYgKGNoLnR5cGUgPT09IFRPSy5UX1JQQVIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGUoW10sIExvYWQsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChjaC50eXBlID09PSBTWU0ueWllbGRfZXhwcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvckV4cHIoYywgY2gpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vICAgICAgICAgICAgaWYgKE5DSChjaCkgPiAxICYmIENISUxEKGNoLCAxKS50eXBlID09PSBTWU0uY29tcF9mb3IpIHtcblx0ICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvckNvbXByZWhlbnNpb24oYywgY2gpO1xuXHQgICAgICAgICAgICAvLyAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGFzdEZvclRlc3RsaXN0Q29tcChjLCBjaCk7XG5cdCAgICAgICAgY2FzZSBUT0suVF9MU1FCOiAvLyBsaXN0IG9yIGxpc3Rjb21wXG5cdCAgICAgICAgICAgIGNoID0gQ0hJTEQobiwgMSk7XG5cdCAgICAgICAgICAgIGlmIChjaC50eXBlID09PSBUT0suVF9SU1FCKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpc3QoW10sIExvYWQsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIFJFUShjaCwgU1lNLmxpc3RtYWtlcik7XG5cdCAgICAgICAgICAgIGlmIChOQ0goY2gpID09PSAxIHx8IENISUxEKGNoLCAxKS50eXBlID09PSBUT0suVF9DT01NQSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0KHNlcUZvclRlc3RsaXN0KGMsIGNoKSwgTG9hZCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgICAgIH0gXG5cdCAgICAgICAgICAgIHJldHVybiBhc3RGb3JMaXN0Y29tcChjLCBjaCk7XG5cdCAgICAgICAgICAgIFxuXHQgICAgICAgIGNhc2UgVE9LLlRfTEJSQUNFOlxuXHQgICAgICAgICAgICAvKiBkaWN0b3JzZXRtYWtlcjogXG5cdCAgICAgICAgICAgICAqICAgICAodGVzdCAnOicgdGVzdCAoY29tcF9mb3IgOiAoJywnIHRlc3QgJzonIHRlc3QpKiBbJywnXSkpIHxcblx0ICAgICAgICAgICAgICogICAgICh0ZXN0IChjb21wX2ZvciB8ICgnLCcgdGVzdCkqIFsnLCddKSlcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGtleXMgPSBbXTtcblx0ICAgICAgICAgICAgdmFsdWVzID0gW107XG5cdCAgICAgICAgICAgIGNoID0gQ0hJTEQobiwgMSk7XG5cdCAgICAgICAgICAgIGlmIChuLnR5cGUgPT09IFRPSy5UX1JCUkFDRSkge1xuXHQgICAgICAgICAgICAgICAgLy9pdCdzIGFuIGVtcHR5IGRpY3Rcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGljdChbXSwgbnVsbCwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgICAgIH0gXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKE5DSChjaCkgPT09IDEgfHwgKE5DSChjaCkgIT09IDAgJiYgQ0hJTEQoY2gsIDEpLnR5cGUgPT09IFRPSy5UX0NPTU1BKSkge1xuXHQgICAgICAgICAgICAgICAgLy9pdCdzIGEgc2ltcGxlIHNldFxuXHQgICAgICAgICAgICAgICAgZWx0cyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGguZmxvb3IoKE5DSChjaCkgKyAxKSAvIDIpO1xuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IE5DSChjaCk7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gYXN0Rm9yRXhwcihjLCBDSElMRChjaCwgaSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGVsdHNbaSAvIDJdID0gZXhwcmVzc2lvbjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KGVsdHMsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgICAgICB9IFxuXHQgICAgICAgICAgICBlbHNlIGlmIChOQ0goY2gpICE9PSAwICYmIENISUxEKGNoLCAxKS50eXBlID09IFNZTS5jb21wX2Zvcikge1xuXHQgICAgICAgICAgICAgICAgLy9pdCdzIGEgc2V0IGNvbXByZWhlbnNpb25cblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RGb3JTZXRDb21wKGMsIGNoKTtcblx0ICAgICAgICAgICAgfSBcblx0ICAgICAgICAgICAgZWxzZSBpZiAoTkNIKGNoKSA+IDMgJiYgQ0hJTEQoY2gsIDMpLnR5cGUgPT09IFNZTS5jb21wX2Zvcikge1xuXHQgICAgICAgICAgICAgICAgLy9pdCdzIGEgZGljdCBjb21wci4gSSB0aGluay5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RGb3JEaWN0Q29tcChjLCBjaCk7XG5cdCAgICAgICAgICAgIH0gXG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGguZmxvb3IoKE5DSChjaCkgKyAxKSAvIDQpOyAvLyArIDEgZm9yIG5vIHRyYWlsaW5nIGNvbW1hIGNhc2Vcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBOQ0goY2gpOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzW2kgLyA0XSA9IGFzdEZvckV4cHIoYywgQ0hJTEQoY2gsIGkpKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaSAvIDRdID0gYXN0Rm9yRXhwcihjLCBDSElMRChjaCwgaSArIDIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGljdChrZXlzLCB2YWx1ZXMsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgY2FzZSBUT0suVF9CQUNLUVVPVEU6XG5cdCAgICAgICAgICAgIC8vdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJiYWNrcXVvdGUgbm90IHN1cHBvcnRlZCwgdXNlIHJlcHIoKVwiLCBjLmNfZmlsZW5hbWUsIG4ubGluZW5vKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXByKGFzdEZvclRlc3RsaXN0KGMsIENISUxEKG4sIDEpKSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgZ29vZy5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgYXRvbVwiLCBjaC50eXBlKTtcblxuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yUG93ZXIgKGMsIG4pIHtcblx0ICAgIC8qIHBvd2VyOiBhdG9tIHRyYWlsZXIqICgnKionIGZhY3RvcikqXG5cdCAgICAgKi9cblx0ICAgIHZhciBmO1xuXHQgICAgdmFyIHRtcDtcblx0ICAgIHZhciBjaDtcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIGU7XG5cdCAgICBSRVEobiwgU1lNLnBvd2VyKTtcblx0ICAgIGUgPSBhc3RGb3JBdG9tKGMsIENISUxEKG4sIDApKTtcblx0ICAgIGlmIChOQ0gobikgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4gZTtcblx0ICAgIH1cblx0ICAgIGZvciAoaSA9IDE7IGkgPCBOQ0gobik7ICsraSkge1xuXHQgICAgICAgIGNoID0gQ0hJTEQobiwgaSk7XG5cdCAgICAgICAgaWYgKGNoLnR5cGUgIT09IFNZTS50cmFpbGVyKSB7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0bXAgPSBhc3RGb3JUcmFpbGVyKGMsIGNoLCBlKTtcblx0ICAgICAgICB0bXAubGluZW5vID0gZS5saW5lbm87XG5cdCAgICAgICAgdG1wLmNvbF9vZmZzZXQgPSBlLmNvbF9vZmZzZXQ7XG5cdCAgICAgICAgZSA9IHRtcDtcblx0ICAgIH1cblx0ICAgIGlmIChDSElMRChuLCBOQ0gobikgLSAxKS50eXBlID09PSBTWU0uZmFjdG9yKSB7XG5cdCAgICAgICAgZiA9IGFzdEZvckV4cHIoYywgQ0hJTEQobiwgTkNIKG4pIC0gMSkpO1xuXHQgICAgICAgIGUgPSBuZXcgQmluT3AoZSwgUG93LCBmLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBlO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yRXhwciAoYywgbikge1xuXHQgICAgLyogaGFuZGxlIHRoZSBmdWxsIHJhbmdlIG9mIHNpbXBsZSBleHByZXNzaW9uc1xuXHQgICAgIHRlc3Q6IG9yX3Rlc3QgWydpZicgb3JfdGVzdCAnZWxzZScgdGVzdF0gfCBsYW1iZGVmXG5cdCAgICAgb3JfdGVzdDogYW5kX3Rlc3QgKCdvcicgYW5kX3Rlc3QpKlxuXHQgICAgIGFuZF90ZXN0OiBub3RfdGVzdCAoJ2FuZCcgbm90X3Rlc3QpKlxuXHQgICAgIG5vdF90ZXN0OiAnbm90JyBub3RfdGVzdCB8IGNvbXBhcmlzb25cblx0ICAgICBjb21wYXJpc29uOiBleHByIChjb21wX29wIGV4cHIpKlxuXHQgICAgIGV4cHI6IHhvcl9leHByICgnfCcgeG9yX2V4cHIpKlxuXHQgICAgIHhvcl9leHByOiBhbmRfZXhwciAoJ14nIGFuZF9leHByKSpcblx0ICAgICBhbmRfZXhwcjogc2hpZnRfZXhwciAoJyYnIHNoaWZ0X2V4cHIpKlxuXHQgICAgIHNoaWZ0X2V4cHI6IGFyaXRoX2V4cHIgKCgnPDwnfCc+PicpIGFyaXRoX2V4cHIpKlxuXHQgICAgIGFyaXRoX2V4cHI6IHRlcm0gKCgnKyd8Jy0nKSB0ZXJtKSpcblx0ICAgICB0ZXJtOiBmYWN0b3IgKCgnKid8Jy8nfCclJ3wnLy8nKSBmYWN0b3IpKlxuXHQgICAgIGZhY3RvcjogKCcrJ3wnLSd8J34nKSBmYWN0b3IgfCBwb3dlclxuXHQgICAgIHBvd2VyOiBhdG9tIHRyYWlsZXIqICgnKionIGZhY3RvcikqXG5cblx0ICAgICBBcyB3ZWxsIGFzIG1vZGlmaWVkIHZlcnNpb25zIHRoYXQgZXhpc3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksXG5cdCAgICAgdG8gZXhwbGljaXRseSBhbGxvdzpcblx0ICAgICBbIHggZm9yIHggaW4gbGFtYmRhOiAwLCBsYW1iZGE6IDEgXVxuXHQgICAgICh3aGljaCB3b3VsZCBiZSBhbWJpZ3VvdXMgd2l0aG91dCB0aGVzZSBleHRyYSBydWxlcylcblxuXHQgICAgIG9sZF90ZXN0OiBvcl90ZXN0IHwgb2xkX2xhbWJkZWZcblx0ICAgICBvbGRfbGFtYmRlZjogJ2xhbWJkYScgW3ZhcmFyZ2xpc3RdICc6JyBvbGRfdGVzdFxuXG5cdCAgICAgKi9cblxuXHQgICAgdmFyIGV4cDtcblx0ICAgIHZhciBjbXBzO1xuXHQgICAgdmFyIG9wcztcblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIHNlcTtcblx0ICAgIExPT1A6IHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgc3dpdGNoIChuLnR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSBTWU0udGVzdDpcblx0ICAgICAgICAgICAgY2FzZSBTWU0ub2xkX3Rlc3Q6XG5cdCAgICAgICAgICAgICAgICBpZiAoQ0hJTEQobiwgMCkudHlwZSA9PT0gU1lNLmxhbWJkZWYgfHwgQ0hJTEQobiwgMCkudHlwZSA9PT0gU1lNLm9sZF9sYW1iZGVmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvckxhbWJkZWYoYywgQ0hJTEQobiwgMCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoTkNIKG4pID4gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3RGb3JJZmV4cHIoYywgbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG5cdCAgICAgICAgICAgIGNhc2UgU1lNLm9yX3Rlc3Q6XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmFuZF90ZXN0OlxuXHQgICAgICAgICAgICAgICAgaWYgKE5DSChuKSA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG4gPSBDSElMRChuLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBMT09QO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc2VxID0gW107XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTkNIKG4pOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZXFbaSAvIDJdID0gYXN0Rm9yRXhwcihjLCBDSElMRChuLCBpKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoQ0hJTEQobiwgMSkudmFsdWUgPT09IFwiYW5kXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xPcChBbmQsIHNlcSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBnb29nLmFzc2VydHMuYXNzZXJ0KENISUxEKG4sIDEpLnZhbHVlID09PSBcIm9yXCIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sT3AoT3IsIHNlcSwgbi5saW5lbm8sIG4uY29sX29mZnNldCk7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLm5vdF90ZXN0OlxuXHQgICAgICAgICAgICAgICAgaWYgKE5DSChuKSA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG4gPSBDSElMRChuLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBMT09QO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmFyeU9wKE5vdCwgYXN0Rm9yRXhwcihjLCBDSElMRChuLCAxKSksIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmNvbXBhcmlzb246XG5cdCAgICAgICAgICAgICAgICBpZiAoTkNIKG4pID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbiA9IENISUxEKG4sIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIExPT1A7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcHMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBjbXBzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IE5DSChuKTsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wc1soaSAtIDEpIC8gMl0gPSBhc3RGb3JDb21wT3AoYywgQ0hJTEQobiwgaSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjbXBzWyhpIC0gMSkgLyAyXSA9IGFzdEZvckV4cHIoYywgQ0hJTEQobiwgaSArIDEpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wYXJlKGFzdEZvckV4cHIoYywgQ0hJTEQobiwgMCkpLCBvcHMsIGNtcHMsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmV4cHI6XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLnhvcl9leHByOlxuXHQgICAgICAgICAgICBjYXNlIFNZTS5hbmRfZXhwcjpcblx0ICAgICAgICAgICAgY2FzZSBTWU0uc2hpZnRfZXhwcjpcblx0ICAgICAgICAgICAgY2FzZSBTWU0uYXJpdGhfZXhwcjpcblx0ICAgICAgICAgICAgY2FzZSBTWU0udGVybTpcblx0ICAgICAgICAgICAgICAgIGlmIChOQ0gobikgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBuID0gQ0hJTEQobiwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGludWUgTE9PUDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RGb3JCaW5vcChjLCBuKTtcblx0ICAgICAgICAgICAgY2FzZSBTWU0ueWllbGRfZXhwcjpcblx0ICAgICAgICAgICAgICAgIGV4cCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICBpZiAoTkNIKG4pID09PSAyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXhwID0gYXN0Rm9yVGVzdGxpc3QoYywgQ0hJTEQobiwgMSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBZaWVsZChleHAsIG4ubGluZW5vLCBuLmNvbF9vZmZzZXQpO1xuXHQgICAgICAgICAgICBjYXNlIFNZTS5mYWN0b3I6XG5cdCAgICAgICAgICAgICAgICBpZiAoTkNIKG4pID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbiA9IENISUxEKG4sIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIExPT1A7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXN0Rm9yRmFjdG9yKGMsIG4pO1xuXHQgICAgICAgICAgICBjYXNlIFNZTS5wb3dlcjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RGb3JQb3dlcihjLCBuKTtcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGdvb2cuYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGV4cHJcIiwgXCJuLnR5cGU6ICVkXCIsIG4udHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYXN0Rm9yUHJpbnRTdG10IChjLCBuKSB7XG5cdCAgICAvKiBwcmludF9zdG10OiAncHJpbnQnICggWyB0ZXN0ICgnLCcgdGVzdCkqIFsnLCddIF1cblx0ICAgICB8ICc+PicgdGVzdCBbICgnLCcgdGVzdCkrIFsnLCddIF0gKVxuXHQgICAgICovXG5cdCAgICB2YXIgbmw7XG5cdCAgICB2YXIgaSwgajtcblx0ICAgIHZhciBzZXE7XG5cdCAgICB2YXIgc3RhcnQgPSAxO1xuXHQgICAgdmFyIGRlc3QgPSBudWxsO1xuXHQgICAgUkVRKG4sIFNZTS5wcmludF9zdG10KTtcblx0ICAgIGlmIChOQ0gobikgPj0gMiAmJiBDSElMRChuLCAxKS50eXBlID09PSBUT0suVF9SSUdIVFNISUZUKSB7XG5cdCAgICAgICAgZGVzdCA9IGFzdEZvckV4cHIoYywgQ0hJTEQobiwgMikpO1xuXHQgICAgICAgIHN0YXJ0ID0gNDtcblx0ICAgIH1cblx0ICAgIHNlcSA9IFtdO1xuXHQgICAgZm9yIChpID0gc3RhcnQsIGogPSAwOyBpIDwgTkNIKG4pOyBpICs9IDIsICsraikge1xuXHQgICAgICAgIHNlcVtqXSA9IGFzdEZvckV4cHIoYywgQ0hJTEQobiwgaSkpO1xuXHQgICAgfVxuXHQgICAgbmwgPSAoQ0hJTEQobiwgTkNIKG4pIC0gMSkpLnR5cGUgPT09IFRPSy5UX0NPTU1BID8gZmFsc2UgOiB0cnVlO1xuXHQgICAgcmV0dXJuIG5ldyBQcmludChkZXN0LCBzZXEsIG5sLCBuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzdEZvclN0bXQgKGMsIG4pIHtcblx0ICAgIHZhciBjaDtcblx0ICAgIGlmIChuLnR5cGUgPT09IFNZTS5zdG10KSB7XG5cdCAgICAgICAgZ29vZy5hc3NlcnRzLmFzc2VydChOQ0gobikgPT09IDEpO1xuXHQgICAgICAgIG4gPSBDSElMRChuLCAwKTtcblx0ICAgIH1cblx0ICAgIGlmIChuLnR5cGUgPT09IFNZTS5zaW1wbGVfc3RtdCkge1xuXHQgICAgICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQobnVtU3RtdHMobikgPT09IDEpO1xuXHQgICAgICAgIG4gPSBDSElMRChuLCAwKTtcblx0ICAgIH1cblx0ICAgIGlmIChuLnR5cGUgPT09IFNZTS5zbWFsbF9zdG10KSB7XG5cdCAgICAgICAgUkVRKG4sIFNZTS5zbWFsbF9zdG10KTtcblx0ICAgICAgICBuID0gQ0hJTEQobiwgMCk7XG5cdCAgICAgICAgLyogc21hbGxfc3RtdDogZXhwcl9zdG10IHwgcHJpbnRfc3RtdCAgfCBkZWxfc3RtdCB8IHBhc3Nfc3RtdFxuXHQgICAgICAgICB8IGZsb3dfc3RtdCB8IGltcG9ydF9zdG10IHwgZ2xvYmFsX3N0bXQgfCBleGVjX3N0bXRcblx0ICAgICAgICAgfCBhc3NlcnRfc3RtdFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN3aXRjaCAobi50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmV4cHJfc3RtdDpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RGb3JFeHByU3RtdChjLCBuKTtcblx0ICAgICAgICAgICAgY2FzZSBTWU0ucHJpbnRfc3RtdDpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RGb3JQcmludFN0bXQoYywgbik7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmRlbF9zdG10OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvckRlbFN0bXQoYywgbik7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLnBhc3Nfc3RtdDpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFzcyhuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgICAgICAgICAgY2FzZSBTWU0uZmxvd19zdG10OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvckZsb3dTdG10KGMsIG4pO1xuXHQgICAgICAgICAgICBjYXNlIFNZTS5pbXBvcnRfc3RtdDpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RGb3JJbXBvcnRTdG10KGMsIG4pO1xuXHQgICAgICAgICAgICBjYXNlIFNZTS5nbG9iYWxfc3RtdDpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RGb3JHbG9iYWxTdG10KGMsIG4pO1xuXHQgICAgICAgICAgICBjYXNlIFNZTS5leGVjX3N0bXQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXN0Rm9yRXhlY1N0bXQoYywgbik7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmFzc2VydF9zdG10OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvckFzc2VydFN0bXQoYywgbik7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLmRlYnVnZ2VyX3N0bXQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlYnVnZ2VyXyhuLmxpbmVubywgbi5jb2xfb2Zmc2V0KTtcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGdvb2cuYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIHNtYWxsX3N0bXRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgLyogY29tcG91bmRfc3RtdDogaWZfc3RtdCB8IHdoaWxlX3N0bXQgfCBmb3Jfc3RtdCB8IHRyeV9zdG10XG5cdCAgICAgICAgIHwgZnVuY2RlZiB8IGNsYXNzZGVmIHwgZGVjb3JhdGVkXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ggPSBDSElMRChuLCAwKTtcblx0ICAgICAgICBSRVEobiwgU1lNLmNvbXBvdW5kX3N0bXQpO1xuXHQgICAgICAgIHN3aXRjaCAoY2gudHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlIFNZTS5pZl9zdG10OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvcklmU3RtdChjLCBjaCk7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLndoaWxlX3N0bXQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXN0Rm9yV2hpbGVTdG10KGMsIGNoKTtcblx0ICAgICAgICAgICAgY2FzZSBTWU0uZm9yX3N0bXQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXN0Rm9yRm9yU3RtdChjLCBjaCk7XG5cdCAgICAgICAgICAgIGNhc2UgU1lNLnRyeV9zdG10OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvclRyeVN0bXQoYywgY2gpO1xuXHQgICAgICAgICAgICBjYXNlIFNZTS53aXRoX3N0bXQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXN0Rm9yV2l0aFN0bXQoYywgY2gpO1xuXHQgICAgICAgICAgICBjYXNlIFNZTS5mdW5jZGVmOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvckZ1bmNkZWYoYywgY2gsIFtdKTtcblx0ICAgICAgICAgICAgY2FzZSBTWU0uY2xhc3NkZWY6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXN0Rm9yQ2xhc3NkZWYoYywgY2gsIFtdKTtcblx0ICAgICAgICAgICAgY2FzZSBTWU0uZGVjb3JhdGVkOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdEZvckRlY29yYXRlZChjLCBjaCk7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBnb29nLmFzc2VydHMuYXNzZXJ0KFwidW5oYW5kbGVkIGNvbXBvdW5kX3N0bXRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0U2suYXN0RnJvbVBhcnNlID0gZnVuY3Rpb24gKG4sIGZpbGVuYW1lLCBjX2ZsYWdzKSB7XG5cdCAgICB2YXIgajtcblx0ICAgIHZhciBudW07XG5cdCAgICB2YXIgY2g7XG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciBjID0gbmV3IENvbXBpbGluZyhcInV0Zi04XCIsIGZpbGVuYW1lLCBjX2ZsYWdzKTtcblx0ICAgIHZhciBzdG10cyA9IFtdO1xuXHQgICAgdmFyIGsgPSAwO1xuXHQgICAgc3dpdGNoIChuLnR5cGUpIHtcblx0ICAgICAgICBjYXNlIFNZTS5maWxlX2lucHV0OlxuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTkNIKG4pIC0gMTsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICBjaCA9IENISUxEKG4sIGkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gVE9LLlRfTkVXTElORSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgUkVRKGNoLCBTWU0uc3RtdCk7XG5cdCAgICAgICAgICAgICAgICBudW0gPSBudW1TdG10cyhjaCk7XG5cdCAgICAgICAgICAgICAgICBpZiAobnVtID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RtdHNbaysrXSA9IGFzdEZvclN0bXQoYywgY2gpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2ggPSBDSElMRChjaCwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgUkVRKGNoLCBTWU0uc2ltcGxlX3N0bXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBudW07ICsraikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG10c1trKytdID0gYXN0Rm9yU3RtdChjLCBDSElMRChjaCwgaiAqIDIpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bGUoc3RtdHMpO1xuXHQgICAgICAgIGNhc2UgU1lNLmV2YWxfaW5wdXQ6XG5cdCAgICAgICAgICAgIGdvb2cuYXNzZXJ0cy5mYWlsKFwidG9kbztcIik7XG5cdCAgICAgICAgY2FzZSBTWU0uc2luZ2xlX2lucHV0OlxuXHQgICAgICAgICAgICBnb29nLmFzc2VydHMuZmFpbChcInRvZG87XCIpO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIGdvb2cuYXNzZXJ0cy5mYWlsKFwidG9kbztcIik7XG5cdCAgICB9XG5cdH07XG5cblx0U2suYXN0RHVtcCA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICB2YXIgc3BhY2VzID0gZnVuY3Rpb24gKG4pIC8vIHRvZG87IGJsdXJnaFxuXHQgICAge1xuXHQgICAgICAgIHZhciBpO1xuXHQgICAgICAgIHZhciByZXQgPSBcIlwiO1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcblx0ICAgICAgICAgICAgcmV0ICs9IFwiIFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgfTtcblxuXHQgICAgdmFyIF9mb3JtYXQgPSBmdW5jdGlvbiAobm9kZSwgaW5kZW50KSB7XG5cdCAgICAgICAgdmFyIHJldDtcblx0ICAgICAgICB2YXIgZWxlbXNzdHI7XG5cdCAgICAgICAgdmFyIHg7XG5cdCAgICAgICAgdmFyIGVsZW1zO1xuXHQgICAgICAgIHZhciBmaWVsZHN0cjtcblx0ICAgICAgICB2YXIgZmllbGQ7XG5cdCAgICAgICAgdmFyIGF0dHJzO1xuXHQgICAgICAgIHZhciBmaWVsZGxlbjtcblx0ICAgICAgICB2YXIgYjtcblx0ICAgICAgICB2YXIgYTtcblx0ICAgICAgICB2YXIgaTtcblx0ICAgICAgICB2YXIgZmllbGRzO1xuXHQgICAgICAgIHZhciBuYW1lbGVuO1xuXHQgICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpbmRlbnQgKyBcIk5vbmVcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAobm9kZS5wcm90b3R5cGUgJiYgbm9kZS5wcm90b3R5cGUuX2FzdG5hbWUgIT09IHVuZGVmaW5lZCAmJiBub2RlLnByb3RvdHlwZS5faXNlbnVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpbmRlbnQgKyBub2RlLnByb3RvdHlwZS5fYXN0bmFtZSArIFwiKClcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAobm9kZS5fYXN0bmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIG5hbWVsZW4gPSBzcGFjZXMobm9kZS5fYXN0bmFtZS5sZW5ndGggKyAxKTtcblx0ICAgICAgICAgICAgZmllbGRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLl9maWVsZHMubGVuZ3RoOyBpICs9IDIpIC8vIGl0ZXJfZmllbGRzXG5cdCAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgIGEgPSBub2RlLl9maWVsZHNbaV07IC8vIGZpZWxkIG5hbWVcblx0ICAgICAgICAgICAgICAgIGIgPSBub2RlLl9maWVsZHNbaSArIDFdKG5vZGUpOyAvLyBmaWVsZCBnZXR0ZXIgZnVuY1xuXHQgICAgICAgICAgICAgICAgZmllbGRsZW4gPSBzcGFjZXMoYS5sZW5ndGggKyAxKTtcblx0ICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKFthLCBfZm9ybWF0KGIsIGluZGVudCArIG5hbWVsZW4gKyBmaWVsZGxlbildKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBhdHRycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkc1tpXTtcblx0ICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goZmllbGRbMF0gKyBcIj1cIiArIGZpZWxkWzFdLnJlcGxhY2UoL15cXHMrLywgXCJcIikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZpZWxkc3RyID0gYXR0cnMuam9pbihcIixcXG5cIiArIGluZGVudCArIG5hbWVsZW4pO1xuXHQgICAgICAgICAgICByZXR1cm4gaW5kZW50ICsgbm9kZS5fYXN0bmFtZSArIFwiKFwiICsgZmllbGRzdHIgKyBcIilcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoZ29vZy5pc0FycmF5TGlrZShub2RlKSkge1xuXHQgICAgICAgICAgICAvL1NrLmRlYnVnb3V0KFwiYXJyXCIsIG5vZGUubGVuZ3RoKTtcblx0ICAgICAgICAgICAgZWxlbXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgIHggPSBub2RlW2ldO1xuXHQgICAgICAgICAgICAgICAgZWxlbXMucHVzaChfZm9ybWF0KHgsIGluZGVudCArIFwiIFwiKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxlbXNzdHIgPSBlbGVtcy5qb2luKFwiLFxcblwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGluZGVudCArIFwiW1wiICsgZWxlbXNzdHIucmVwbGFjZSgvXlxccysvLCBcIlwiKSArIFwiXVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldCA9IFwiVHJ1ZVwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXQgPSBcIkZhbHNlXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKSB7XG5cdCAgICAgICAgICAgICAgICByZXQgPSBub2RlLnRwJHN0cigpLnY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSB7XG5cdCAgICAgICAgICAgICAgICByZXQgPSBub2RlW1wiJHJcIl0oKS52O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0ID0gXCJcIiArIG5vZGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGluZGVudCArIHJldDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gX2Zvcm1hdChub2RlLCBcIlwiKTtcblx0fTtcblxuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLmFzdEZyb21QYXJzZVwiLCBTay5hc3RGcm9tUGFyc2UpO1xuXHRnb29nLmV4cG9ydFN5bWJvbChcIlNrLmFzdER1bXBcIiwgU2suYXN0RHVtcCk7XG5cblxuXG5cdC8qIC0tLS0gL1VzZXJzL3JvYi9za3VscHR5L2xpYi9hZnRlcndvcmQuanMgLS0tLSAqLyBcblxuXHRmdW5jdGlvbiB3cmFwQXN0VGhpbmcoZngsIGFyZ3BvcywgZGVidWcpIHtcblx0XHRhcmdwb3MgPSBhcmdwb3MgfHwgMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24oeCkge1xuXHRcdFx0dmFyIG4gPSBhcmd1bWVudHNbYXJncG9zLTFdO1xuXHRcdFx0dmFyIHJlc3VsdCA9IGZ4LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcblx0XHRcdHJlc3VsdC5yYW5nZSA9IG4ucmFuZ2U7XG5cdFx0XHRyZXN1bHQuc3RyID0gbi5zdHI7XG5cdFx0XHRyZXN1bHQubG9jID0gbi5sb2M7XG5cdFx0XHRpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhuKTtcblx0XHRcdFx0Y29uc29sZS5sb2cocmVzdWx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fVxuXG5cdGFzdEZvckF0b20gPSB3cmFwQXN0VGhpbmcoYXN0Rm9yQXRvbSk7XG5cdGFzdEZvckNvbXBPcCA9IHdyYXBBc3RUaGluZyhhc3RGb3JDb21wT3ApO1xuXHRhc3RGb3JTdWl0ZSA9IHdyYXBBc3RUaGluZyhhc3RGb3JTdWl0ZSk7XG5cdGFzdEZvckV4Y2VwdENsYXVzZSA9IHdyYXBBc3RUaGluZyhhc3RGb3JFeGNlcHRDbGF1c2UpO1xuXHRhc3RGb3JEb3R0ZWROYW1lID0gd3JhcEFzdFRoaW5nKGFzdEZvckRvdHRlZE5hbWUpO1xuXHRhc3RGb3JEZWNvcmF0b3IgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yRGVjb3JhdG9yKTtcblx0YXN0Rm9yRGVjb3JhdG9ycyA9IHdyYXBBc3RUaGluZyhhc3RGb3JEZWNvcmF0b3JzKTtcblx0YXN0Rm9yRGVjb3JhdGVkID0gd3JhcEFzdFRoaW5nKGFzdEZvckRlY29yYXRlZCk7XG5cdGFzdEZvcldpdGhWYXIgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yV2l0aFZhcik7XG5cdGFzdEZvcldpdGhTdG10ID0gd3JhcEFzdFRoaW5nKGFzdEZvcldpdGhTdG10KTtcblx0YXN0Rm9yRXhlY1N0bXQgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yRXhlY1N0bXQpO1xuXHRhc3RGb3JJZlN0bXQgPSB3cmFwQXN0VGhpbmcoYXN0Rm9ySWZTdG10KTtcblx0YXN0Rm9yRXhwcmxpc3QgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yRXhwcmxpc3QpO1xuXHRhc3RGb3JEZWxTdG10ID0gd3JhcEFzdFRoaW5nKGFzdEZvckRlbFN0bXQpO1xuXHRhc3RGb3JHbG9iYWxTdG10ID0gd3JhcEFzdFRoaW5nKGFzdEZvckdsb2JhbFN0bXQpO1xuXHRhc3RGb3JBc3NlcnRTdG10ID0gd3JhcEFzdFRoaW5nKGFzdEZvckFzc2VydFN0bXQpO1xuXHRhc3RGb3JJbXBvcnRTdG10ID0gd3JhcEFzdFRoaW5nKGFzdEZvckltcG9ydFN0bXQpO1xuXHRhc3RGb3JUZXN0bGlzdENvbXAgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yVGVzdGxpc3RDb21wKTtcblx0YXN0Rm9yTGlzdGNvbXAgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yTGlzdGNvbXApO1xuXHRhc3RGb3JGYWN0b3IgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yRmFjdG9yKTtcblx0YXN0Rm9yRm9yU3RtdCA9IHdyYXBBc3RUaGluZyhhc3RGb3JGb3JTdG10KTtcblx0YXN0Rm9yVHJhaWxlciA9IHdyYXBBc3RUaGluZyhhc3RGb3JUcmFpbGVyKTtcblx0YXN0Rm9yRmxvd1N0bXQgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yRmxvd1N0bXQpO1xuXHRhc3RGb3JBcmd1bWVudHMgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yQXJndW1lbnRzKTtcblx0YXN0Rm9yRnVuY2RlZiA9IHdyYXBBc3RUaGluZyhhc3RGb3JGdW5jZGVmKTtcblx0YXN0Rm9yQ2xhc3NCYXNlcyA9IHdyYXBBc3RUaGluZyhhc3RGb3JDbGFzc0Jhc2VzKTtcblx0YXN0Rm9yQ2xhc3NkZWYgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yQ2xhc3NkZWYpO1xuXHRhc3RGb3JMYW1iZGVmID0gd3JhcEFzdFRoaW5nKGFzdEZvckxhbWJkZWYpO1xuXHRhc3RGb3JDb21wcmVoZW5zaW9uID0gd3JhcEFzdFRoaW5nKGFzdEZvckNvbXByZWhlbnNpb24pO1xuXHRhc3RGb3JJdGVyQ29tcCA9IHdyYXBBc3RUaGluZyhhc3RGb3JJdGVyQ29tcCk7XG5cdGFzdEZvckRpY3RDb21wID0gd3JhcEFzdFRoaW5nKGFzdEZvckRpY3RDb21wKTtcblx0YXN0Rm9yR2VuRXhwciA9IHdyYXBBc3RUaGluZyhhc3RGb3JHZW5FeHByKTtcblx0YXN0Rm9yU2V0Q29tcCA9IHdyYXBBc3RUaGluZyhhc3RGb3JTZXRDb21wKTtcblx0YXN0Rm9yV2hpbGVTdG10ID0gd3JhcEFzdFRoaW5nKGFzdEZvcldoaWxlU3RtdCk7XG5cdGFzdEZvckF1Z2Fzc2lnbiA9IHdyYXBBc3RUaGluZyhhc3RGb3JBdWdhc3NpZ24pO1xuXHRhc3RGb3JCaW5vcCA9IHdyYXBBc3RUaGluZyhhc3RGb3JCaW5vcCk7XG5cdGFzdEZvclRlc3RsaXN0ID0gd3JhcEFzdFRoaW5nKGFzdEZvclRlc3RsaXN0KTtcblx0YXN0Rm9yRXhwclN0bXQgPSB3cmFwQXN0VGhpbmcoYXN0Rm9yRXhwclN0bXQpO1xuXHRhc3RGb3JJZmV4cHIgPSB3cmFwQXN0VGhpbmcoYXN0Rm9ySWZleHByKTtcblx0YXN0Rm9yRXhwciA9IHdyYXBBc3RUaGluZyhhc3RGb3JFeHByKTtcblx0U2suYXN0RnJvbVBhcnNlID0gd3JhcEFzdFRoaW5nKFNrLmFzdEZyb21QYXJzZSwgMSk7XG5cblx0U2submFtZUZvclRva2VuID0gZnVuY3Rpb24odikge1xuXHRcdGlmICggdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgKSByZXR1cm4gdjtcblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBTay5Ub2tlbml6ZXIuVG9rZW5zICkge1xuXHRcdFx0aWYgKCBTay5Ub2tlbml6ZXIuVG9rZW5zW25hbWVdID09IHYgKSByZXR1cm4gbmFtZTtcblx0XHR9XG5cdFx0aWYgKCB2IGluIFNrLlBhcnNlVGFibGVzLm51bWJlcjJzeW1ib2wgKSB7XG5cdFx0XHRyZXR1cm4gU2suUGFyc2VUYWJsZXMubnVtYmVyMnN5bWJvbFt2XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJz8/PzonICsgdjtcblx0fTtcblxuXHQvL1NrLnB5dGhvbjMgPSB0cnVlO1xuXHRTay5QYXJzZXIgPSBQYXJzZXI7XG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnY7IH07XG5cdFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52OyB9O1xuXG5cdFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IgPSBmdW5jdGlvbihzdHIsIGZpbGUsIGxpbmUsIGN0eCwgZXh0cmEpIHtcblx0XHR2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKHN0ciwgZmlsZSwgbGluZSk7XG5cdFx0ZXJyLmNvbnRleHQgPSBjdHg7XG5cdFx0ZXJyLmV4dHJhID0gZXh0cmE7XG5cdFx0ZXJyLmxpbmUgPSBsaW5lO1xuXHRcdHJldHVybiBlcnI7XG5cdH07XG5cblx0U2suYnVpbHRpbi5JbmRlbnRhdGlvbkVycm9yID0gZnVuY3Rpb24oc3RyLCBmaWxlLCBsaW5lLCByb3csIGV4dHJhKSB7XG5cdFx0dmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcignSW5kZW50YXRpb24gRXJyb3I6ICcgKyBzdHIsIGZpbGUsIGxpbmUpO1xuXHRcdGVyci5jb250ZXh0ID0gW1tsaW5lLCByb3ddLCBbbGluZSwgcm93XV07XG5cdFx0ZXJyLmV4dHJhID0ge1xuXHRcdH07XG5cdFx0ZXJyLmxpbmUgPSBsaW5lO1xuXHRcdHJldHVybiBlcnI7XG5cdH07XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IFNrO1xuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5cdC8vVE9ETzogRmluZCBhIHdheSB0byBub3QgaGF2ZSB0byBkbyB0aGlzLlxuXHRmdW5jdGlvbiBnZXRPcE5hbWUob3ApIHtcblx0XHRpZiAob3AucHJvdG90eXBlLl9hc3RuYW1lKSB7XG5cdFx0XHRyZXR1cm4gb3AucHJvdG90eXBlLl9hc3RuYW1lO1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VkbG50IGRlY29kZSBvcGVyYXRvciBuYW1lIGZvcjogXCIgKyAob3AubmFtZSB8fCBvcC50b1N0cmluZygpKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBhYm9ydCh3aHkpIHtcblx0XHRjb25zb2xlLmxvZyhuZXcgRXJyb3IoXCJBQk9SVDpcIiArIHdoeSkuc3RhY2spO1xuXHRcdHRocm93IG5ldyBFcnJvcih3aHkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNFeHByZXNzaW9uKG4pIHtcblx0XHRyZXR1cm4gL0V4cHJlc3Npb24kLy50ZXN0KG4udHlwZSk7XG5cdH1cblxuXHR2YXIgaWR4ID0gMDtcblx0ZnVuY3Rpb24gY3JlYXRlVGVtcE5hbWUoaGludCkge1xuXHRcdHJldHVybiAnX190ZW1wJCcgKyBoaW50ICsgJyQnICsgaWR4Kys7XG5cdH1cblxuXHRmdW5jdGlvbiBlbnN1cmVTdGF0ZW1lbnQocykge1xuXHRcdHZhciBmID0gcztcblx0XHRpZiAoICFpc0FycmF5KHMpICkgZiA9IFtmXTtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmLmxlbmd0aDsgKytpICkge1xuXHRcdFx0dmFyIHYgPSBmW2ldO1xuXHRcdFx0aWYgKCBpc0V4cHJlc3Npb24odikgKSB7XG5cdFx0XHRcdGZbaV0gPSB7dHlwZTogXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIGV4cHJlc3Npb246IHZ9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggaXNBcnJheShzKSApIHJldHVybiBzO1xuXHRcdGVsc2UgcmV0dXJuIGZbMF07XG5cdH1cblxuXHRmdW5jdGlvbiBpZGVudChuKSB7XG5cdFx0cmV0dXJuIHt0eXBlOiBcIklkZW50aWZpZXJcIiwgbmFtZTogbi52YWx1ZU9mKCl9O1xuXHR9XG5cblx0ZnVuY3Rpb24gbWVtYmVyKG8sIHApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogXCJNZW1iZXJFeHByZXNzaW9uXCIsXG5cdFx0XHRvYmplY3Q6IG8sXG5cdFx0XHRwcm9wZXJ0eTogcCxcblx0XHRcdGNvbXB1dGVkOiBmYWxzZVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBsaXRlcmFsKHYpIHtcblx0XHRpZiAoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHYgPSB2LnZhbHVlT2YoKTtcblxuXHRcdGlmICggdHlwZW9mIHYgPT09ICdudW1iZXInICYmICgxIC8gdiAhPT0gMSAvIE1hdGguYWJzKHYpKSApIHtcblx0XHRcdHJldHVybiB7dHlwZTogXCJVbmFyeUV4cHJlc3Npb25cIiwgYXJndW1lbnQ6IGxpdGVyYWwoLXYpLCBvcGVyYXRvcjogJy0nIH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHt0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IHYsIHJhdzogSlNPTi5zdHJpbmdpZnkodil9O1xuXHR9XG5cblx0ZnVuY3Rpb24gYmluT3AobGVmdCwgb3AsIHJpZ2h0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiQmluYXJ5RXhwcmVzc2lvblwiLFxuXHRcdFx0bGVmdDogbGVmdCxcblx0XHRcdHJpZ2h0OiByaWdodCxcblx0XHRcdG9wZXJhdG9yOiBvcFxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBsb2dpY09wKGxlZnQsIG9wLCByaWdodCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcIkxvZ2ljYWxFeHByZXNzaW9uXCIsXG5cdFx0XHRsZWZ0OiBsZWZ0LFxuXHRcdFx0cmlnaHQ6IHJpZ2h0LFxuXHRcdFx0b3BlcmF0b3I6IG9wXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRlcm5hcnkoY29uZCwgYSwgYikge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLFxuXHRcdFx0dGVzdDogY29uZCxcblx0XHRcdGNvbnNlcXVlbnQ6IGEsXG5cdFx0XHRhbHRlcm5hdGU6IGJcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdmFyXyhuYW1lLCBpbml0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxuXHRcdFx0a2luZDogJ3ZhcicsXG5cdFx0XHRkZWNsYXJhdGlvbnM6IFt7XG5cdFx0XHRcdHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXG5cdFx0XHRcdGlkOiBuYW1lLFxuXHRcdFx0XHRpbml0OiBpbml0ID8gaW5pdCA6IHVuZGVmaW5lZFxuXHRcdFx0fV1cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIGN0eCkge1xuXHRcdC8vY29uc29sZS5sb2cobm9kZS5saW5lbm8sIG5vZGUuY29sX29mZnNldCk7XG5cdFx0dmFyIHJlc3VsdCA9IGRpc3BhdGNoKG5vZGUsIGN0eCk7XG5cdFx0aWYgKCBub2RlLnJhbmdlICkgcmVzdWx0LnJhbmdlID0gW25vZGUucmFuZ2VbMF0sIG5vZGUucmFuZ2VbMV1dO1xuXHRcdGlmICggbm9kZS5sb2MgKSByZXN1bHQubG9jID0gbm9kZS5sb2M7XG5cdFx0cmVzdWx0LnN0ciA9IG5vZGUuc3RyO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwYXRjaChub2RlLCBjdHgpIHtcblx0XHRpZiAoICFjdHgubG9jYWxzICkgY3R4LmxvY2FscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0XHRpZiAoICFub2RlICkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJXQVQhXCIsIG5ldyBFcnJvcigpLnN0YWNrKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIldoYXQ/XCIpO1xuXHRcdH1cblx0XHRpZiAoIGlzQXJyYXkobm9kZSkgKSB7XG5cdFx0XHR2YXIgYm9keSA9IFtdO1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7ICsraSApIHtcblx0XHRcdFx0dmFyIHIgPSB0cmFuc2Zvcm0obm9kZVtpXSwgY3R4KTtcblx0XHRcdFx0aWYgKCBpc0FycmF5KHIpICkgYm9keS5wdXNoLmFwcGx5KGJvZHksIHIpO1xuXHRcdFx0XHRlbHNlIGJvZHkucHVzaChyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib2R5O1xuXHRcdH1cblx0XHRzd2l0Y2ggKG5vZGUuX2FzdG5hbWUpIHtcblx0XHRcdGNhc2UgJ0F0dHJpYnV0ZSc6IHJldHVybiB0cmFuc2Zvcm1BdHRyaWJ1dGUobm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ0Fzc2lnbic6IHJldHVybiB0cmFuc2Zvcm1Bc3NpZ24obm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ0F1Z0Fzc2lnbic6IHJldHVybiB0cmFuc2Zvcm1BdWdBc3NpZ24obm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ0Jpbk9wJzogcmV0dXJuIHRyYW5zZm9ybUJpbk9wKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdCb29sT3AnOiByZXR1cm4gdHJhbnNmb3JtQm9vbE9wKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdCcmVhayc6IHJldHVybiB0cmFuc2Zvcm1CcmVhayhub2RlLCBjdHgpO1xuXHRcdFx0Y2FzZSAnQ2FsbCc6IHJldHVybiB0cmFuc2Zvcm1DYWxsKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdDbGFzc0RlZic6IHJldHVybiB0cmFuc2Zvcm1DbGFzc0RlZihub2RlLCBjdHgpO1xuXHRcdFx0Y2FzZSAnQ29udGludWUnOiByZXR1cm4gdHJhbmZvcm1Db250aW51ZShub2RlLCBjdHgpO1xuXHRcdFx0Y2FzZSAnQ29tcGFyZSc6IHJldHVybiB0cmFuc2Zvcm1Db21wYXJlKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdEaWN0JzogcmV0dXJuIHRyYW5zZm9ybURpY3Qobm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ0RlbGV0ZSc6IHJldHVybiB0cmFuc2Zvcm1EZWwobm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ0V4cHInOiByZXR1cm4gdHJhbnNmb3JtRXhwcihub2RlLCBjdHgpO1xuXHRcdFx0Y2FzZSAnRm9yJzogcmV0dXJuIHRyYW5zZm9ybUZvcihub2RlLCBjdHgpO1xuXHRcdFx0Y2FzZSAnRnVuY3Rpb25EZWYnOiByZXR1cm4gdHJhbnNmb3JtRnVuY3Rpb25EZWYobm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ0dlbmVyYXRvckV4cCc6IHJldHVybiB0cmFuc2Zvcm1MaXN0Q29tcChub2RlLCBjdHgpOyAvL1RPRE86IE1ha2UgdGhpcyBzZXBlcmF0ZVxuXHRcdFx0Y2FzZSAnR2xvYmFsJzogcmV0dXJuIHRyYW5zZm9ybUdsb2JhbChub2RlLCBjdHgpO1xuXHRcdFx0Y2FzZSAnSWYnOiByZXR1cm4gdHJhbnNmb3JtSWYobm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ0ltcG9ydCc6IHJldHVybiBOb09wKCk7XG5cdFx0XHRjYXNlICdMYW1iZGEnOiByZXR1cm4gdHJhbnNmb3JtTGFtYmRhKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdMaXN0JzogcmV0dXJuIHRyYW5zZm9ybUxpc3Qobm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ0xpc3RDb21wJzogcmV0dXJuIHRyYW5zZm9ybUxpc3RDb21wKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdNb2R1bGUnOiByZXR1cm4gdHJhbnNmb3JtTW9kdWxlKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdOYW1lJzogcmV0dXJuIHRyYW5zZm9ybU5hbWUobm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ1ByaW50JzogcmV0dXJuIHRyYW5zZm9ybVByaW50KG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdSZXR1cm4nOiByZXR1cm4gdHJhbnNmb3JtUmV0dXJuKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdTdHInOiByZXR1cm4gdHJhbnNmb3JtU3RyKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdTdWJzY3JpcHQnOiByZXR1cm4gdHJhbnNmb3JtU3Vic2NyaXB0KG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdUdXBsZSc6IHJldHVybiB0cmFuc2Zvcm1UdXBsZShub2RlLCBjdHgpO1xuXHRcdFx0Y2FzZSAnTnVtJzogcmV0dXJuIHRyYW5zZm9ybU51bShub2RlLCBjdHgpO1xuXHRcdFx0Y2FzZSAnUGFzcyc6IHJldHVybiB0cmFuc2Zvcm1QYXNzKG5vZGUsIGN0eCk7XG5cdFx0XHRjYXNlICdVbmFyeU9wJzogcmV0dXJuIHRyYW5zZm9ybVVuYXJ5T3Aobm9kZSwgY3R4KTtcblx0XHRcdGNhc2UgJ1doaWxlJzogcmV0dXJuIHRyYW5zZm9ybVdoaWxlKG5vZGUsIGN0eCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkRvbnQga25vdyBob3cgdG8gdHJhbnNmb3JtOiBcIiArIG5vZGUuX2FzdG5hbWUpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShub2RlLCBudWxsLCAnICAnKSk7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRvbnQga25vdyBob3cgdG8gdHJhbnNmb3JtOiBcIiArIG5vZGUuX2FzdG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIE5vT3AoKSB7IHJldHVybiBbXTsgfVxuXG5cblxuXHRmdW5jdGlvbiBtYWtlVmFyaWFibGVOYW1lKG5hbWUpIHtcblx0XHR2YXIgcGFydHMgPSBBcnJheS5pc0FycmF5KG5hbWUpID8gbmFtZSA6IG5hbWUuc3BsaXQoL1xcLi9nKTtcblx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiBpZGVudChuYW1lKTtcblx0XHR2YXIgcHJvcCA9IHBhcnRzLnBvcCgpO1xuXHRcdHJldHVybiBtZW1iZXIobWFrZVZhcmlhYmxlTmFtZShwYXJ0cyksIGlkZW50KHByb3ApKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybUF0dHJpYnV0ZShub2RlLCBjdHgpIHtcblx0XHR2YXIgbiA9IG5vZGUuYXR0cjtcblx0XHRpZiAoIG4uX2FzdG5hbWUgKSBuID0gdHJhbnNmb3JtKG4sIGN0eCk7XG5cdFx0ZWxzZSBuID0ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogbi52YWx1ZU9mKCl9O1xuXHRcdHJldHVybiBtZW1iZXIodHJhbnNmb3JtKG5vZGUudmFsdWUsIGN0eCksIG4pO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtQXVnQXNzaWduKG5vZGUsIGN0eCkge1xuXHRcdC8vVE9ETzogV2UgbmVlZCB0byBub3QgaW5qZWN0IGxlZnQgaW50byB0aGUgY29kZSB0d2ljZVxuXHRcdC8vYXMgaXQgY291bGQgaGF2ZSBzaWRlIGVmZmVjdHMuXG5cdFx0dmFyIHJpZ2h0ID0gdHJhbnNmb3JtKG5vZGUudmFsdWUsIGN0eCk7XG5cdFx0dmFyIGxlZnQgPSB0cmFuc2Zvcm0obm9kZS50YXJnZXQsIGN0eCk7XG5cdFx0dmFyIHRuID0gY3JlYXRlVGVtcE5hbWUoXCJsZWZ0XCIpO1xuXHRcdHZhciBvcE5hbWUgPSBnZXRPcE5hbWUobm9kZS5vcCk7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHZhcl8oaWRlbnQodG4pLCBsZWZ0KSxcblx0XHRcdGVuc3VyZVN0YXRlbWVudCh7XG5cdFx0XHRcdHR5cGU6IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIixcblx0XHRcdFx0b3BlcmF0b3I6ICc9Jyxcblx0XHRcdFx0bGVmdDogbGVmdCxcblx0XHRcdFx0cmlnaHQ6IGNyZWF0ZUJpbk9wKGxlZnQsIG9wTmFtZSwgcmlnaHQpXG5cdFx0XHR9KVxuXHRcdF07XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1Bc3NpZ24obm9kZSwgY3R4KSB7XG5cblx0XHR2YXIgcmVzdWx0cyA9IFtdO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGUudGFyZ2V0cy5sZW5ndGg7ICsraSApIHtcblx0XHRcdHZhciBsZWZ0ID0gbm9kZS50YXJnZXRzW2ldO1xuXHRcdFx0aWYgKCBjdHgud3JpdGVUYXJnZXQgKSB7XG5cdFx0XHRcdGxlZnQgPSBtZW1iZXIoY3R4LndyaXRlVGFyZ2V0LCB0cmFuc2Zvcm0obGVmdCxjdHgpKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLGNyZWF0ZVR1cGxlVW5wYWNraW5nQXNzaWduKGxlZnQsIHRyYW5zZm9ybShub2RlLnZhbHVlLCBjdHgpLCBjdHgpKTtcblx0XHRcblx0XHR9XG5cdFx0aWYgKCByZXN1bHRzLmxlbmd0aCA9PSAxICkgcmV0dXJuIHJlc3VsdHNbMF07XG5cdFx0cmV0dXJuIHt0eXBlOiBcIkJsb2NrU3RhdGVtZW50XCIsIGJvZHk6IHJlc3VsdHN9OyBcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJpbk9wKGxlZnQsIG9wLCByaWdodCkge1xuXG5cdFx0aWYgKCBvcCA9PT0gJ0Zsb29yRGl2JyApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdFx0Y2FsbGVlOiBtYWtlVmFyaWFibGVOYW1lKCdNYXRoLmZsb29yJyksXG5cdFx0XHRcdGFyZ3VtZW50czogW3tcblx0XHRcdFx0XHR0eXBlOiBcIkJpbmFyeUV4cHJlc3Npb25cIixcblx0XHRcdFx0XHRsZWZ0OiBsZWZ0LFxuXHRcdFx0XHRcdHJpZ2h0OiByaWdodCxcblx0XHRcdFx0XHRvcGVyYXRvcjogJy8nXG5cdFx0XHRcdH1dXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHZhciBmeE9wcyA9IHtcblx0XHRcdFwiQWRkXCI6IFwiX19weXRob25SdW50aW1lLm9wcy5hZGRcIixcblx0XHRcdFwiTXVsdFwiOiBcIl9fcHl0aG9uUnVudGltZS5vcHMubXVsdGlwbHlcIixcblx0XHRcdFwiUG93XCI6IFwiTWF0aC5wb3dcIlxuXHRcdH07XG5cblx0XHRpZiAoIG9wIGluIGZ4T3BzICApIHtcblx0XHRcdHZhciBjYWxsID0ge1xuXHRcdFx0XHR0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCIsXG5cdFx0XHRcdGNhbGxlZTogbWFrZVZhcmlhYmxlTmFtZShmeE9wc1tvcF0pLFxuXHRcdFx0XHRhcmd1bWVudHM6IFtsZWZ0LCByaWdodF1cblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gY2FsbDtcblx0XHR9XG5cblx0XHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdFx0XCJBZGRcIjogXCIrXCIsXG5cdFx0XHRcIlN1YlwiOiBcIi1cIixcblx0XHRcdFwiTW9kXCI6IFwiJVwiLFxuXHRcdFx0XCJEaXZcIjogXCIvXCIsXG5cdFx0XHRcIkJpdEFuZFwiOiBcIiZcIixcblx0XHRcdFwiQml0T3JcIjogXCJ8XCIsXG5cdFx0XHQnQml0WG9yJzogJ14nLFxuXHRcdFx0XCJMU2hpZnRcIjogXCI8PFwiLFxuXHRcdFx0XCJSU2hpZnRcIjogXCI+PlwiXG5cblx0XHR9O1xuXG5cdFx0aWYgKCAhKG9wIGluIG9wZXJhdG9ycykgKSBhYm9ydChcIlVua25vd24gYmluYXJ5IG9wZXJhdG9yOiBcIiArIG9wKTtcblxuXHRcdHJldHVybiBiaW5PcChsZWZ0LCBvcGVyYXRvcnNbb3BdLCByaWdodCk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1CaW5PcChub2RlLCBjdHgpIHtcblx0XHR2YXIgbGVmdCA9IHRyYW5zZm9ybShub2RlLmxlZnQsIGN0eCk7XG5cdFx0dmFyIHJpZ2h0ID0gdHJhbnNmb3JtKG5vZGUucmlnaHQsIGN0eCk7XG5cdFx0cmV0dXJuIGNyZWF0ZUJpbk9wKGxlZnQsIGdldE9wTmFtZShub2RlLm9wKSwgcmlnaHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtQm9vbE9wKG5vZGUsIGN0eCkge1xuXHRcdHZhciBmdmFscyA9IG5ldyBBcnJheShub2RlLnZhbHVlcy5sZW5ndGgpO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGUudmFsdWVzLmxlbmd0aDsgKytpICkge1xuXHRcdFx0ZnZhbHNbaV0gPSB0cmFuc2Zvcm0obm9kZS52YWx1ZXNbaV0sIGN0eCk7XG5cdFx0fVxuXHRcdHZhciBvcE5hbWUgPSBnZXRPcE5hbWUobm9kZS5vcCk7XG5cdFx0dmFyIG9wZXJhdG9ycyA9IHtcblx0XHRcdCdBbmQnOiAnJiYnLFxuXHRcdFx0J09yJzogJ3x8J1xuXHRcdH07XG5cblx0XHRpZiAoICEob3BOYW1lIGluIG9wZXJhdG9ycyApICkgYWJvcnQoXCJVbmtub3duIGJvb2wgb3BlYXJ0b3I6IFwiICsgb3BOYW1lKTtcblx0XHR2YXIgb3BzdHIgPSBvcGVyYXRvcnNbb3BOYW1lXTtcblxuXHRcdHZhciByZXN1bHQgPSBmdmFscy5wb3AoKTtcblx0XHR3aGlsZSAoIGZ2YWxzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRyZXN1bHQgPSBsb2dpY09wKGZ2YWxzLnBvcCgpLCBvcHN0ciwgcmVzdWx0KTtcblx0XHR9XG5cblxuXHRcdC8vVE9ETzogU3VwcG9ydCB8fCBhcyB3ZWxsP1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1CcmVhayhub2RlLCBjdHgpIHtcblx0XHRyZXR1cm4ge3R5cGU6IFwiQnJlYWtTdGF0ZW1lbnRcIn07XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1DYWxsKG5vZGUsIGN0eCkge1xuXHRcdHZhciBidWlsdGlucyA9IFsnbGVuJ107XG5cdFx0aWYgKCBub2RlLmZ1bmMuX2FzdG5hbWUgPT0gJ05hbWUnICkge1xuXHRcdFx0c3dpdGNoICggbm9kZS5mdW5jLmlkLnYgKSB7XG5cdFx0XHRcdGNhc2UgJ2xlbic6XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLFxuXHRcdFx0XHRcdFx0b2JqZWN0OiB0cmFuc2Zvcm0obm9kZS5hcmdzWzBdLCBjdHgpLFxuXHRcdFx0XHRcdFx0cHJvcGVydHk6IHt0eXBlOiBcIklkZW50aWZpZXJcIiwgbmFtZTogXCJsZW5ndGhcIn1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRjYXNlICdhbGwnOiBjYXNlICdvcmQnOlxuXHRcdFx0XHRjYXNlICdzdW0nOiBjYXNlICdhbnknOlxuXHRcdFx0XHRjYXNlICdzdHInOiBjYXNlICdjaHInOlxuXHRcdFx0XHRjYXNlICdhc2NpaSc6IGNhc2UgJ2Rpdm1vZCc6XG5cdFx0XHRcdGNhc2UgJ3JhbmdlJzogY2FzZSAnZW51bWVyYXRlJzpcblx0XHRcdFx0Y2FzZSAncm91bmQnOiBjYXNlICdmaWx0ZXInOlxuXHRcdFx0XHRjYXNlICdhYnMnOiBjYXNlICdmbG9hdCc6XG5cdFx0XHRcdGNhc2UgJ2ludCc6IGNhc2UgJ2hleCc6XG5cdFx0XHRcdGNhc2UgJ3R1cGxlJzogY2FzZSAgJ21hcCc6XG5cdFx0XHRcdGNhc2UgJ2Jvb2wnOiBjYXNlICdtYXgnOlxuXHRcdFx0XHRjYXNlICdzb3J0ZWQnOiBjYXNlICdtaW4nOlxuXHRcdFx0XHRjYXNlICdsaXN0JzogY2FzZSAnb2N0Jzpcblx0XHRcdFx0Y2FzZSAncG93JzogY2FzZSAgJ3JldmVyc2VkJzpcblx0XHRcdFx0Y2FzZSAncmVwcic6XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6ICdDYWxsRXhwcmVzc2lvbicsXG5cdFx0XHRcdFx0XHRjYWxsZWU6IG1ha2VWYXJpYWJsZU5hbWUoJ19fcHl0aG9uUnVudGltZS5mdW5jdGlvbnMuJyArIG5vZGUuZnVuYy5pZC52KSxcblx0XHRcdFx0XHRcdGFyZ3VtZW50czogdHJhbnNmb3JtKG5vZGUuYXJncywgY3R4KVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdGNhc2UgJ2RpY3QnOlxuXHRcdFx0XHRcdHZhciBhcmdzID0gW107XG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZS5rZXl3b3Jkcy5sZW5ndGg7ICsraSApIHtcblx0XHRcdFx0XHRcdGFyZ3MucHVzaCh7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlFeHByZXNzaW9uXCIsXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzOiBbXG5cdFx0XHRcdFx0XHRcdFx0bGl0ZXJhbChub2RlLmtleXdvcmRzW2ldLmFyZy52KSxcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm0obm9kZS5rZXl3b3Jkc1tpXS52YWx1ZSwgY3R4KVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiTmV3RXhwcmVzc2lvblwiLFxuXHRcdFx0XHRcdFx0Y2FsbGVlOiBtYWtlVmFyaWFibGVOYW1lKCdfX3B5dGhvblJ1bnRpbWUub2JqZWN0cy5kaWN0JyksXG5cdFx0XHRcdFx0XHRhcmd1bWVudHM6IGFyZ3Ncblx0XHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGFyZ3MgPSB0cmFuc2Zvcm0obm9kZS5hcmdzLCBjdHgpO1xuXG5cdFx0aWYgKCBub2RlLmtleXdvcmRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHR2YXIgcGFyYW1zRGljdCA9IHtcblx0XHRcdFx0dHlwZTogXCJPYmplY3RFeHByZXNzaW9uXCIsXG5cdFx0XHRcdHByb3BlcnRpZXM6IFt7XG5cdFx0XHRcdFx0dHlwZTogXCJQcm9wZXJ0eVwiLFxuXHRcdFx0XHRcdGtleTogaWRlbnQoXCJfX2t3cFwiKSxcblx0XHRcdFx0XHR2YWx1ZTogbGl0ZXJhbCh0cnVlKVxuXHRcdFx0XHR9XVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZS5rZXl3b3Jkcy5sZW5ndGg7ICsraSApIHtcblx0XHRcdFx0dmFyIGsgPSBub2RlLmtleXdvcmRzW2ldO1xuXHRcdFx0XHRwYXJhbXNEaWN0LnByb3BlcnRpZXMucHVzaCh7XG5cdFx0XHRcdFx0dHlwZTogXCJQcm9wZXJ0eVwiLFxuXHRcdFx0XHRcdGtleTogaWRlbnQoay5hcmcudiksXG5cdFx0XHRcdFx0dmFsdWU6IHRyYW5zZm9ybShrLnZhbHVlLCBjdHgpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXh0cmFBcmcgPSB7XG5cdFx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdFx0Y2FsbGVlOiBtYWtlVmFyaWFibGVOYW1lKCdfX3B5dGhvblJ1bnRpbWUudXRpbHMuY3JlYXRlUGFyYW1zT2JqJyksXG5cdFx0XHRcdGFyZ3VtZW50czogW3BhcmFtc0RpY3RdXG5cdFx0XHR9O1xuXG5cdFx0XHRhcmdzLnB1c2goZXh0cmFBcmcpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCIsXG5cdFx0XHRjYWxsZWU6IHRyYW5zZm9ybShub2RlLmZ1bmMsIGN0eCksXG5cdFx0XHRhcmd1bWVudHM6IGFyZ3Ncblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtQ2xhc3NEZWYobm9kZSwgY3R4KSB7XG5cdFx0dmFyIGJvZHkgPSBbXTtcblx0XHR2YXIgcHJvdG8gPSBtZW1iZXIoaWRlbnQobm9kZS5uYW1lKSwgaWRlbnQoJ3Byb3RvdHlwZScpKTtcblx0XHR2YXIgbmN0eCA9IHtcblx0XHRcdHdyaXRlVGFyZ2V0OiBwcm90byxcblx0XHRcdGluQ2xhc3M6IHRydWUsXG5cdFx0XHRsb2NhbHM6IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHR9O1xuXG5cdFx0aWYgKCBub2RlLmJhc2VzLmxlbmd0aCA+IDEgKSBhbGVydChcIk11bHRpcGxlIGJhc2UgY2xhc3NlcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuXHRcdHZhciBiYXNlID0gKG5vZGUuYmFzZXMubGVuZ3RoID4gMCkgPyB0cmFuc2Zvcm0obm9kZS5iYXNlc1swXSwgY3R4KSA6IHVuZGVmaW5lZDtcblxuXHRcdHZhciBjdG9yQm9keSA9IFtdO1xuXHRcdGN0b3JCb2R5LnB1c2goe1xuXHRcdFx0dHlwZTogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5cdFx0XHRraW5kOiAndmFyJyxcblx0XHRcdGRlY2xhcmF0aW9uczogW3tcblx0XHRcdFx0dHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIixcblx0XHRcdFx0aWQ6IGlkZW50KCd0aGF0JyksXG5cdFx0XHRcdGluaXQ6IHt0eXBlOiBcIlRoaXNFeHByZXNzaW9uXCJ9XG5cdFx0XHR9XVxuXHRcdH0pO1xuXG5cdFx0Y3RvckJvZHkucHVzaCh7XG5cdFx0XHR0eXBlOiBcIklmU3RhdGVtZW50XCIsXG5cdFx0XHR0ZXN0OiB7XG5cdFx0XHRcdHR5cGU6XCJVbmFyeUV4cHJlc3Npb25cIixcblx0XHRcdFx0YXJndW1lbnQ6IGJpbk9wKGlkZW50KCd0aGF0JyksIFwiaW5zdGFuY2VvZlwiLCBpZGVudChub2RlLm5hbWUpKSxcblx0XHRcdFx0b3BlcmF0b3I6IFwiIVwiXG5cdFx0XHR9LFxuXHRcdFx0Y29uc2VxdWVudDogZW5zdXJlU3RhdGVtZW50KHtcblx0XHRcdFx0dHlwZTogXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFxuXHRcdFx0XHRsZWZ0OiBpZGVudCgndGhhdCcpLFxuXHRcdFx0XHRyaWdodDoge1xuXHRcdFx0XHRcdHR5cGU6ICBcIkNhbGxFeHByZXNzaW9uXCIsXG5cdFx0XHRcdFx0Y2FsbGVlOiBtYWtlVmFyaWFibGVOYW1lKCdPYmplY3QuY3JlYXRlJyksXG5cdFx0XHRcdFx0YXJndW1lbnRzOiBbIHByb3RvIF1cblx0XHRcdFx0fSxcblx0XHRcdFx0b3BlcmF0b3I6ICc9J1xuXHRcdFx0fSlcblx0XHR9KTtcblxuXHRcdGN0b3JCb2R5LnB1c2goe1xuXHRcdFx0dHlwZTogXCJJZlN0YXRlbWVudFwiLFxuXHRcdFx0dGVzdDoge1xuXHRcdFx0XHR0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCIsXG5cdFx0XHRcdGNhbGxlZTogbWVtYmVyKHByb3RvLCBpZGVudCgnaGFzT3duUHJvcGVydHknKSksXG5cdFx0XHRcdGFyZ3VtZW50czogW2xpdGVyYWwoJ19faW5pdF9fJyldXG5cdFx0XHR9LFxuXHRcdFx0Y29uc2VxdWVudDogZW5zdXJlU3RhdGVtZW50KHtcblx0XHRcdFx0dHlwZTogXCJDYWxsRXhwcmVzc2lvblwiLFxuXHRcdFx0XHRjYWxsZWU6IG1lbWJlcihtZW1iZXIocHJvdG8sIGlkZW50KCdfX2luaXRfXycpKSwgaWRlbnQoJ2FwcGx5JykpLFxuXHRcdFx0XHRhcmd1bWVudHM6IFtpZGVudCgndGhhdCcpLCBpZGVudCgnYXJndW1lbnRzJyldXG5cdFx0XHR9KVxuXHRcdH0pO1xuXG5cdFx0aWYgKCBiYXNlICkge1xuXHRcdFx0Y3RvckJvZHkucHVzaChlbnN1cmVTdGF0ZW1lbnQoe1xuXHRcdFx0XHR0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCIsXG5cdFx0XHRcdGNhbGxlZToge1xuXHRcdFx0XHRcdHR5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLFxuXHRcdFx0XHRcdG9iamVjdDogYmFzZSxcblx0XHRcdFx0XHRwcm9wZXJ0eTogaWRlbnQoJ2FwcGx5JyksXG5cdFx0XHRcdFx0Y29tcHV0ZWQ6IGZhbHNlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFyZ3VtZW50czogW2lkZW50KCd0aGF0JyksIGlkZW50KCdhcmd1bWVudHMnKV1cblx0XHRcdH0pKTtcblx0XHR9XG5cblx0XHRjdG9yQm9keS5wdXNoKHtcblx0XHRcdHR5cGU6IFwiUmV0dXJuU3RhdGVtZW50XCIsXG5cdFx0XHRhcmd1bWVudDogaWRlbnQoJ3RoYXQnKVxuXHRcdH0pO1xuXG5cblx0XHRib2R5LnB1c2goe1xuXHRcdFx0dHlwZTogXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsXG5cdFx0XHRpZDogaWRlbnQobm9kZS5uYW1lKSxcblx0XHRcdHBhcmFtczogW10sXG5cdFx0XHRib2R5OiB7dHlwZTogXCJCbG9ja1N0YXRlbWVudFwiLCBib2R5OmN0b3JCb2R5fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCBiYXNlICkge1xuXHRcdFx0Ym9keS5wdXNoKHtcblx0XHRcdFx0dHlwZTogXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFxuXHRcdFx0XHRsZWZ0OiBwcm90byxcblx0XHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0XHR0eXBlOiAgXCJDYWxsRXhwcmVzc2lvblwiLFxuXHRcdFx0XHRcdGNhbGxlZTogbWFrZVZhcmlhYmxlTmFtZSgnT2JqZWN0LmNyZWF0ZScpLFxuXHRcdFx0XHRcdGFyZ3VtZW50czogWyBtZW1iZXIoYmFzZSwgaWRlbnQoJ3Byb3RvdHlwZScpKSBdXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9wZXJhdG9yOiBcIj1cIlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ym9keSA9IGJvZHkuY29uY2F0KHRyYW5zZm9ybShub2RlLmJvZHksIG5jdHgpKTtcblxuXHRcdGJvZHkucHVzaCh7XG5cdFx0XHR0eXBlOiBcIlJldHVyblN0YXRlbWVudFwiLFxuXHRcdFx0YXJndW1lbnQ6IGlkZW50KG5vZGUubmFtZSlcblx0XHR9KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5cdFx0XHRcImRlY2xhcmF0aW9uc1wiOiBbXG5cdFx0XHR7XG5cdFx0XHQgIFwidHlwZVwiOiBcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFxuXHRcdFx0ICBcImlkXCI6IGlkZW50KG5vZGUubmFtZSksXG5cdFx0XHQgIFwiaW5pdFwiOiB7XG5cdFx0XHQgIFx0dHlwZTogXCJDYWxsRXhwcmVzc2lvblwiLFxuXHRcdFx0ICBcdGNhbGxlZToge1xuXHRcdFx0ICBcdFx0dHlwZTogXCJGdW5jdGlvbkV4cHJlc3Npb25cIixcblx0XHRcdCAgXHRcdHBhcmFtczogW10sXG5cdFx0XHQgIFx0XHRib2R5OiB7dHlwZTogXCJCbG9ja1N0YXRlbWVudFwiLCBib2R5OiBlbnN1cmVTdGF0ZW1lbnQoYm9keSl9XG5cdFx0XHQgIFx0fSxcblx0XHRcdCAgXHRhcmd1bWVudHM6IFtdXG5cdFx0XHQgIH1cblx0XHRcdH1dLFxuXHRcdFx0XCJraW5kXCI6IGN0eC52YXJUeXBlIHx8ICd2YXInXG5cdFx0fTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gdHJhbmZvcm1Db250aW51ZShub2RlLCBjdHgpIHtcblx0XHRyZXR1cm4ge3R5cGU6IFwiQ29udGludWVTdGF0ZW1lbnRcIn07XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlQ29wKGxlZnQsIG9wLCByaWdodCkge1xuXG5cdFx0dmFyIGZ4T3BzID0ge1xuXHRcdFx0XCJJbl9cIjogXCJpblwiLFxuXHRcdFx0XCJJblwiOiBcImluXCIsXG5cdFx0XHRcIk5vdEluXCI6IFwiaW5cIlxuXHRcdH07XG5cdFx0dmFyIG9wTmFtZSA9IGdldE9wTmFtZShvcCk7XG5cdFx0aWYgKCBvcE5hbWUgaW4gZnhPcHMgICkge1xuXHRcdFx0dmFyIGNhbGwgPSB7XG5cdFx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdFx0Y2FsbGVlOiBtYWtlVmFyaWFibGVOYW1lKFwiX19weXRob25SdW50aW1lLm9wcy5cIiArIGZ4T3BzW29wTmFtZV0pLFxuXHRcdFx0XHRhcmd1bWVudHM6IFtsZWZ0LCByaWdodF1cblx0XHRcdH07XG5cblx0XHRcdGlmICggb3BOYW1lID09IFwiTm90SW5cIiApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiBcIlVuYXJ5RXhwcmVzc2lvblwiLFxuXHRcdFx0XHRcdGFyZ3VtZW50OiBjYWxsLFxuXHRcdFx0XHRcdG9wZXJhdG9yOiBcIiFcIlxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNhbGw7XHRcblx0XHRcdH0gXG5cdFx0fVxuXG5cdFx0XG5cdFx0dmFyIG9wZXJhdG9ycyA9IHtcblx0XHRcdFwiRXFcIjogXCI9PT1cIixcblx0XHRcdFwiTm90RXFcIjogXCIhPT1cIixcblx0XHRcdFwiTHRFXCI6IFwiPD1cIixcblx0XHRcdFwiTHRcIjogXCI8XCIsXG5cdFx0XHRcIkd0RVwiOiBcIj49XCIsXG5cdFx0XHRcIkd0XCI6IFwiPlwiLFxuXHRcdFx0XCJJc1wiOiBcIj09PVwiLFxuXHRcdFx0XCJJc05vdFwiOiBcIiE9PVwiXG5cdFx0fTtcblx0XHRcblx0XHRpZiAoICEob3BOYW1lIGluIG9wZXJhdG9ycykgKSBhYm9ydChcIlVuc3Vwb3J0ZWQgQ29tcGFyZSBvcGVyYXRvcjogXCIgKyBvcE5hbWUpO1xuXHRcdHJldHVybiBiaW5PcChsZWZ0LCBvcGVyYXRvcnNbb3BOYW1lXSwgcmlnaHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtQ29tcGFyZShub2RlLCBjdHgpIHtcblx0XHR2YXIgbGVmdCA9IHRyYW5zZm9ybShub2RlLmxlZnQsIGN0eCk7XG5cdFx0dmFyIHJlc3VsdDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGUuY29tcGFyYXRvcnMubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHR2YXIgcmlnaHQgPSB0cmFuc2Zvcm0obm9kZS5jb21wYXJhdG9yc1tpXSwgY3R4KTtcblx0XHRcdHZhciBjb3AgPSBtYWtlQ29wKGxlZnQsIG5vZGUub3BzW2ldLCByaWdodCk7XG5cdFx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdFx0cmVzdWx0ID0gYmluT3AocmVzdWx0LCAnJiYnLCBjb3ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0ID0gY29wO1xuXHRcdFx0fVxuXHRcdFx0bGVmdCA9IHJpZ2h0O1xuXHRcdH1cblxuXHRcdFxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybURlbChub2RlLCBjdHgpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZS50YXJnZXRzLmxlbmd0aDsgKytpICkge1xuXHRcdFx0dmFyIHN0ID0gbm9kZS50YXJnZXRzW2ldO1xuXHRcdFx0dmFyIHBhcnRpYWwgPSB0cmFuc2Zvcm0oc3QsIGN0eCk7XG5cdFx0XHRyZXN1bHQucHVzaCh7XG5cdFx0XHRcdHR5cGU6IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIixcblx0XHRcdFx0b3BlcmF0b3I6IFwiPVwiLFxuXHRcdFx0XHRsZWZ0OiBwYXJ0aWFsLFxuXHRcdFx0XHRyaWdodDoge1xuXHRcdFx0XHRcdHR5cGU6IFwiVW5hcnlFeHByZXNzaW9uXCIsXG5cdFx0XHRcdFx0YXJndW1lbnQ6IGxpdGVyYWwoMCksXG5cdFx0XHRcdFx0b3BlcmF0b3I6ICd2b2lkJyxcblx0XHRcdFx0XHRwcmVmaXg6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBlbnN1cmVTdGF0ZW1lbnQoe1xuXHRcdFx0dHlwZTogXCJTZXF1ZW5jZUV4cHJlc3Npb25cIixcblx0XHRcdGV4cHJlc3Npb25zOiByZXN1bHRcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybURpY3Qobm9kZSwgY3R4KSB7XG5cdFx0dmFyIGFyZ3MgPSBbXTtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2RlLmtleXMubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRhcmdzLnB1c2goe1xuXHRcdFx0XHR0eXBlOiBcIkFycmF5RXhwcmVzc2lvblwiLFxuXHRcdFx0XHRlbGVtZW50czogW1xuXHRcdFx0XHRcdHRyYW5zZm9ybShub2RlLmtleXNbaV0sIGN0eCksXG5cdFx0XHRcdFx0dHJhbnNmb3JtKG5vZGUudmFsdWVzW2ldLCBjdHgpXG5cdFx0XHRcdF1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogXCJOZXdFeHByZXNzaW9uXCIsXG5cdFx0XHRjYWxsZWU6IG1ha2VWYXJpYWJsZU5hbWUoXCJfX3B5dGhvblJ1bnRpbWUub2JqZWN0cy5kaWN0XCIpLFxuXHRcdFx0YXJndW1lbnRzOiBhcmdzXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybUV4cHIobm9kZSwgY3R4KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFxuXHRcdFx0ZXhwcmVzc2lvbjogdHJhbnNmb3JtKG5vZGUudmFsdWUsIGN0eClcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gYXNzaWduUG9zc2libHlXaXRoRGVjbGFyYXRpb24odGFyZ2V0LCB2YWx1ZSwgY3R4KSB7XG5cdFx0dmFyIGxlZnQgPSB0YXJnZXQuX2FzdG5hbWUgPyB0cmFuc2Zvcm0odGFyZ2V0LCBjdHgpIDogdGFyZ2V0O1xuXHRcdHZhciB2YXJpYmxlO1xuXG5cdFx0aWYgKCBsZWZ0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICkgdmFyaWJsZSA9IGxlZnQubmFtZTtcblxuXHRcdGlmICggIXZhcmlibGUgfHwgIWN0eCB8fCAhY3R4LmxvY2FscyB8fCBjdHgubG9jYWxzW3ZhcmlibGVdICkge1xuXHRcdFx0cmV0dXJuIHt0eXBlOiBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgZXhwcmVzc2lvbjoge1xuXHRcdFx0XHR0eXBlOiBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXG5cdFx0XHRcdG9wZXJhdG9yOiBcIj1cIixcblx0XHRcdFx0bGVmdDogbGVmdCxcblx0XHRcdFx0cmlnaHQ6IHZhbHVlXG5cdFx0XHR9fTtcblx0XHR9XG5cblx0XHRjdHgubG9jYWxzW3ZhcmlibGVdID0gdHJ1ZTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcblx0XHRcdGRlY2xhcmF0aW9uczogW3tcblx0XHRcdFx0dHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIixcblx0XHRcdFx0aWQ6IGxlZnQsXG5cdFx0XHRcdGluaXQ6IHZhbHVlXG5cdFx0XHR9XSxcblx0XHRcdGtpbmQ6IGN0eC52YXJUeXBlIHx8ICd2YXInXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVR1cGxlVW5wYWNraW5nQXNzaWduKHRhcmdldCwgdmFsdWUsIGN0eCkge1xuXG5cdFx0aWYgKCB0YXJnZXQuX2FzdG5hbWUgPT09ICdUdXBsZScgKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHR2YXIgdG4gPSBjcmVhdGVUZW1wTmFtZShcInJpZ2h0XCIpO1xuXHRcdFx0cmVzdWx0LnB1c2goe1xuXHRcdFx0XHR0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcblx0XHRcdFx0a2luZDogXCJ2YXJcIixcblx0XHRcdFx0ZGVjbGFyYXRpb25zOiBbe1xuXHRcdFx0XHRcdHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXG5cdFx0XHRcdFx0aWQ6IGlkZW50KHRuKSxcblx0XHRcdFx0XHRpbml0OiB2YWx1ZVxuXHRcdFx0XHR9XVxuXHRcdFx0fSk7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0YXJnZXQuZWx0cy5sZW5ndGg7ICsraSApIHtcblx0XHRcdFx0cmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LGNyZWF0ZVR1cGxlVW5wYWNraW5nQXNzaWduKFxuXHRcdFx0XHRcdHRhcmdldC5lbHRzW2ldLFxuXHRcdFx0XHRcdHt0eXBlOiBcIk1lbWJlckV4cHJlc3Npb25cIiwgb2JqZWN0OiBpZGVudCh0biksIHByb3BlcnR5OiBsaXRlcmFsKGkpLCAgY29tcHV0ZWQ6IHRydWV9XG5cdFx0XHRcdCxjdHgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFthc3NpZ25Qb3NzaWJseVdpdGhEZWNsYXJhdGlvbih0YXJnZXQsIHZhbHVlLCBjdHgpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUZvckxvb3AoaWlkZW50LCB0aWRlbnQsIGl0ZXIsIHRhcmdldCwgYm9keSwgY3R4KSB7XG5cblx0XHRib2R5ID0gY3JlYXRlVHVwbGVVbnBhY2tpbmdBc3NpZ24oXG5cdFx0XHR0YXJnZXQsIFxuXHRcdFx0e3R5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLCBvYmplY3Q6IHRpZGVudCwgcHJvcGVydHk6IGlpZGVudCwgY29tcHV0ZWQ6IHRydWV9LFxuXHRcdFx0Y3R4XG5cdFx0KS5jb25jYXQoYm9keSk7XG5cblx0XHR2YXIgcml0ZXIgPSB0ZXJuYXJ5KFxuXHRcdFx0e3R5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIiwgY2FsbGVlOiBtYWtlVmFyaWFibGVOYW1lKFwiQXJyYXkuaXNBcnJheVwiKSwgYXJndW1lbnRzOltpdGVyXX0sXG5cdFx0XHRpdGVyLFxuXHRcdFx0e3R5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIiwgY2FsbGVlOiBtYWtlVmFyaWFibGVOYW1lKFwiT2JqZWN0LmtleXNcIiksIGFyZ3VtZW50czpbaXRlcl19XG5cdFx0KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcIkZvclN0YXRlbWVudFwiLFxuXHRcdFx0aW5pdDoge1xuXHRcdFx0XHRcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5cdFx0XHRcdFwiZGVjbGFyYXRpb25zXCI6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHQgIFwidHlwZVwiOiBcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFxuXHRcdFx0XHQgIFwiaWRcIjogaWlkZW50LFxuXHRcdFx0XHQgIFwiaW5pdFwiOiBsaXRlcmFsKDApXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0ICBcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0b3JcIixcblx0XHRcdFx0ICBcImlkXCI6IHRpZGVudCxcblx0XHRcdFx0ICBcImluaXRcIjogcml0ZXJcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFwia2luZFwiOiBjdHgudmFyVHlwZVxuXHRcdFx0fSxcblx0XHRcdHRlc3Q6IGJpbk9wKGlpZGVudCwgJzwnLCB7XG5cdFx0XHRcdHR5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLCBvYmplY3Q6IHRpZGVudCwgcHJvcGVydHk6IHt0eXBlOiBcIklkZW50aWZpZXJcIiwgbmFtZTogXCJsZW5ndGhcIn1cblx0XHRcdH0pLFxuXHRcdFx0dXBkYXRlOiB7XG5cdFx0XHRcdFwidHlwZVwiOiBcIlVwZGF0ZUV4cHJlc3Npb25cIixcblx0XHRcdFx0XCJvcGVyYXRvclwiOiBcIisrXCIsXG5cdFx0XHRcdFwicHJlZml4XCI6IHRydWUsXG5cdFx0XHRcdFwiYXJndW1lbnRcIjogaWlkZW50XG5cdFx0XHR9LFxuXHRcdFx0Ym9keToge3R5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIiwgYm9keTogYm9keX1cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtRm9yKG5vZGUsIGN0eCkge1xuXHRcdHZhciBuYW1lID0gY3JlYXRlVGVtcE5hbWUoJ2lkeCcpO1xuXHRcdHZhciBpaWRlbnQgPSBpZGVudChuYW1lKTtcblx0XHR2YXIgdG5hbWUgPSBjcmVhdGVUZW1wTmFtZSgndGFyZ2V0Jyk7XG5cdFx0dmFyIHRpZGVudCA9IHt0eXBlOiBcIklkZW50aWZpZXJcIiwgbmFtZTogdG5hbWV9O1xuXHRcdHZhciBpdGVyID0gdHJhbnNmb3JtKG5vZGUuaXRlciwgY3R4KTtcblx0XHR2YXIgYm9keSA9IGVuc3VyZVN0YXRlbWVudCh0cmFuc2Zvcm0obm9kZS5ib2R5LCBjdHgpKTtcblxuXHRcdGlmICggbm9kZS5vcmVsc2UgJiYgbm9kZS5vcmVsc2UubGVuZ3RoID4gMCApIGFib3J0KFwiZWxzZTogZm9yLWVsc2Ugc3RhdGVtZW50IHVuc3VwcG9ydGVkLlwiKTtcblx0XHRyZXR1cm4gY3JlYXRlRm9yTG9vcChpaWRlbnQsIHRpZGVudCwgaXRlciwgbm9kZS50YXJnZXQsIGJvZHksIGN0eCk7XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlRnVuY3Rpb25Cb2R5KG5vZGUsIGN0eCkge1xuXHRcdHZhciBhcmdzID0gbm9kZS5hcmdzLmFyZ3Muc2xpY2UoMCk7XG5cdFx0aWYgICggY3R4LmluQ2xhc3MgKSB7XG5cdFx0XHQvL1RPRE86IE1ha2Ugc3VyZSBpdCdzIG5hbWVkIHNlbGYsIG1heWJlP1xuXHRcdFx0YXJncy5zaGlmdCgpO1xuXHRcdH1cblx0XHR2YXIgaGFzQW55QXJndW1lbnRzID0gYXJncy5sZW5ndGggPiAwIHx8IG5vZGUuYXJncy52YXJhcmcgfHwgbm9kZS5hcmdzLmt3YXJnO1xuXHRcdHZhciBuY3R4ID0ge1xuXHRcdFx0bG9jYWxzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXHRcdFx0dmFyVHlwZTogY3R4LnZhclR5cGVcblx0XHR9O1xuXHRcdHZhciBib2R5ID0gZW5zdXJlU3RhdGVtZW50KHRyYW5zZm9ybShub2RlLmJvZHksIG5jdHgpKTtcblx0XHR2YXIgcHJlbWJsZSA9IFtdO1xuXG5cdFx0aWYgKCBjdHguaW5DbGFzcyApIHtcblx0XHRcdHByZW1ibGUucHVzaCh7XG5cdFx0XHRcdFwidHlwZVwiOiBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcblx0XHRcdFx0XCJkZWNsYXJhdGlvbnNcIjogW3tcblx0XHRcdFx0XHRcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0b3JcIixcblx0XHRcdFx0XHRcImlkXCI6IGlkZW50KCdzZWxmJyksXG5cdFx0XHRcdFx0XCJpbml0XCI6IHt0eXBlOiBcIlRoaXNFeHByZXNzaW9uXCJ9XG5cdFx0XHRcdH1dLFxuXHRcdFx0XHRcImtpbmRcIjogXCJ2YXJcIlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNBbnlBcmd1bWVudHMgKSB7XG5cdFx0XHRcblx0XHRcdHZhciBoYXNQYXJhbXMgPSBjcmVhdGVUZW1wTmFtZSgnaGFzUGFyYW1zJyk7XG5cdFx0XHR2YXIgcGFyYW0wID0gY3JlYXRlVGVtcE5hbWUoJ3BhcmFtMCcpO1xuXHRcdFx0dmFyIHJlYWxBcmdDb3VudCA9IGNyZWF0ZVRlbXBOYW1lKCdyZWFsQXJnQ291bnQnKTtcblx0XHRcdHZhciBhcmdMZW4gPSBtYWtlVmFyaWFibGVOYW1lKCdhcmd1bWVudHMubGVuZ3RoJyk7XG5cdFx0XHR2YXIgYXJnTiA9IHt0eXBlOiBcIk1lbWJlckV4cHJlc3Npb25cIiwgb2JqZWN0OiBpZGVudCgnYXJndW1lbnRzJyksIHByb3BlcnR5OiBiaW5PcChhcmdMZW4sICctJywgbGl0ZXJhbCgxKSksIGNvbXB1dGVkOiB0cnVlfTtcblx0XHRcdHZhciBhcmdOS2V5d29yZHMgPSB7dHlwZTogXCJNZW1iZXJFeHByZXNzaW9uXCIsIG9iamVjdDogYXJnTiwgcHJvcGVydHk6IGlkZW50KCdrZXl3b3JkcycpLCBjb21wdXRlZDogZmFsc2V9O1xuXG5cdFx0XHRwcmVtYmxlLnB1c2goe1xuXHRcdFx0XHRcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5cdFx0XHRcdFwiZGVjbGFyYXRpb25zXCI6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHQgIFwidHlwZVwiOiBcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFxuXHRcdFx0XHQgIFwiaWRcIjogaWRlbnQoaGFzUGFyYW1zKSxcblx0XHRcdFx0ICBcImluaXRcIjogbG9naWNPcChiaW5PcChhcmdMZW4sICc+JywgbGl0ZXJhbCgwKSksICcmJicsIGxvZ2ljT3AoYXJnTiwgJyYmJywgYXJnTktleXdvcmRzKSlcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFwia2luZFwiOiAgXCJ2YXJcIlxuXHRcdFx0fSk7XG5cblx0XHRcdHZhciBtYWluID0gW107XG5cdFx0XHRtYWluLnB1c2goe1xuXHRcdFx0XHRcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5cdFx0XHRcdFwiZGVjbGFyYXRpb25zXCI6IFt7XG5cdFx0XHRcdFx0XCJ0eXBlXCI6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXG5cdFx0XHRcdFx0XCJpZFwiOiBpZGVudChwYXJhbTApLFxuXHRcdFx0XHRcdFwiaW5pdFwiOiB0ZXJuYXJ5KGlkZW50KGhhc1BhcmFtcyksIGFyZ05LZXl3b3Jkcywge3R5cGU6IFwiT2JqZWN0RXhwcmVzc2lvblwiLCBwcm9wZXJ0aWVzOiBbXX0pXG5cdFx0XHRcdH0se1xuXHRcdFx0XHRcdFwidHlwZVwiOiBcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFxuXHRcdFx0XHRcdFwiaWRcIjogaWRlbnQocmVhbEFyZ0NvdW50KSxcblx0XHRcdFx0XHRcImluaXRcIjogYmluT3AoYXJnTGVuLCAnLScsIHRlcm5hcnkoaWRlbnQoaGFzUGFyYW1zKSwgbGl0ZXJhbCgxKSwgbGl0ZXJhbCgwKSkpXG5cdFx0XHRcdH1dLFxuXHRcdFx0XHRcImtpbmRcIjogXCJ2YXJcIlxuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRcdHZhciBhID0gbm9kZS5hcmdzLmFyZ3NbaV07XG5cdFx0XHRcdHZhciBkaWR4ID0gaSAtIChub2RlLmFyZ3MuYXJncy5sZW5ndGggLSBub2RlLmFyZ3MuZGVmYXVsdHMubGVuZ3RoKTtcblx0XHRcdFx0dmFyIGRlZiA9IGRpZHggPj0gMCA/IHRyYW5zZm9ybShub2RlLmFyZ3MuZGVmYXVsdHNbZGlkeF0sIGN0eCkgOiBpZGVudCgndW5kZWZpbmVkJyk7XG5cblx0XHRcdFx0bWFpbi5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiBcIklmU3RhdGVtZW50XCIsXG5cdFx0XHRcdFx0dGVzdDogYmluT3AoaWRlbnQocmVhbEFyZ0NvdW50KSwgJzwnLCBsaXRlcmFsKGkrMSkpLFxuXHRcdFx0XHRcdGNvbnNlcXVlbnQ6IGVuc3VyZVN0YXRlbWVudCh7XG5cdFx0XHRcdFx0XHR0eXBlOiBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXG5cdFx0XHRcdFx0XHRvcGVyYXRvcjogXCI9XCIsXG5cdFx0XHRcdFx0XHRsZWZ0OiBpZGVudChhLmlkKSxcblx0XHRcdFx0XHRcdHJpZ2h0OiB0ZXJuYXJ5KFxuXHRcdFx0XHRcdFx0XHRiaW5PcChsaXRlcmFsKGEuaWQpLCAnaW4nLCBpZGVudChwYXJhbTApKSxcblx0XHRcdFx0XHRcdFx0e3R5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLCBvYmplY3Q6IGlkZW50KHBhcmFtMCksIHByb3BlcnR5OiBpZGVudChhLmlkKSwgY29tcHV0ZWQ6IGZhbHNlfSxcblx0XHRcdFx0XHRcdFx0ZGVmXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZS5hcmdzLnZhcmFyZyApIHtcblx0XHRcdFx0bWFpbi5wdXNoKHtcblx0XHRcdFx0XHRcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5cdFx0XHRcdFx0XCJkZWNsYXJhdGlvbnNcIjogW3tcblx0XHRcdFx0XHRcdFwidHlwZVwiOiBcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFxuXHRcdFx0XHRcdFx0XCJpZFwiOiBpZGVudChub2RlLmFyZ3MudmFyYXJnKSxcblx0XHRcdFx0XHRcdFwiaW5pdFwiOiB7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdFx0XHRcdFx0Y2FsbGVlOiBtYWtlVmFyaWFibGVOYW1lKFwiQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxcIiksXG5cdFx0XHRcdFx0XHRcdGFyZ3VtZW50czogW2lkZW50KCdhcmd1bWVudHMnKSwgbGl0ZXJhbChub2RlLmFyZ3MuYXJncy5sZW5ndGgpLCBoYXNBbnlBcmd1bWVudHMgPyBpZGVudChyZWFsQXJnQ291bnQpIDogdW5kZWZpbmVkXVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFwia2luZFwiOiBcInZhclwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGUuYXJncy5rd2FyZyApIHtcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZS5hcmdzLmFyZ3MubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRcdFx0bWFpbi5wdXNoKGVuc3VyZVN0YXRlbWVudCh7XG5cdFx0XHRcdFx0XHR0eXBlOiBcIlVuYXJ5RXhwcmVzc2lvblwiLFxuXHRcdFx0XHRcdFx0b3BlcmF0b3I6IFwiZGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRhcmd1bWVudDoge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1lbWJlckV4cHJlc3Npb25cIixcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiBpZGVudChwYXJhbTApLFxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eTogaWRlbnQobm9kZS5hcmdzLmFyZ3NbaV0uaWQpLFxuXHRcdFx0XHRcdFx0XHRjb21wdXRlZDogZmFsc2Vcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWFpbi5wdXNoKHtcblx0XHRcdFx0XHRcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5cdFx0XHRcdFx0XCJkZWNsYXJhdGlvbnNcIjogW3tcblx0XHRcdFx0XHRcdFwidHlwZVwiOiBcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFxuXHRcdFx0XHRcdFx0XCJpZFwiOiBpZGVudChub2RlLmFyZ3Mua3dhcmcpLFxuXHRcdFx0XHRcdFx0XCJpbml0XCI6IGlkZW50KHBhcmFtMClcblx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcImtpbmRcIjogXCJ2YXJcIlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cHJlbWJsZSA9IHByZW1ibGUuY29uY2F0KG1haW4pOyAvL1RPRE86IElmIHdlIGRvbnQgaGF2ZSBkZWZhdXRzLCB3ZSBjYW4gZ3VhcmQgdGhpcyB3aXRoIF9faGFzUGFyYW1zXHRcblx0XHR9XG5cblxuXHRcdGJvZHkgPSBwcmVtYmxlLmNvbmNhdChib2R5KTtcblx0XHR2YXIgcGFyYW1zID0gdHJhbnNmb3JtKGFyZ3MsIGN0eCk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHByZW1ibGU6IHByZW1ibGUsXG5cdFx0XHRib2R5OiBib2R5LFxuXHRcdFx0cGFyYW1zOiBwYXJhbXNcblx0XHR9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1GdW5jdGlvbkRlZihub2RlLCBjdHgpIHtcblx0XHR2YXIgZGF0YSA9IHByZXBhcmVGdW5jdGlvbkJvZHkobm9kZSwgY3R4KTtcblxuXG5cblx0XHRpZiAoIGN0eC53cml0ZVRhcmdldCApIHtcblx0XHRcdHJldHVybiBlbnN1cmVTdGF0ZW1lbnQoe1xuXHRcdFx0XHR0eXBlOiBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXG5cdFx0XHRcdGxlZnQ6IHt0eXBlOiBcIk1lbWJlckV4cHJlc3Npb25cIiwgb2JqZWN0OiBjdHgud3JpdGVUYXJnZXQsIHByb3BlcnR5OiBpZGVudChub2RlLm5hbWUpfSxcblx0XHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0XHR0eXBlOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFxuXHRcdFx0XHRcdG5hbWU6IGlkZW50KG5vZGUubmFtZSksXG5cdFx0XHRcdFx0cGFyYW1zOiBkYXRhLnBhcmFtcyxcblx0XHRcdFx0XHRib2R5OiB7dHlwZTogXCJCbG9ja1N0YXRlbWVudFwiLCBib2R5OiBkYXRhLmJvZHl9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9wZXJhdG9yOiAnPSdcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0eXBlOiBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIixcblx0XHRcdFx0aWQ6IHt0eXBlOiBcIklkZW50aWZpZXJcIiwgbmFtZTogbm9kZS5uYW1lLnZ9LFxuXHRcdFx0XHRwYXJhbXM6IGRhdGEucGFyYW1zLFxuXHRcdFx0XHRib2R5OiB7dHlwZTogXCJCbG9ja1N0YXRlbWVudFwiLCBib2R5OiBkYXRhLmJvZHl9XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybUdsb2JhbChub2RlLCBjdHgpIHtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2RlLm5hbWVzLmxlbmd0aDsgKytpICkge1xuXHRcdFx0Y3R4LmxvY2Fsc1tub2RlLm5hbWVzW2ldLnZdID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtSWYobm9kZSwgY3R4KSB7XG5cdFx0dmFyIGJvZHkgPSBlbnN1cmVTdGF0ZW1lbnQodHJhbnNmb3JtKG5vZGUuYm9keSwgY3R4KSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiSWZTdGF0ZW1lbnRcIixcblx0XHRcdHRlc3Q6IHRyYW5zZm9ybShub2RlLnRlc3QsIGN0eCksXG5cdFx0XHRjb25zZXF1ZW50OiB7dHlwZTogXCJCbG9ja1N0YXRlbWVudFwiLCBib2R5OiBib2R5fSxcblx0XHRcdGFsdGVybmF0ZTogKG5vZGUub3JlbHNlICYmIG5vZGUub3JlbHNlLmxlbmd0aCA+IDApID8ge3R5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIiwgYm9keTogZW5zdXJlU3RhdGVtZW50KHRyYW5zZm9ybShub2RlLm9yZWxzZSwgY3R4KSl9IDogdW5kZWZpbmVkXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybUxhbWJkYShub2RlLCBjdHgpIHtcblx0XHR2YXIgZGF0YSA9IHByZXBhcmVGdW5jdGlvbkJvZHkobm9kZSwgY3R4KTtcblx0XHRcblx0XHQvL1RPRE86IFRoaXMgaXMgcHJldHR5IHNrZXRjaHkuXG5cdFx0dmFyIGxhc3QgPSBkYXRhLmJvZHlbZGF0YS5ib2R5Lmxlbmd0aCAtIDFdO1xuXHRcdGRhdGEuYm9keVtkYXRhLmJvZHkubGVuZ3RoIC0gMV0gPSB7dHlwZTogXCJSZXR1cm5TdGF0ZW1lbnRcIiwgYXJndW1lbnQ6IGxhc3QuZXhwcmVzc2lvbn07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogXCJGdW5jdGlvbkV4cHJlc3Npb25cIixcblx0XHRcdHBhcmFtczogZGF0YS5wYXJhbXMsXG5cdFx0XHRib2R5OiB7dHlwZTogXCJCbG9ja1N0YXRlbWVudFwiLCBib2R5OiBkYXRhLmJvZHl9XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybUxpc3Qobm9kZSwgY3R4KSB7XG5cdFx0dmFyIGNhbGwgPSB7XG5cdFx0XHR0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCIsXG5cdFx0XHRjYWxsZWU6IG1ha2VWYXJpYWJsZU5hbWUoXCJfX3B5dGhvblJ1bnRpbWUub2JqZWN0cy5saXN0XCIpLFxuXHRcdFx0YXJndW1lbnRzOiB0cmFuc2Zvcm0obm9kZS5lbHRzLCBjdHgpXG5cdFx0fTtcblx0XHRyZXR1cm4gY2FsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybUxpc3RDb21wKG5vZGUsIGN0eCkge1x0XG5cdFx0dmFyIGJvZHkgPSBbXTtcblx0XHR2YXIgYWdncmlnYXRvciA9IGNyZWF0ZVRlbXBOYW1lKCdyZXN1bHQnKTtcblxuXHRcdGJvZHkucHVzaCh7XG5cdFx0XHRcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG5cdFx0XHRcImRlY2xhcmF0aW9uc1wiOiBbe1xuXHRcdFx0XHRcInR5cGVcIjogXCJWYXJpYWJsZURlY2xhcmF0b3JcIixcblx0XHRcdFx0XCJpZFwiOiBpZGVudChhZ2dyaWdhdG9yKSxcblx0XHRcdFx0XCJpbml0XCI6IHtcblx0XHRcdFx0XHR0eXBlOiBcIk5ld0V4cHJlc3Npb25cIixcblx0XHRcdFx0XHRjYWxsZWU6IG1ha2VWYXJpYWJsZU5hbWUoJ19fcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QnKSxcblx0XHRcdFx0XHRhcmd1bWVudHM6IFtdXG5cdFx0XHRcdH1cblx0XHRcdH1dLFxuXHRcdFx0XCJraW5kXCI6IFwidmFyXCJcblx0XHR9KTtcblxuXHRcdHZhciBpbnNpZGVCb2R5ID0gW107XG5cblx0XHRpbnNpZGVCb2R5LnB1c2goZW5zdXJlU3RhdGVtZW50KHtcblx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdGNhbGxlZToge3R5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLCBvYmplY3Q6IGlkZW50KGFnZ3JpZ2F0b3IpLCBwcm9wZXJ0eTogaWRlbnQoJ3B1c2gnKSwgY29tcHV0ZWQ6IGZhbHNlfSxcblx0XHRcdGFyZ3VtZW50czogW3RyYW5zZm9ybShub2RlLmVsdCwgY3R4KV1cblx0XHR9KSk7XG5cblx0XHQvL2lmICggbm9kZS5nZW5lcmF0b3JzLmxlbmd0aCAhPT0gMSApIGFib3J0KFwiVW5zdXBvcnRlZCBudW1iZXIgb2YgZ2VuZXJhdG9yc1wiKTtcblx0XHR2YXIgZ2VuID0gbm9kZS5nZW5lcmF0b3JzWzBdO1xuXG5cdFx0Zm9yICggdmFyIGcgPSBub2RlLmdlbmVyYXRvcnMubGVuZ3RoIC0gMTsgZyA+PSAwOyAtLWcgKSB7XG5cdFx0XHR2YXIgaWR4TmFtZSA9IGNyZWF0ZVRlbXBOYW1lKCdpZHgnKTtcblx0XHRcdHZhciBsaXN0TmFtZSA9IGNyZWF0ZVRlbXBOYW1lKFwibGlzdFwiICsgZyk7XG5cdFx0XHR2YXIgaXRlck5hbWUgPSBjcmVhdGVUZW1wTmFtZSgnaXRlcicpO1xuXHRcdFx0dmFyIGdlbiA9IG5vZGUuZ2VuZXJhdG9yc1tnXTtcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGdlbi5pZnMubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRcdGluc2lkZUJvZHkudW5zaGlmdCh7XG5cdFx0XHRcdFx0dHlwZTogXCJJZlN0YXRlbWVudFwiLFxuXHRcdFx0XHRcdHRlc3Q6IHt0eXBlOiBcIlVuYXJ5RXhwcmVzc2lvblwiLCBhcmd1bWVudDogdHJhbnNmb3JtKGdlbi5pZnNbaV0sIGN0eCksIG9wZXJhdG9yOiBcIiFcIn0sXG5cdFx0XHRcdFx0Y29uc2VxdWVudDoge3R5cGU6IFwiQ29udGludWVTdGF0ZW1lbnRcIn1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGluc2lkZUJvZHkgPSBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcblx0XHRcdFx0XHRraW5kOiBcInZhclwiLFxuXHRcdFx0XHRcdGRlY2xhcmF0aW9uczogW3tcblx0XHRcdFx0XHRcdHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRpZDogaWRlbnQobGlzdE5hbWUpLFxuXHRcdFx0XHRcdFx0aW5pdDogdHJhbnNmb3JtKGdlbi5pdGVyLCBjdHgpXG5cdFx0XHRcdFx0fV1cblx0XHRcdFx0fSxcblx0XHRcdFx0Y3JlYXRlRm9yTG9vcChpZGVudChpZHhOYW1lKSwgaWRlbnQoaXRlck5hbWUpLCBpZGVudChsaXN0TmFtZSksIGdlbi50YXJnZXQsIGluc2lkZUJvZHksIGN0eClcblx0XHRcdF07XG5cdFx0fVxuXG5cdFx0Ym9keS5wdXNoLmFwcGx5KGJvZHksIGluc2lkZUJvZHkpO1xuXHRcdGJvZHkucHVzaCh7XG5cdFx0XHR0eXBlOiBcIlJldHVyblN0YXRlbWVudFwiLFxuXHRcdFx0YXJndW1lbnQ6IGlkZW50KGFnZ3JpZ2F0b3IpXG5cdFx0fSk7XG5cblx0XHR2YXIgZXhwciA9IHtcblx0XHRcdHR5cGU6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXG5cdFx0XHRwYXJhbXM6IFtdLFxuXHRcdFx0Ym9keToge3R5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIiwgYm9keTogYm9keX1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdGNhbGxlZTogZXhwcixcblx0XHRcdGFyZ3VtZW50czogW11cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtTW9kdWxlKG5vZGUsIGN0eCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcIlByb2dyYW1cIixcblx0XHRcdGJvZHk6IGVuc3VyZVN0YXRlbWVudCh0cmFuc2Zvcm0obm9kZS5ib2R5LCBjdHgpKVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1OYW1lKG5vZGUsIGN0eCkge1xuXHRcdGlmICggbm9kZS5pZC52ID09PSAnVHJ1ZScgKSByZXR1cm4ge3R5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogdHJ1ZSwgcmF3OiBcInRydWVcIn07XG5cdFx0aWYgKCBub2RlLmlkLnYgPT09ICdGYWxzZScgKSByZXR1cm4ge3R5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogZmFsc2UsIHJhdzogXCJmYWxzZVwifTtcblx0XHRpZiAoIG5vZGUuaWQudiA9PT0gJ05vbmUnICkgcmV0dXJuIHt0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IG51bGwsIHJhdzogXCJudWxsXCJ9O1xuXG5cdFx0aWYgKCBub2RlLmlkLnYgPT09ICdyYW5kb20nICkgcmV0dXJuIG1ha2VWYXJpYWJsZU5hbWUoJ19fcHl0aG9uUnVudGltZS5pbXBvcnRzLnJhbmRvbScpO1xuXHRcdHJldHVybiBpZGVudChub2RlLmlkKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybU51bShub2RlLCBjdHgpIHtcblx0XHRyZXR1cm4gbGl0ZXJhbChub2RlLm4pO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtUHJpbnQobm9kZSwgY3R4KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdGNhbGxlZTogbWFrZVZhcmlhYmxlTmFtZShcImNvbnNvbGUubG9nXCIpLFxuXHRcdFx0YXJndW1lbnRzOiB0cmFuc2Zvcm0obm9kZS52YWx1ZXMsIGN0eClcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtUmV0dXJuKG5vZGUsIGN0eCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcIlJldHVyblN0YXRlbWVudFwiLFxuXHRcdFx0YXJndW1lbnQ6IG5vZGUudmFsdWUgPyB0cmFuc2Zvcm0obm9kZS52YWx1ZSwgY3R4KSA6IHVuZGVmaW5lZFxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1TdHIobm9kZSwgY3R4KSB7XG5cdFx0cmV0dXJuIGxpdGVyYWwobm9kZS5zLnZhbHVlT2YoKSk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1UdXBsZShub2RlLCBjdHgpIHtcblx0XHR2YXIgY2FsbCA9IHtcblx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdGNhbGxlZTogbWFrZVZhcmlhYmxlTmFtZShcIl9fcHl0aG9uUnVudGltZS5vYmplY3RzLnR1cGxlXCIpLFxuXHRcdFx0YXJndW1lbnRzOiB0cmFuc2Zvcm0obm9kZS5lbHRzLCBjdHgpXG5cdFx0fTtcblx0XHRyZXR1cm4gY2FsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybVN1YnNjcmlwdChub2RlLCBjdHgpIHtcblx0XHQvL1RPRE86IERvIHNpbGx5IHB5dGhvbmljIGxpc3Qgb2Zmc2V0IGxvZ2ljXG5cdFx0dmFyIHZhbCA9IHRyYW5zZm9ybShub2RlLnZhbHVlLCBjdHgpO1xuXHRcdGlmICggbm9kZS5zbGljZS52YWx1ZSApIHtcblx0XHRcdHZhciBsdSA9IHRyYW5zZm9ybShub2RlLnNsaWNlLnZhbHVlLCBjdHgpO1xuXHRcdFx0bHUgPSB7XG5cdFx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdFx0Y2FsbGVlOiBtYWtlVmFyaWFibGVOYW1lKFwiX19weXRob25SdW50aW1lLm9wcy5zdWJzY3JpcHRJbmRleFwiKSxcblx0XHRcdFx0YXJndW1lbnRzOiBbdmFsLCBsdV1cblx0XHRcdH07XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0eXBlOiBcIk1lbWJlckV4cHJlc3Npb25cIixcblx0XHRcdFx0Y29tcHV0ZWQ6IHRydWUsXG5cdFx0XHRcdG9iamVjdDogdmFsLFxuXHRcdFx0XHRwcm9wZXJ0eTogbHVcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcblx0XHRcdGNhbGxlZTogbWFrZVZhcmlhYmxlTmFtZSgnX19weXRob25SdW50aW1lLmludGVybmFsLnNsaWNlJyksXG5cdFx0XHRhcmd1bWVudHM6W1xuXHRcdFx0XHR2YWwsXG5cdFx0XHRcdG5vZGUuc2xpY2UubG93ZXIgPyB0cmFuc2Zvcm0obm9kZS5zbGljZS5sb3dlciwgY3R4KSA6IGlkZW50KCd1bmRlZmluZWQnKSxcblx0XHRcdFx0bm9kZS5zbGljZS51cHBlciA/IHRyYW5zZm9ybShub2RlLnNsaWNlLnVwcGVyLCBjdHgpIDogaWRlbnQoJ3VuZGVmaW5lZCcpLFxuXHRcdFx0XHRub2RlLnNsaWNlLnN0ZXAgPyB0cmFuc2Zvcm0obm9kZS5zbGljZS5zdGVwLCBjdHgpIDogaWRlbnQoJ3VuZGVmaW5lZCcpLFxuXHRcdFx0XVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1QYXNzKG5vZGUsIGN0eCkge1xuXHRcdHJldHVybiB7dHlwZTogXCJFbXB0eVN0YXRlbWVudFwifTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybVVuYXJ5T3Aobm9kZSwgY3R4KSB7XG5cdFx0dmFyIGFyZ3VtZW50ID0gdHJhbnNmb3JtKG5vZGUub3BlcmFuZCwgY3R4KTtcblxuXHRcdHZhciBmeE9wcyA9IHtcblx0XHRcdFwiQWRkXCI6IFwiYWRkXCIsXG5cdFx0XHRcIk11bHRcIjogXCJtdWx0aXBseVwiLFxuXHRcdH07XG5cdFx0dmFyIG9wTmFtZSA9IGdldE9wTmFtZShub2RlLm9wKTtcblxuXHRcdGlmICggb3BOYW1lIGluIGZ4T3BzICApIHtcblx0XHRcdHZhciBjYWxsID0ge1xuXHRcdFx0XHR0eXBlOiBcIkNhbGxFeHByZXNzaW9uXCIsXG5cdFx0XHRcdGNhbGxlZTogbWFrZVZhcmlhYmxlTmFtZShcIl9fcHl0aG9uUnVudGltZS5vcHMuXCIgKyBmeE9wc1tvcE5hbWVdKSxcblx0XHRcdFx0YXJndW1lbnRzOiBbYXJndW1lbnRdXG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGNhbGw7XG5cdFx0fVxuXG5cdFx0dmFyIG9wZXJhdG9ycyA9IHtcblx0XHRcdFwiTm90XCI6IFwiIVwiLFxuXHRcdFx0XCJVU3ViXCI6IFwiLVwiLFxuXHRcdFx0XCJJbnZlcnRcIjogXCJ+XCJcblx0XHR9O1xuXG5cdFx0aWYgKCAhKG9wTmFtZSBpbiBvcGVyYXRvcnMpICkgYWJvcnQoXCJVbmtub3duIHVuYXJ5IG9wZXJhdG9yOiBcIiArIG9wTmFtZSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogXCJVbmFyeUV4cHJlc3Npb25cIixcblx0XHRcdGFyZ3VtZW50OiBhcmd1bWVudCxcblx0XHRcdG9wZXJhdG9yOiBvcGVyYXRvcnNbb3BOYW1lXVxuXHRcdH07XG5cdFx0XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1XaGlsZShub2RlLCBjdHgpIHtcblx0XHRpZiAoIG5vZGUub3JlbHNlICYmIG5vZGUub3JlbHNlLmxlbmd0aCA+IDAgKSBhYm9ydChcImVsc2U6IHN0YXRlbWVudCBmb3Igd2hpbGUgdW5zdXBwb3J0ZWQuXCIpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcIldoaWxlU3RhdGVtZW50XCIsXG5cdFx0XHR0ZXN0OiB0cmFuc2Zvcm0obm9kZS50ZXN0LCBjdHgpLFxuXHRcdFx0Ym9keToge3R5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIiwgYm9keTogZW5zdXJlU3RhdGVtZW50KHRyYW5zZm9ybShub2RlLmJvZHksIGN0eCkpfVxuXHRcdH07XHRcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtO1xuXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIFNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXHRmdW5jdGlvbiBzcGxhdChlKSB7XG5cdFx0Y29uc29sZS5sb2coXCJHT1QgRVJST1IhXCIpO1xuXHRcdGNvbnNvbGUubG9nKGUsIGUuZXh0cmEpO1xuXHRcdGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGUuZXh0cmEubm9kZSwgZnVuY3Rpb24oaywgIG8pIHtcblx0XHRcdGlmICggayA9PSAndHlwZScgKSByZXR1cm4gU2submFtZUZvclRva2VuKG8pO1xuXHRcdFx0ZWxzZSBpZiAoIGsgPT0gJ2NoaWxkcmVuJyApIHJldHVybiBvO1xuXHRcdFx0ZWxzZSBpZiAoIGsgPT09ICAnJyApIHJldHVybiBvO1xuXHRcdFx0ZWxzZSBpZiAoICFpc05hTihwYXJzZUludChrKSkgKSByZXR1cm4gbztcblx0XHRcdGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LCAnICAnKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXByb3ZlRXJyb3IoZSwgb3B0aW9ucywgY29kZSkge1xuXHRcdHZhciByO1xuXHRcdGlmICggZS5jb250ZXh0ICYmIGUuY29udGV4dC5sZW5ndGggPjAgKSB7XG5cdFx0XHRyID0gZS5jb250ZXh0WzBdO1x0XG5cdFx0fVxuXG5cdFx0aWYgKCBlLmV4dHJhICYmIGUuZXh0cmEubm9kZSApIHtcblx0XHRcdGlmICggIXIgKSB7XG5cdFx0XHRcdHIgPSBbZS5leHRyYS5ub2RlLmxvYy5zdGFydC5saW5lLGUuZXh0cmEubm9kZS5sb2Muc3RhcnQuY29sdW1uXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHIgKSB7XG5cdFx0XHRzZXRFcnJvclBvcyhlLCByWzBdLCByWzFdKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMuZnJpZW5kbHlFcnJvcnMgJiYgZS5leHRyYSApIHtcblx0XHRcdGUubWVzc2FnZSA9IG1ha2VFcnJvckZyaWVuZGx5KGUsIGNvZGUpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEVycm9yUG9zKGUsIGxpbmUsIGNvbCkge1xuXHRcdGUubG9jID0ge2xpbmU6IGxpbmUsIGNvbHVtbjogY29sfTtcblx0XHRlLmxpbmUgPSBsaW5lO1xuXHRcdGUuY29sdW1uID0gY29sO1xuXHR9XG5cblx0ZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmcocykge1xuXHRcdHN3aXRjaCAocykge1xuXHRcdGNhc2UgJ2lmX3N0bXQnOiByZXR1cm4gJ2lmIHN0YXRlbWVudCc7XG5cdFx0Y2FzZSAnd2hpbGVfc3RtdCc6IHJldHVybiAnd2hpbGUgc3RhdGVtZW50Jztcblx0XHRjYXNlICdmdW5jZGVmJzogcmV0dXJuICdmdW5jdGlvbic7XG5cdFx0ZGVmYXVsdDogcmV0dXJuICc/JyArIHMgKyAnPyc7XG5cdFx0fSBcblx0fVxuXG5cdGZ1bmN0aW9uIG5vZGVUb1R5cGUobikge1xuXHRcdHZhciB0eXBlID0gU2submFtZUZvclRva2VuKG4udHlwZSk7XG5cdFx0aWYgKCB0eXBlID09PSAnc3VpdGUnICkgcmV0dXJuIG5vZGVUb1R5cGUobi5jaGlsZHJlblswXSk7XG5cdFx0cmV0dXJuIGZyaWVuZGx5U3RyaW5nKHR5cGUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUVycm9yRnJpZW5kbHkoZSwgY29kZSkge1xuXHRcdC8vY29uc29sZS5sb2coXCJFWFwiLCBlLm1lc3NhZ2UsIGUuZXh0cmEpO1xuXHRcdGlmICggZS5leHRyYS5raW5kID09IFwiREFHX01JU1NcIiApIHtcblx0XHRcdGlmICggZS5leHRyYS5leHBlY3RlZC5pbmRleE9mKCdUX0NPTE9OJykgIT09IC0xICkge1xuXHRcdFx0XHQvL1dlIG1pZ2h0IGJlIG1pc3NpbmcgYSBjb2xvbi5cblx0XHRcdFx0dmFyIGFmdGVyID0gKGUuY29udGV4dCAmJiBlLmNvbnRleHRbMl0gPyBlLmNvbnRleHRbMl0gOiBlLmV4dHJhLmZvdW5kX3ZhbCkucmVwbGFjZSgvXFxzKyQvLCcnKTtcblx0XHRcdFx0dmFyIGxjID0gZS5leHRyYS5ub2RlLmNoaWxkcmVuW2UuZXh0cmEubm9kZS5jaGlsZHJlbi5sZW5ndGgtMV07XG5cdFx0XHRcdGlmICggbGMudmFsdWUgPT09ICdlbHNlJyApIGFmdGVyID0gJ2Vsc2UnO1xuXG5cdFx0XHRcdGlmICggZS5leHRyYS5mb3VuZCA9PSAnVF9TRU1JJyApIHtcblx0XHRcdFx0XHRyZXR1cm4gXCJSZXBsYWNlIHRoZSBgO2AgYXQgdGhlIGVuZCBvZiBgXCIgKyBhZnRlciArIFwiYCB3aXRoIGEgYDpgXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGUuZXh0cmEuZm91bmQgPT0gJ1RfTkVXTElORScgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFwiTmVlZCBhIGA6YCBvbiB0aGUgZW5kIG9mIHRoZSBsaW5lIGZvbGxvd2luZyBgXCIgKyBhZnRlciArIFwiYC5cIjtcblx0XHRcdFx0fSBlbHNlIGlmICggZS5leHRyYS5mb3VuZCA9PSAnVF9OQU1FJyApIHtcblx0XHRcdFx0XHRyZXR1cm4gXCJOZWVkIGEgYDpgIGFmdGVyIGBcIiArIGFmdGVyICsgXCJgLlwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlLmV4dHJhLmZvdW5kID09ICdUX0VRVUFMJyApIHtcblx0XHRcdFx0XHRyZXR1cm4gXCJDYW4ndCBhc3NpZ24gdG8gYSB2YXJpYWJsZSB3aXRoaW4gdGhlIGNvbmRpdGlvbiBvZiBhbiBcIiArIGZyaWVuZGx5U3RyaW5nKGUuZXh0cmEuaW5zaWRlKSArIFwiLiAgRGlkIHlvdSBtZWFuIHRvIHVzZSBgPT1gIGluc3RlYWQgb2YgYD1gP1wiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZS5leHRyYS5leHBlY3RlZC5pbmRleE9mKCdUX0RFREVOVCcpICE9PSAtMSApIHtcblx0XHRcdFx0aWYgKCBlLmV4dHJhLmZvdW5kX3ZhbC50b0xvd2VyQ2FzZSgpID09PSAnZWxzZScgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFwiYGVsc2VgIG5lZWRzIHRvIGxpbmUgdXAgd2l0aCBpdHMgYGlmYC5cIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gXCJJbmRlbnRhdGlvbiBlcnJvci5cIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGUuZXh0cmEuZXhwZWN0ZWQuaW5kZXhPZignVF9JTkRFTlQnKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHZhciBsYyA9IGUuZXh0cmEucGFyZW50IHx8IGUuZXh0cmEubm9kZTtcblx0XHRcdFx0dmFyIG5hbWUgID0gbm9kZVRvVHlwZShsYyk7XG5cdFx0XHRcdGlmICggbmFtZSA9PT0gJ2lmIHN0YXRlbWVudCcgKSB7XG5cdFx0XHRcdFx0Ly9TY2FuIGZvciB0aGUgbW9zdCByZWNlbnQgcGFydCBvZiB0aGUgaWZzdGF0ZW1lbnQuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGMuY2hpbGRyZW4ubGVuZ3RoOyArK2kgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIFtcImlmXCIsIFwiZWxpZlwiLCBcImVsc2VcIl0uaW5kZXhPZihsYy5jaGlsZHJlbltpXS52YWx1ZSkgIT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gbGMuY2hpbGRyZW5baV0udmFsdWUgKyAnIHN0YXRlbWVudCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbGMudmFsdWUgPT09ICdlbHNlJyApIG5hbWUgPSAnZWxzZSBzdGF0ZW1lbnQnO1xuXHRcdFx0XHRyZXR1cm4gJ0VtcHR5ICcgKyBuYW1lICsgJy4gUHV0IDQgc3BhY2VzIGluIGZyb250IG9mIHN0YXRlbWVudHMgaW5zaWRlIHRoZSAnICsgbmFtZSArICcuJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlLmV4dHJhLmZvdW5kID09PSAnVF9OQU1FJyApIHtcblx0XHRcdFx0c3dpdGNoICggZS5leHRyYS5mb3VuZF92YWwgKSB7XG5cdFx0XHRcdFx0Y2FzZSAnZWxzZSc6XG5cdFx0XHRcdFx0Y2FzZSAnZWxpZic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ2AnICsgZS5leHRyYS5mb3VuZF92YWwgKyAnYCBtdXN0IGJlIHBhaXJlZCB3aXRoIGFuIGBpZmAnO1xuXHRcdFx0XHRcdGNhc2UgJ2Vsc2VpZic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ2BlbHNlaWZgIHNob3VsZCBiZSBzaG9ydGVuZWQgdG8gYGVsaWZgJztcblx0XHRcdFx0fSBcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlLmV4dHJhLmZvdW5kID09PSAnVF9BTVBFUicgJiYgZS5leHRyYS5pbnNpZGUgPT0gJ2FuZF9leHByJyApIHtcblx0XHRcdFx0cmV0dXJuICdQeXRob24gdXNlcyB0aGUgd29yZCBgYW5kYCBpbnN0ZWFkIG9mIGAmJmAgZm9yIGJvb2xlYW4gQU5EIGV4cHJlc3Npb25zLic7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKCBlLmV4dHJhLmluc2lkZSA9PT0gJ3RyYWlsZXInICkge1xuXHRcdFx0XHQvL1dlIGFyZSBwYXJzaW5nIGVpdGhlciBhbiBhcmdsaXN0IG9yIGEgc3Vic2NyaXB0LlxuXHRcdFx0XHRpZiAoIGUuZXh0cmEuZXhwZWN0ZWQuaW5kZXhPZignVF9SUEFSJykgPT09IDAgKSB7XG5cdFx0XHRcdFx0Ly9FeHBlY3RlZCApLCBtdXN0IGJlIGEgYXJnbHNpdDtcblx0XHRcdFx0XHRpZiAoIGUubGluZSA+IGUuZXh0cmEubm9kZS5saW5lbm8gKSB7XG5cdFx0XHRcdFx0XHQvL091ciBhcmdsaXN0IGlzIGluY29tcGxldGUsIGFuZCB3ZSBoYXZlIG1hZGUgaXQgdG8gdGhlIG5leHQgbGluZSwuXG5cdFx0XHRcdFx0XHQvL0xpa2VseSB0aGV5IGp1c3QgZm9yZ290IHRvIGNsb3NlIHRoZWlyICgpJ3Ncblx0XHRcdFx0XHRcdHNldEVycm9yUG9zKGUsIGUuZXh0cmEubm9kZS5saW5lbm8sIGUuZXh0cmEubm9kZS5jb2xfb2Zmc2V0KTtcblx0XHRcdFx0XHRcdHZhciB0ID0gZS5leHRyYS5ub2RlLmxvYztcblx0XHRcdFx0XHRcdGUuY29udGV4dCA9IFtcblx0XHRcdFx0XHRcdFx0W3Quc3RhcnQubGluZSx0LnN0YXJ0LmNvbHVtbl0sXG5cdFx0XHRcdFx0XHRcdFt0LmVuZC5saW5lLHQuZW5kLmNvbHVtbl1cblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ1VuY2xvc2VkIGAoYCBpbiBmdW5jdGlvbiBhcmd1bWVudHMuJyArIGUuZXh0cmEubm9kZS5saW5lbm87XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICdGdW5jdGlvbiBjYWxscyBwYXJhbWF0ZXJzIG11c3QgYmUgc2VwZXJhdGVkIGJ5IGAsYHMnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZS5leHRyYS5mb3VuZCA9PT0gJ1RfSU5ERU5UJyApIHtcblx0XHRcdFx0aWYgKCBlLmV4dHJhLmV4cGVjdGVkLmluZGV4T2YoJ3N0bXQnKSAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdUb28gbXVjaCBpbmRlbnRhdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgbGluZS4nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZS5leHRyYS5leHBlY3RlZC5pbmRleE9mKCdzdWJzY3JpcHRsaXN0JykgPT09IDAgKSB7XG5cdFx0XHRcdHJldHVybiBcIk1hbGZvcm1lZCBzdWJzY3JpcHRcIjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlLmV4dHJhLmV4cGVjdGVkLmluZGV4T2YoJ1RfTkVXTElORScpICE9PSAtMSApIHtcblx0XHRcdFx0dmFyIG4gPSBlLmV4dHJhLm5vZGU7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIGUuZXh0cmEubm9kZS5jaGlsZHJlblswXSApIHtcblx0XHRcdFx0XHR2YXIgbiA9IGUuZXh0cmEubm9kZS5jaGlsZHJlblswXTtcblx0XHRcdFx0XHR2YXIgcHJldmlvdXNUeXBlID0gU2submFtZUZvclRva2VuKG4udHlwZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdGlmICggcHJldmlvdXNUeXBlID09ICdzbWFsbF9zdG10JyApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggbi5jaGlsZHJlbiAmJiBuLmNoaWxkcmVuLmxlbmd0aCA9PSAxICkgbiA9IG4uY2hpbGRyZW5bMF07XG5cdFx0XHRcdFx0XHR2YXIgd2hhdCA9IGNvZGUuc3Vic3RyaW5nKG4ucmFuZ2VbMF0sIG4ucmFuZ2VbMV0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuICdJZiB5b3Ugd2FudCB0byBjYWxsIGAnICsgd2hhdCArJ2AgYXMgZnVuY3Rpb24sIHlvdSBuZWVkIGAoKWBcXCdzJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICdVbmV4cGVjdGVkIHRva2VuOiAnICsgZS5tZXNzYWdlO1xuXHRcdH0gZWxzZSBpZiAoIGUuZXh0cmEua2luZCA9PSBcIkNMQVNTSUZZXCIgKSB7XG5cdFx0XHRpZiAoIGUuZXh0cmEudmFsdWUgPT09ICdcIicgKSByZXR1cm4gJ1VudGVybWluYXRlZCBzdHJpbmcuIEFkZCBhIG1hdGNoaW5nIGBcImAgYXQgdGhlIGVuZCBvZiB5b3VyIHN0cmluZy4nO1xuXHRcdFx0cmV0dXJuICdVbnRlcm1pbmF0ZWQgYCcgKyBlLmV4dHJhLnZhbHVlICsgJ2AnO1xuXHRcdH0gZWxzZSBpZiAoIGUuZXh0cmEua2luZCA9PSBcIlNUUklOR19FT0ZcIiApIHtcblx0XHRcdHJldHVybiAnVW50ZXJtaW5hdGVkIG11dGktbGluZSBzdHJpbmcuIEFkZCBhIG1hdGNoaW5nIGBcIlwiXCJgIGF0IHRoZSBlbmQgb2YgeW91ciBzdHJpbmcuJztcblx0XHR9IGVsc2UgaWYgKCBlLmV4dHJhLmtpbmQgPT0gXCJTVEFURU1FTlRfRU9GXCIgKSB7XG5cdFx0XHRpZiAoIGUuZXh0cmEucGFyZW5sZXYgPiAwICkge1xuXHRcdFx0XHR2YXIgdG9wID0gZS5leHRyYS5wYXJlbnN0YWNrW2UuZXh0cmEucGFyZW5zdGFjay5sZW5ndGgtMV07XG5cdFx0XHRcdHZhciBraW5kID0gdG9wWzBdO1xuXHRcdFx0XHR2YXIgdHlwZXMgPSAnKFt7Jztcblx0XHRcdFx0dmFyIHBhaXIgPSAnKV19Jztcblx0XHRcdFx0dmFyIGNsb3NlID0gcGFpclt0eXBlcy5pbmRleE9mKGtpbmQpXTtcblx0XHRcdFx0c2V0RXJyb3JQb3MoZSwgdG9wWzFdLCB0b3BbMl0tMSk7XG5cdFx0XHRcdHJldHVybiAnVW5tYXRjaGVkIGAnICsga2luZCArICdgLiAgRXZlcnkgb3BlbmluZyBgJyArIGtpbmQgKyAnYCBuZWVkcyBhIGNsb3NpbmcgYCcgKyBjbG9zZSArICdgIHRvIG1hdGNoIGl0Lic7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZS5tZXNzYWdlO1xuXHRcdH1cblxuXHRcdHJldHVybiBlLm1lc3NhZ2U7XG5cdFx0XG5cdFx0XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGltcHJvdmVFcnJvcjtcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdCAgJ3VzZSBzdHJpY3QnO1xuXHQgIGlmKHRydWUpXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ICBlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0ICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdCAgZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdCAgICBleHBvcnRzW1wiX19weXRob25SdW50aW1lXCJdID0gZmFjdG9yeSgpO1xuXHQgIGVsc2Vcblx0ICAgIHJvb3RbXCJfX3B5dGhvblJ1bnRpbWVcIl0gPSBmYWN0b3J5KCk7XG5cdH0odGhpcywgZnVuY3Rpb24oKSB7XG5cdCAgJ3VzZSBzdHJpY3QnO1xuXHQgIHZhciBweXRob25SdW50aW1lID0ge1xuXHQgICAgaW50ZXJuYWw6IHtcblx0ICAgICAgLy8gT25seSB1c2VkIHdpdGhpbiBydW50aW1lXG5cdCAgICAgIGlzU2VxOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSAmJiAoYS5fdHlwZSA9PT0gXCJsaXN0XCIgfHwgYS5fdHlwZSA9PT0gXCJ0dXBsZVwiKTsgfSxcblx0ICAgICAgc2xpY2U6IGZ1bmN0aW9uIChvYmosIHN0YXJ0LCBlbmQsIHN0ZXApIHtcblx0ICAgICAgICB2YXIgc2xpY2U7XG5cdCAgICAgICAgaWYgKCB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyApIHNsaWNlID0gZnVuY3Rpb24oeCx5KSB7IHJldHVybiBvYmouc3Vic3RyaW5nKHgseSk7IH1cblx0ICAgICAgICBlbHNlIHNsaWNlID0gb2JqLnNsaWNlLmJpbmQob2JqKTtcblxuXHQgICAgICAgIGlmIChzdGVwID09IG51bGwgfHwgc3RlcCA9PT0gMCkgc3RlcCA9IDE7IC8vIFRPRE86IHN0ZXAgPT09IDAgaXMgYSBydW50aW1lIGVycm9yXG5cdCAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcblx0ICAgICAgICAgIGlmIChzdGVwIDwgMCkgc3RhcnQgPSBvYmoubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgIGVsc2Ugc3RhcnQgPSAwO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPCAwKSBzdGFydCArPSBvYmoubGVuZ3RoO1xuXHQgICAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgaWYgKHN0ZXAgPCAwKSBlbmQgPSAtMTtcblx0ICAgICAgICAgIGVsc2UgZW5kID0gb2JqLmxlbmd0aDtcblx0ICAgICAgICB9IGVsc2UgaWYgKGVuZCA8IDApIGVuZCArPSBvYmoubGVuZ3RoO1xuXG5cdCAgICAgICAgdmFyIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpLCB0bXAsIGk7XG5cdCAgICAgICAgaWYgKHN0ZXAgPCAwKSB7XG5cdCAgICAgICAgICB0bXAgPSBzbGljZShlbmQgKyAxLCBzdGFydCArIDEpO1xuXHQgICAgICAgICAgZm9yIChpID0gdG1wLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSArPSBzdGVwKSByZXQuYXBwZW5kKHRtcFtpXSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRtcCA9IHNsaWNlKHN0YXJ0LCBlbmQpO1xuXHQgICAgICAgICAgaWYgKHN0ZXAgPT09IDEgJiYgdHlwZW9mIHRtcCAhPT0gJ3N0cmluZycpIHJldCA9IHB5dGhvblJ1bnRpbWUudXRpbHMuY3JlYXRlTGlzdCh0bXApO1xuXHQgICAgICAgICAgZWxzZSBmb3IgKGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSArPSBzdGVwKSByZXQuYXBwZW5kKHRtcFtpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICggdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgKSByZXR1cm4gcmV0LmpvaW4oJycpO1xuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgIH0sXG5cdCAgICAgIGlzSlNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICB1dGlsczoge1xuXHQgICAgICBjcmVhdGVEaWN0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMuZGljdCgpO1xuXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdClcblx0ICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzWzBdKSByZXRba10gPSBhcmd1bWVudHNbMF1ba107XG5cdCAgICAgICAgZWxzZVxuXHQgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiY3JlYXRlRGljdCBleHBlY3RzIGEgc2luZ2xlIEphdmFTY3JpcHQgb2JqZWN0XCIpO1xuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgIH0sXG5cdCAgICAgIGNyZWF0ZVBhcmFtc09iajogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIEluOiBleHByLCBleHByLCAuLi4sIHtpZDpleHByLCBfX2t3cDp0cnVlfSwge2lkOmV4cHIsIF9fa3dwOnRydWV9LCAuLi5cblx0ICAgICAgICAvLyBPdXQ6IHtmb3JtYWxzOltleHByLCBleHByLCAuLi5dLCBrZXl3b3Jkczp7aWQ6ZXhwciwgaWQ6ZXhwciwgLi4ufX1cblx0ICAgICAgICB2YXIgcGFyYW1zID0geyBmb3JtYWxzOiBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKSwga2V5d29yZHM6IG5ldyBQeXRob25EaWN0KCkgfTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAmJiBhcmd1bWVudHNbaV0uX19rd3AgPT09IHRydWUpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHNbaV0pXG5cdCAgICAgICAgICAgICAgaWYgKGsgIT09ICdfX2t3cCcpIHBhcmFtcy5rZXl3b3Jkc1trXSA9IGFyZ3VtZW50c1tpXVtrXTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGVsc2UgcGFyYW1zLmZvcm1hbHMucHVzaChhcmd1bWVudHNbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcGFyYW1zO1xuXHQgICAgICB9LFxuXHQgICAgICBjb252ZXJ0VG9MaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuXHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxpc3QsIHB5dGhvblJ1bnRpbWUudXRpbHMubGlzdFByb3BlcnR5RGVzY3JpcHRvcik7XG5cdCAgICAgICAgcmV0dXJuIGxpc3Q7XG5cdCAgICAgIH0sXG5cdCAgICAgIGNvbnZlcnRUb0RpY3Q6IGZ1bmN0aW9uIChkaWN0KSB7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGljdCwgcHl0aG9uUnVudGltZS51dGlscy5kaWN0UHJvcGVydHlEZXNjcmlwdG9yKTtcblx0ICAgICAgICByZXR1cm4gZGljdDtcblx0ICAgICAgfSwgXG5cdCAgICAgIGxpc3RQcm9wZXJ0eURlc2NyaXB0b3I6IHtcblx0ICAgICAgICAgIFwiX3R5cGVcIjoge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdsaXN0JzsgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBcIl9pc1B5dGhvblwiOiB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBcImFwcGVuZFwiOiB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICAgIHRoaXMucHVzaCh4KTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBcImNsZWFyXCI6IHtcblx0ICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICB0aGlzLnNwbGljZSgwLCB0aGlzLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgXCJjb3B5XCI6IHtcblx0ICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZSgwKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBcImNvdW50XCI6IHtcblx0ICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgICAgdmFyIGMgPSAwO1xuXHQgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSB4KSBjKys7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIGM7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgXCJlcXVhbHNcIjoge1xuXHQgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSB4Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldLmhhc093blByb3BlcnR5KFwiZXF1YWxzXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzW2ldLmVxdWFscyh4W2ldKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXNbaV0gIT09IHhbaV0pIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG5cdCAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIFwiZXh0ZW5kXCI6IHtcblx0ICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChMKSB7XG5cdCAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBMLmxlbmd0aDsgaSsrKSB0aGlzLnB1c2goTFtpXSk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgXCJpbmRleFwiOiB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoeCk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgXCJpbmRleE9mXCI6IHtcblx0ICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh4LCBmcm9tSW5kZXgpIHtcblx0ICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleCA/IGZyb21JbmRleCA6IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldLmhhc093blByb3BlcnR5KFwiZXF1YWxzXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0uZXF1YWxzKHgpKSByZXR1cm4gaTtcblx0ICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW2ldID09PSB4KSByZXR1cm4gaTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuXHQgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBcImluc2VydFwiOiB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoaSwgeCkge1xuXHQgICAgICAgICAgICAgIHRoaXMuc3BsaWNlKGksIDAsIHgpO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIFwicG9wXCI6IHtcblx0ICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGg8MSkgaSA9IHRoaXMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXNbaV07XG5cdCAgICAgICAgICAgICAgdGhpcy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgXCJfcHlTbGljZVwiOiB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCkge1xuXHQgICAgICAgICAgICAgIHJldHVybiBweXRob25SdW50aW1lLmludGVybmFsLnNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQsIHN0ZXApO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIFwicmVtb3ZlXCI6IHtcblx0ICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5zcGxpY2UodGhpcy5pbmRleE9mKHgpLCAxKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBcInNvcnRcIjoge1xuXHQgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oeCwgcmV2ZXJzZSkge1xuXHQgICAgICAgICAgICAgIHZhciBsaXN0MiA9IHRoaXMuc2xpY2UoMCk7XG5cdCAgICAgICAgICAgICAgdmFyIGFwcGx5X2tleSA9IGZ1bmN0aW9uKGEsIG51bWVyaWNhbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGxpc3QzID0gbGlzdDIubWFwKHgpO1xuXHQgICAgICAgICAgICAgICAgLy8gY29uc3RydWN0IGEgZGljdCB0aGF0IG1hcHMgdGhlIGxpc3RheSBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtYXBcblx0ICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nID0ge31cblx0ICAgICAgICAgICAgICAgIGZvcih2YXIgaSBpbiBsaXN0MykgbWFwcGluZ1tsaXN0M1tpXV0gPSBsaXN0MltpXTtcblx0ICAgICAgICAgICAgICAgIGlmKG51bWVyaWNhbClcblx0ICAgICAgICAgICAgICAgICAgbGlzdDMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cdCAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgIGxpc3QzLnNvcnQoKVxuXHQgICAgICAgICAgICAgICAgZm9yKHZhciBpIGluIGEpIGFbaV0gPSBtYXBwaW5nW2xpc3QzW2ldXTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgZm9yKHZhciBpIGluIHRoaXMpIHtcblx0ICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzW2ldICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUodGhpc1tpXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHggIT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhcHBseV9rZXkodGhpcywgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGxpc3QyLnNvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIHRoaXMpIHRoaXNbal0gPSBsaXN0MltqXTtcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICBpZihyZXZlcnNlKVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZSgpO1xuXHQgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIGlmKHR5cGVvZiB4ICE9ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgICAgICBhcHBseV9rZXkodGhpcywgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbGlzdDIuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cdCAgICAgICAgICAgICAgICBmb3IodmFyIGkgaW4gdGhpcykgdGhpc1tpXSA9IGxpc3QyW2ldO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICBpZihyZXZlcnNlKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXZlcnNlKCk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgXCJ0b1N0cmluZ1wiOiB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuICdbJyArIHRoaXMuam9pbignLCAnKSArICddJztcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgY3JlYXRlTGlzdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTtcblx0ICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSlcblx0ICAgICAgICAgIGZvciAodmFyIGkgaW4gYXJndW1lbnRzWzBdKSByZXQucHVzaChhcmd1bWVudHNbMF1baV0pO1xuXHQgICAgICAgIGVsc2Vcblx0ICAgICAgICAgIGZvciAodmFyIGkgaW4gYXJndW1lbnRzKSByZXQucHVzaChhcmd1bWVudHNbaV0pO1xuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgIH0sXG5cdCAgICAgIGRpY3RQcm9wZXJ0eURlc2NyaXB0b3I6IHtcblx0ICAgICAgICBcIl90eXBlXCI6IHtcblx0ICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2RpY3QnO30sXG5cdCAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgXCJfaXNQeXRob25cIjoge1xuXHQgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuXHQgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFwiaXRlbXNcIjoge1xuXHQgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGl0ZW1zID0gbmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy5saXN0KCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcykgaXRlbXMuYXBwZW5kKG5ldyBweXRob25SdW50aW1lLm9iamVjdHMudHVwbGUoaywgdGhpc1trXSkpO1xuXHQgICAgICAgICAgICByZXR1cm4gaXRlbXM7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFwibGVuZ3RoXCI6IHtcblx0ICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykubGVuZ3RoO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBcImNsZWFyXCI6IHtcblx0ICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcykgZGVsZXRlIHRoaXNbaV07XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFwiZ2V0XCI6IHtcblx0ICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoa2V5LCBkZWYpIHtcblx0ICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzKSByZXR1cm4gdGhpc1trZXldO1xuXHQgICAgICAgICAgICBlbHNlIGlmIChkZWYgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGRlZjtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFwia2V5c1wiOiB7XG5cdCAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcyk7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFwicG9wXCI6IHtcblx0ICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoa2V5LCBkZWYpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlO1xuXHQgICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMpIHtcblx0ICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXNba2V5XTtcblx0ICAgICAgICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGRlZiAhPT0gdW5kZWZpbmVkKSB2YWx1ZSA9IGRlZjtcblx0ICAgICAgICAgICAgZWxzZSByZXR1cm4gbmV3IEVycm9yKFwiS2V5RXJyb3JcIik7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICAgIH0sIFwidmFsdWVzXCI6IHtcblx0ICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHZhbHVlcy5hcHBlbmQodGhpc1trZXldKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIG9wczoge1xuXHQgICAgICBhZGQ6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBweXRob25SdW50aW1lLmludGVybmFsLmlzU2VxKGEpICYmIHB5dGhvblJ1bnRpbWUuaW50ZXJuYWwuaXNTZXEoYikpIHtcblx0ICAgICAgICAgIGlmIChhLl90eXBlICE9PSBiLl90eXBlKVxuXHQgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJjYW4gb25seSBjb25jYXRlbmF0ZSBcIiArIGEuX3R5cGUgKyBcIiAobm90ICdcIiArIGIuX3R5cGUgKyBcIicpIHRvIFwiICsgYS5fdHlwZSk7XG5cdCAgICAgICAgICB2YXIgcmV0O1xuXHQgICAgICAgICAgaWYgKGEuX3R5cGUgPT09ICdsaXN0JykgcmV0ID0gbmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy5saXN0KCk7XG5cdCAgICAgICAgICBlbHNlIGlmIChhLl90eXBlID09PSAndHVwbGUnKSByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLnR1cGxlKCk7XG5cdCAgICAgICAgICBpZiAocmV0KSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykgcmV0LnB1c2goYVtpXSk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykgcmV0LnB1c2goYltpXSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhICsgYjtcblx0ICAgICAgfSxcblx0ICAgICAgaW46IGZ1bmN0aW9uIChhLCBiLCBuKSB7XG5cdCAgICAgICAgdmFyIHIgPSBiLmhhc093blByb3BlcnR5KCdpbmRleE9mJykgPyBiLmluZGV4T2YoYSkgPj0gMCA6IGEgaW4gYjtcblx0ICAgICAgICByZXR1cm4gbiA/ICFyIDogcjtcblx0ICAgICAgfSxcblx0ICAgICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgLy8gVE9ETzogbm9uLXNlcXVlbmNlIG9wZXJhbmQgbXVzdCBiZSBhbiBpbnRlZ2VyXG5cdCAgICAgICAgaWYgKCB0eXBlb2YgYSA9PT0gJ29iamVjdCcgKSB7XG5cdCAgICAgICAgICBpZiAocHl0aG9uUnVudGltZS5pbnRlcm5hbC5pc1NlcShhKSAmJiAhaXNOYU4ocGFyc2VJbnQoYikpKSB7XG5cdCAgICAgICAgICAgIHZhciByZXQ7XG5cdCAgICAgICAgICAgIGlmIChhLl90eXBlID09PSAnbGlzdCcpIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpO1xuXHQgICAgICAgICAgICBlbHNlIGlmIChhLl90eXBlID09PSAndHVwbGUnKSByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLnR1cGxlKCk7XG5cdCAgICAgICAgICAgIGlmIChyZXQpIHtcblx0ICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGI7IGkrKylcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYS5sZW5ndGg7IGorKykgcmV0LnB1c2goYVtqXSk7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIGlmIChweXRob25SdW50aW1lLmludGVybmFsLmlzU2VxKGIpICYmICFpc05hTihwYXJzZUludChhKSkpIHtcblx0ICAgICAgICAgICAgdmFyIHJldDtcblx0ICAgICAgICAgICAgaWYgKGIuX3R5cGUgPT09ICdsaXN0JykgcmV0ID0gbmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy5saXN0KCk7XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGIuX3R5cGUgPT09ICd0dXBsZScpIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMudHVwbGUoKTtcblx0ICAgICAgICAgICAgaWYgKHJldCkge1xuXHQgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYTsgaSsrKVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaisrKSByZXQucHVzaChiW2pdKTtcblx0ICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhICogYjtcblx0ICAgICAgfSxcblx0ICAgICAgc3Vic2NyaXB0SW5kZXg6IGZ1bmN0aW9uIChvLCBpKSB7XG5cdCAgICAgICAgaWYgKCBpID49IDAgKSByZXR1cm4gaTtcblx0ICAgICAgICBpZiAoIHB5dGhvblJ1bnRpbWUuaW50ZXJuYWwuaXNTZXEobykgKSByZXR1cm4gby5sZW5ndGggKyBpO1xuXHQgICAgICAgIGlmICggcHl0aG9uUnVudGltZS5pbnRlcm5hbC5pc0pTQXJyYXkobykgKSByZXR1cm4gby5sZW5ndGggKyBpO1xuXHQgICAgICAgIGlmICggdHlwZW9mIG8gPT09IFwic3RyaW5nXCIgKSByZXR1cm4gby5sZW5ndGggKyBpO1xuXHQgICAgICAgIHJldHVybiBpO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICBvYmplY3RzOiB7XG5cdCAgICAgIGRpY3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb2JqID0gbmV3IFB5dGhvbkRpY3QoKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSApIG9ialthcmd1bWVudHNbaV1bMF1dID0gYXJndW1lbnRzW2ldWzFdO1xuXHQgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICAgIH0sXG5cdCAgICAgIGxpc3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJyID0gW107XG5cdCAgICAgICAgYXJyLnB1c2guYXBwbHkoYXJyLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIHB5dGhvblJ1bnRpbWUudXRpbHMuY29udmVydFRvTGlzdChhcnIpO1xuXHQgICAgICAgIHJldHVybiBhcnI7XG5cdCAgICAgIH0sXG5cdCAgICAgIHR1cGxlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyciA9IFtdO1xuXHQgICAgICAgIGFyci5wdXNoLmFwcGx5KGFyciwgYXJndW1lbnRzKTtcblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyLCBcIl90eXBlXCIsXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAndHVwbGUnOyB9LFxuXHQgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyLCBcIl9pc1B5dGhvblwiLFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcblx0ICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyciwgXCJjb3VudFwiLFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICB2YXIgYyA9IDA7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0geCkgYysrO1xuXHQgICAgICAgICAgICByZXR1cm4gYztcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnIsIFwiZXF1YWxzXCIsXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSB4Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0uaGFzT3duUHJvcGVydHkoXCJlcXVhbHNcIikpIHtcblx0ICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzW2ldLmVxdWFscyh4W2ldKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW2ldICE9PSB4W2ldKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyciwgXCJpbmRleFwiLFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHgpO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyciwgXCJpbmRleE9mXCIsXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh4LCBmcm9tSW5kZXgpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZnJvbUluZGV4ID8gZnJvbUluZGV4IDogMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldLmhhc093blByb3BlcnR5KFwiZXF1YWxzXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldLmVxdWFscyh4KSkgcmV0dXJuIGk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXNbaV0gPT09IHgpIHJldHVybiBpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG5cdCAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnIsIFwiX3B5U2xpY2VcIixcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0ZXApIHsgXG5cdCAgICAgICAgICAgIHJldHVybiBweXRob25SdW50aW1lLmludGVybmFsLnNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQsIHN0ZXApO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2Vcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyLCBcInRvU3RyaW5nXCIsXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHMgPSAnKCcgKyB0aGlzLmpvaW4oJywgJyk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcyArPSAnLCc7XG5cdCAgICAgICAgICAgIHMgKz0gJyknO1xuXHQgICAgICAgICAgICByZXR1cm4gcztcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBhcnI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cblx0ICAgIC8vIFB5dGhvbiBidWlsdC1pbiBmdW5jdGlvbnNcblxuXHQgICAgZnVuY3Rpb25zOiB7XG5cdCAgICAgIGFiczogZnVuY3Rpb24oeCkge1xuXHQgICAgICAgIHJldHVybiBNYXRoLmFicyh4KTtcblx0ICAgICAgfSxcblx0ICAgICAgYWxsOiBmdW5jdGlvbihpdGVyYWJsZSkge1xuXHQgICAgICAgIGZvciAodmFyIGkgaW4gaXRlcmFibGUpIGlmIChweXRob25SdW50aW1lLmZ1bmN0aW9ucy5ib29sKGl0ZXJhYmxlW2ldKSAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9LFxuXHQgICAgICBhbnk6IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSBpbiBpdGVyYWJsZSkgaWYgKHB5dGhvblJ1bnRpbWUuZnVuY3Rpb25zLmJvb2woaXRlcmFibGVbaV0pID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH0sXG5cdCAgICAgIGFzY2lpOiBmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICB2YXIgcyA9IHB5dGhvblJ1bnRpbWUuZnVuY3Rpb25zLnJlcHIob2JqKSxcblx0ICAgICAgICAgICAgYXNjID0gXCJcIixcblx0ICAgICAgICAgICAgY29kZTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGNvZGUgPSBzLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgICBpZiAoY29kZSA8PSAxMjcpIGFzYyArPSBzW2ldO1xuXHQgICAgICAgICAgZWxzZSBpZiAoY29kZSA8PSAweEZGKSBhc2MgKz0gXCJcXFxceFwiICsgY29kZS50b1N0cmluZygxNik7XG5cdCAgICAgICAgICBlbHNlIGlmICgweEQ4MDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REJGRikgeyAvLyBVQ1MtMiBmb3IgdGhlIGFzdHJhbCBjaGFyc1xuXHQgICAgICAgICAgICAvLyBpZiAoaSsxID49IHMubGVuZ3RoKSB0aHJvdyBcIkhpZ2ggc3Vycm9nYXRlIG5vdCBmb2xsb3dlZCBieSBsb3cgc3Vycm9nYXRlXCI7IC8vIElzIHRoaXMgbmVlZGVkP1xuXHQgICAgICAgICAgICBjb2RlID0gKChjb2RlLTB4RDgwMCkqMHg0MDApKyhzLmNoYXJDb2RlQXQoKytpKS0weERDMDApKzB4MTAwMDA7XG5cdCAgICAgICAgICAgIGFzYyArPSBcIlxcXFxVXCIgKyAoXCIwMDBcIitjb2RlLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDw9IDB4RkZGRikgYXNjICs9IFwiXFxcXHVcIiArIChcIjBcIitjb2RlLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuXHQgICAgICAgICAgZWxzZSBpZiAoY29kZSA8PSAweDEwRkZGRikgYXNjICs9IFwiXFxcXFVcIiArIChcIjAwMFwiK2NvZGUudG9TdHJpbmcoMTYpKS5zbGljZSgtOCk7XG5cdCAgICAgICAgICBlbHNlOyAvLyBJbnZhbGlkIHZhbHVlLCBzaG91bGQgcHJvYmFibHkgdGhyb3cgc29tZXRoaW5nLiBJdCBzaG91bGQgbmV2ZXIgZ2V0IGhlcmUgdGhvdWdoIGFzIHN0cmluZ3Mgc2hvdWxkbid0IGNvbnRhaW4gdGhlbSBpbiB0aGUgZmlyc3QgcGxhY2Vcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFzYztcblx0ICAgICAgfSxcblx0ICAgICAgYm9vbDogZnVuY3Rpb24oeCkge1xuXHQgICAgICAgIHJldHVybiAhKHggPT09IHVuZGVmaW5lZCB8fCAvLyBObyBhcmd1bWVudFxuXHQgICAgICAgICAgICAgICAgIHggPT09IG51bGwgfHwgLy8gTm9uZVxuXHQgICAgICAgICAgICAgICAgIHggPT09IGZhbHNlIHx8IC8vIEZhbHNlXG5cdCAgICAgICAgICAgICAgICAgeCA9PT0gMCB8fCAvLyBaZXJvXG5cdCAgICAgICAgICAgICAgICAgeC5sZW5ndGggPT09IDAgfHwgLy8gRW1wdHkgU2VxdWVuY2Vcblx0ICAgICAgICAgICAgICAgICAvLyBUT0RPOiBFbXB0eSBNYXBwaW5nLCBuZWVkcyBtb3JlIHN1cHBvcnQgZm9yIHB5dGhvbiBtYXBwaW5ncyBmaXJzdFxuXHQgICAgICAgICAgICAgICAgICh4Ll9fYm9vbF9fICE9PSB1bmRlZmluZWQgJiYgeC5fX2Jvb2xfXygpID09PSBmYWxzZSkgfHwgLy8gSWYgaXQgaGFzIGJvb2wgY29udmVyc2lvbiBkZWZpbmVkXG5cdCAgICAgICAgICAgICAgICAgKHguX19sZW5fXyAhPT0gdW5kZWZpbmVkICYmICh4Ll9fbGVuX18oKSA9PT0gZmFsc2UgfHwgeC5fX2xlbl9fKCkgPT09IDApKSk7IC8vIElmIGl0IGhhcyBsZW5ndGggY29udmVyc2lvbiBkZWZpbmVkXG5cdCAgICAgIH0sXG5cdCAgICAgIGNocjogZnVuY3Rpb24oaSkge1xuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpOyAvLyBUT0RPOiBFcnJvciBjb2RlIGZvciBub3QgMCA8PSBpIDw9IDExMTQxMTFcblx0ICAgICAgfSxcblx0ICAgICAgZGl2bW9kOiBmdW5jdGlvbihhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIHB5dGhvblJ1bnRpbWUub2JqZWN0cy50dXBsZShNYXRoLmZsb29yKGEvYiksIGElYik7XG5cdCAgICAgIH0sXG5cdCAgICAgIGVudW1lcmF0ZTogZnVuY3Rpb24oaXRlcmFibGUsIHN0YXJ0KSB7XG5cdCAgICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuXHQgICAgICAgIHZhciByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTtcblx0ICAgICAgICBmb3IgKHZhciBpIGluIGl0ZXJhYmxlKSByZXQucHVzaChuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLnR1cGxlKHN0YXJ0KyssIGl0ZXJhYmxlW2ldKSk7XG5cdCAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgfSxcblx0ICAgICAgZmlsdGVyOiBmdW5jdGlvbihmbiwgaXRlcmFibGUpIHtcblx0ICAgICAgICBmbiA9IGZuIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG5cdCAgICAgICAgdmFyIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpO1xuXHQgICAgICAgIGZvciAodmFyIGkgaW4gaXRlcmFibGUpIGlmIChmbihpdGVyYWJsZVtpXSkpIHJldC5wdXNoKGl0ZXJhYmxlW2ldKTtcblx0ICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICB9LFxuXHQgICAgICBmbG9hdDogZnVuY3Rpb24oeCkge1xuXHQgICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHJldHVybiAwLjA7XG5cdCAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggPT0gXCJzdHJpbmdcIikgeyAvLyBUT0RPOiBGaXggdHlwZSBjaGVja1xuXHQgICAgICAgICAgeCA9IHgudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICBpZiAoKC9eWystXT9pbmYoaW5pdHkpPyQvaSkuZXhlYyh4KSAhPT0gbnVsbCkgcmV0dXJuIEluZmluaXR5Kih4WzBdPT09XCItXCI/LTE6MSk7XG5cdCAgICAgICAgICBlbHNlIGlmICgoL15uYW4kL2kpLmV4ZWMoeCkgIT09IG51bGwpIHJldHVybiBOYU47XG5cdCAgICAgICAgICBlbHNlIHJldHVybiBwYXJzZUZsb2F0KHgpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHggPT0gXCJudW1iZXJcIikgeyAvLyBUT0RPOiBGaXggdHlwZSBjaGVja1xuXHQgICAgICAgICAgcmV0dXJuIHg7IC8vIFRPRE86IEdldCBweXRob24gdHlwZXMgd29ya2luZyByaWdodCBzbyB3ZSBjYW4gcmV0dXJuIGFuIGFjdHVhbCBmbG9hdFxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpZiAoeC5fX2Zsb2F0X18gIT09IHVuZGVmaW5lZCkgcmV0dXJuIHguX19mbG9hdF9fKCk7XG5cdCAgICAgICAgICBlbHNlIHJldHVybiBudWxsOyAvLyBUT0RPOiBUaHJvdyBUeXBlRXJyb3I6IGZsb2F0KCkgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBhIG51bWJlciwgbm90ICc8dHlwZSBvZiB4Pidcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIGhleDogZnVuY3Rpb24oeCkge1xuXHQgICAgICAgIHJldHVybiB4LnRvU3RyaW5nKDE2KTtcblx0ICAgICAgfSxcblx0ICAgICAgaW50OiBmdW5jdGlvbiAocykge1xuXHQgICAgICAgIHJldHVybiBwYXJzZUludChzKTtcblx0ICAgICAgfSxcblx0ICAgICAgbGVuOiBmdW5jdGlvbiAobykge1xuXHQgICAgICAgIHJldHVybiBvLmxlbmd0aDtcblx0ICAgICAgfSxcblx0ICAgICAgbGlzdDogZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG5cdCAgICAgICAgdmFyIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpO1xuXHQgICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PSAwICkgcmV0dXJuIHJldDtcblx0ICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCgpIHRha2VzIGF0IG1vc3QgMSBhcmd1bWVudCAoJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGdpdmVuKScpO1xuXHQgICAgICAgIGlmIChpdGVyYWJsZSBpbnN0YW5jZW9mIEFycmF5KSBmb3IgKHZhciBpIGluIGl0ZXJhYmxlKSByZXQucHVzaChpdGVyYWJsZVtpXSk7XG5cdCAgICAgICAgZWxzZSBmb3IgKHZhciBpIGluIGl0ZXJhYmxlKSByZXQucHVzaChpKTtcblx0ICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICB9LFxuXHQgICAgICBtYXA6IGZ1bmN0aW9uKGZuLCBpdGVyYWJsZSkge1xuXHQgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYWRkaXRpb25hbCBpdGVyYWJsZXMgcGFzc2VkXG5cdCAgICAgICAgdmFyIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpO1xuXHQgICAgICAgIGZvciAodmFyIGkgaW4gaXRlcmFibGUpIHJldC5wdXNoKGZuKGl0ZXJhYmxlW2ldKSk7XG5cdCAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgfSxcblx0ICAgICAgbWF4OiBmdW5jdGlvbihhcmcxLCBhcmcyKSB7XG5cdCAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBvcHRpb25hbCBrZXl3b3JkLW9ubHkgYXJndW1lbnRzXG5cdCAgICAgICAgLy8gVE9ETzogZW1wdHkgaXRlcmFibGUgcmFpc2VzIFB5dGhvbiBWYWx1ZUVycm9yXG5cdCAgICAgICAgaWYgKCFhcmcyKSB7IC8vIGl0ZXJhYmxlXG5cdCAgICAgICAgICB2YXIgbWF4ID0gbnVsbDtcblx0ICAgICAgICAgIGZvciAodmFyIGkgaW4gYXJnMSkgaWYgKG1heCA9PT0gbnVsbCB8fCBhcmcxW2ldID4gbWF4KSBtYXggPSBhcmcxW2ldO1xuXHQgICAgICAgICAgcmV0dXJuIG1heDtcblx0ICAgICAgICB9IGVsc2UgcmV0dXJuIGFyZzEgPj0gYXJnMiA/IGFyZzEgOiBhcmcyO1xuXHQgICAgICB9LFxuXHQgICAgICBtaW46IGZ1bmN0aW9uKGFyZzEsIGFyZzIpIHtcblx0ICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IG9wdGlvbmFsIGtleXdvcmQtb25seSBhcmd1bWVudHNcblx0ICAgICAgICAvLyBUT0RPOiBlbXB0eSBpdGVyYWJsZSByYWlzZXMgUHl0aG9uIFZhbHVlRXJyb3Jcblx0ICAgICAgICBpZiAoIWFyZzIpIHsgLy8gaXRlcmFibGVcblx0ICAgICAgICAgIHZhciBtYXggPSBudWxsO1xuXHQgICAgICAgICAgZm9yICh2YXIgaSBpbiBhcmcxKSBpZiAobWF4ID09PSBudWxsIHx8IGFyZzFbaV0gPCBtYXgpIG1heCA9IGFyZzFbaV07XG5cdCAgICAgICAgICByZXR1cm4gbWF4O1xuXHQgICAgICAgIH0gZWxzZSByZXR1cm4gYXJnMSA8PSBhcmcyID8gYXJnMSA6IGFyZzI7XG5cdCAgICAgIH0sXG5cdCAgICAgIG9jdDogZnVuY3Rpb24oeCkge1xuXHQgICAgICAgIHJldHVybiB4LnRvU3RyaW5nKDgpO1xuXHQgICAgICB9LFxuXHQgICAgICBvcmQ6IGZ1bmN0aW9uKGMpIHtcblx0ICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuXHQgICAgICB9LFxuXHQgICAgICBwb3c6IGZ1bmN0aW9uKHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4geiA/IE1hdGgucG93KHgsIHkpICUgeiA6IE1hdGgucG93KHgsIHkpO1xuXHQgICAgICB9LFxuXHQgICAgICBwcmludDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBzID0gXCJcIjtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgIHMgKz0gaSA9PT0gMCA/IGFyZ3VtZW50c1tpXSA6IFwiIFwiICsgYXJndW1lbnRzW2ldO1xuXHQgICAgICAgIGNvbnNvbGUubG9nKHMpO1xuXHQgICAgICB9LFxuXHQgICAgICByYW5nZTogZnVuY3Rpb24gKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG5cdCAgICAgICAgaWYgKHN0b3AgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgc3RvcCA9IHN0YXJ0O1xuXHQgICAgICAgICAgc3RhcnQgPSAwO1xuXHQgICAgICAgICAgc3RlcCA9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgc3RlcCA9IDE7XG5cdCAgICAgICAgdmFyIGxlbiA9IH5+KChzdG9wIC0gc3RhcnQpIC8gc3RlcCk7IC8vfn4gaXMgYSBmYXN0IGZsb29yXG5cdCAgICAgICAgaWYgKCBsZW4gPCAwICkgcmV0dXJuIHB5dGhvblJ1bnRpbWUudXRpbHMuY29udmVydFRvTGlzdChbXSk7XG5cdCAgICAgICAgdmFyIHIgPSBuZXcgQXJyYXkobGVuKTtcblx0ICAgICAgICB2YXIgZWxlbWVudCA9IDA7XG5cblx0ICAgICAgICB2YXIgaSA9IHN0YXJ0O1xuXHQgICAgICAgIHdoaWxlIChpIDwgc3RvcCAmJiBzdGVwID4gMCB8fCBpID4gc3RvcCAmJiBzdGVwIDwgMCkge1xuXHQgICAgICAgICAgcltlbGVtZW50KytdID0gaTtcblx0ICAgICAgICAgIGkgKz0gc3RlcDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBweXRob25SdW50aW1lLnV0aWxzLmNvbnZlcnRUb0xpc3Qocik7XG5cdCAgICAgICAgcmV0dXJuIHI7XG5cdCAgICAgIH0sXG5cdCAgICAgIHJlcHI6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHJldHVybiBcIidcIiArIG9iaiArIFwiJ1wiOyAvLyBUT0RPOiBQYXRjaCB1bnRpbCB0eXBlc3lzdGVtIGNvbWVzIHVwLlxuXHQgICAgICAgIGlmIChvYmouX19yZXByX18gIT09IHVuZGVmaW5lZCkgcmV0dXJuIG9iai5fX3JlcHJfXygpO1xuXHQgICAgICAgIGVsc2UgaWYgKG9iai5fX2NsYXNzX18gIT09IHVuZGVmaW5lZCAmJiBvYmouX19jbGFzc19fLm1vZHVsZSAhPT0gdW5kZWZpbmVkICYmIG9iai5fX2NsYXNzX18uX19uYW1lX18pIHtcblx0ICAgICAgICAgIHJldHVybiAnPCcrb2JqLl9fY2xhc3NfXy5fX21vZHVsZV9fKycuJytvYmouX19jbGFzc19fLl9fbmFtZV9fKycgb2JqZWN0Pic7XG5cdCAgICAgICAgfSBlbHNlIHJldHVybiBvYmoudG9TdHJpbmcoKTsgLy8gUmFpc2UgYSBwbGVhc2UgcmVwb3J0IHdhcm5pbmcgaGVyZSwgd2Ugc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgcGllY2Ugb2YgY29kZVxuXHQgICAgICB9LFxuXHQgICAgICByZXZlcnNlZDogZnVuY3Rpb24gKHNlcSkge1xuXHQgICAgICAgIHZhciByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTtcblx0ICAgICAgICBmb3IgKHZhciBpIGluIHNlcSkgcmV0LnB1c2goc2VxW2ldKTtcblx0ICAgICAgICByZXR1cm4gcmV0LnJldmVyc2UoKTtcblx0ICAgICAgfSxcblx0ICAgICAgcm91bmQ6IGZ1bmN0aW9uIChudW0sIG5kaWdpdHMpIHtcblx0ICAgICAgICBpZiAobmRpZ2l0cykge1xuXHQgICAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpO1xuXHQgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtICogc2NhbGUpIC8gc2NhbGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSk7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNvcnRlZDogZnVuY3Rpb24gKGl0ZXJhYmxlLCBrZXksIHJldmVyc2UpIHtcblx0ICAgICAgICB2YXIgcmV0ID0gbmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy5saXN0KCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSBpbiBpdGVyYWJsZSkgcmV0LnB1c2goaXRlcmFibGVbaV0pO1xuXHQgICAgICAgIGlmKGtleSkgcmV0LnNvcnQoa2V5KTsgZWxzZSByZXQuc29ydCgpO1xuXHQgICAgICAgIGlmIChyZXZlcnNlKSByZXQucmV2ZXJzZSgpO1xuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgIH0sXG5cdCAgICAgIHN0cjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIHJldHVybiBvYmoudG9TdHJpbmcoKTtcblx0ICAgICAgfSxcblx0ICAgICAgc3VtOiBmdW5jdGlvbiAoaXRlcmFibGUsIHN0YXJ0KSB7XG5cdCAgICAgICAgLy8gVE9ETzogc3RhcnQgY2FuJ3QgYmUgYSBzdHJpbmdcblx0ICAgICAgICB2YXIgcmV0ID0gc3RhcnQgfHwgMDtcblx0ICAgICAgICBmb3IgKHZhciBpIGluIGl0ZXJhYmxlKSByZXQgKz0gaXRlcmFibGVbaV07XG5cdCAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgfSxcblx0ICAgICAgdHVwbGU6IGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuXHQgICAgICAgIHZhciByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLnR1cGxlKCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSBpbiBpdGVyYWJsZSkgcmV0LnB1c2goaXRlcmFibGVbaV0pO1xuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cblx0ICAgIC8vIFB5dGhvbiBpbXBvcnRzXG5cdCAgICAvLyBUT0RPOiBmcm9tIHggaW1wb3J0IHksIHpcblxuXHQgICAgaW1wb3J0czoge1xuXHQgICAgICByYW5kb206IHtcblx0ICAgICAgICByYW5kb206IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hdGgucmFuZG9tKCk7IH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBQeXRob25EaWN0KCkge1xuXG5cdCAgfVxuXG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUHl0aG9uRGljdC5wcm90b3R5cGUsIHB5dGhvblJ1bnRpbWUudXRpbHMuZGljdFByb3BlcnR5RGVzY3JpcHRvcik7XG5cdCAgcmV0dXJuIHB5dGhvblJ1bnRpbWU7XG5cdH0pKTtcblxuXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xud2luZG93LmFldGhlckZpbGJlcnQgPSByZXF1aXJlKCdza3VscHR5Jyk7XG53aW5kb3cuYWV0aGVyRmlsYmVydExvb3NlID0gcmVxdWlyZSgnc2t1bHB0eScpO1xuXG59LHtcInNrdWxwdHlcIjoxfV19LHt9LFsyXSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ib3dlcl9jb21wb25lbnRzL2FldGhlci9idWlsZC9weXRob24uanNcbi8vIG1vZHVsZSBpZCA9IDc4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMTAgNzMgODUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///780\n");

/***/ })

});